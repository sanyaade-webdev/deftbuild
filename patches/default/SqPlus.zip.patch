diff -rupwN ../dnl3/SqPlus/include/sqstdstring.h SqPlus/include/sqstdstring.h
--- ../dnl3/SqPlus/include/sqstdstring.h	2005-09-25 17:56:20.000000000 -0400
+++ SqPlus/include/sqstdstring.h	2006-08-15 14:08:47.000000000 -0400
@@ -6,9 +6,6 @@
 extern "C" {
 #endif
 
-//#define SQRex_True 1
-//#define SQRex_False 0
-
 typedef unsigned int SQRexBool;
 typedef struct SQRex SQRex;
 
diff -rupwN ../dnl3/SqPlus/include/squirrel.h SqPlus/include/squirrel.h
--- ../dnl3/SqPlus/include/squirrel.h	2006-04-25 13:38:08.000000000 -0400
+++ SqPlus/include/squirrel.h	2009-03-30 15:06:24.000000000 -0400
@@ -1,5 +1,5 @@
 /*
-Copyright (c) 2003-2006 Alberto Demichelis
+Copyright (c) 2003-2008 Alberto Demichelis
 
 This software is provided 'as-is', without any 
 express or implied warranty. In no event will the 
@@ -39,6 +39,10 @@ extern "C" {
 #define SQUIRREL_API extern
 #endif
 
+#if (defined(_WIN64) || defined(_LP64))
+#define _SQ64
+#endif
+
 #ifdef _SQ64
 #ifdef _MSC_VER
 typedef __int64 SQInteger;
@@ -57,6 +61,7 @@ typedef unsigned int SQUnsignedInteger;
 typedef unsigned int SQHash; /*should be the same size of a pointer*/
 #endif
 
+
 typedef float SQFloat;
 typedef void* SQUserPointer;
 typedef SQUnsignedInteger SQBool;
@@ -65,7 +70,6 @@ typedef SQInteger SQRESULT;
 #define SQTrue	(1)
 #define SQFalse	(0)
 
-
 struct SQVM;
 struct SQTable;
 struct SQArray;
@@ -85,33 +89,32 @@ struct SQDelegable;
 #endif
 
 #ifdef SQUNICODE
-
 #if (defined(_MSC_VER) && _MSC_VER >= 1400) // 1400 = VS8
-#define SQUNICODE_VS8
-//#pragma message("*** VS8 Compiler")
 
 #if defined(wchar_t) //this is if the compiler considers wchar_t as native type
 #define wchar_t unsigned short
-//#pragma message("*** Defining w_char_t")
 #endif
 
 #else
-
-//#pragma message("*** VS7.1 Compiler")
-
+#if defined( _MSC_VER )
 typedef unsigned short wchar_t;
-
+#endif
 #endif
 
 typedef wchar_t SQChar;
-
 #define _SC(a) L##a
 #define	scstrcmp	wcscmp
 #define scsprintf	swprintf
 #define scstrlen	wcslen
 #define scstrtod	wcstod
 #define scstrtol	wcstol
+#ifdef _MSC_VER
 #define scatoi		_wtoi
+#else
+  #include <wchar.h>
+  #include <wctype.h>
+  #define scatoi( s ) wcstol( s, NULL, 10 )
+#endif
 #define scstrtoul	wcstoul
 #define scvsprintf	vswprintf
 #define scstrstr	wcsstr
@@ -145,8 +148,8 @@ typedef char SQChar;
 #define MAX_CHAR 0xFF
 #endif
 
-#define SQUIRREL_VERSION	_SC("Squirrel 2.1 stable")
-#define SQUIRREL_COPYRIGHT	_SC("Copyright (C) 2003-2006 Alberto Demichelis")
+#define SQUIRREL_VERSION	_SC("Squirrel 2.2.2 stable")
+#define SQUIRREL_COPYRIGHT	_SC("Copyright (C) 2003-2008 Alberto Demichelis")
 #define SQUIRREL_AUTHOR		_SC("Alberto Demichelis")
 
 #define SQ_VMSTATE_IDLE			0
@@ -231,8 +234,8 @@ typedef union tagSQObjectValue
 
 typedef struct tagSQObject
 {
-	SQObjectValue _unVal;
 	SQObjectType _type;
+	SQObjectValue _unVal;
 }SQObject;
 
 typedef struct tagSQStackInfos{
@@ -325,6 +328,7 @@ SQUIRREL_API SQRESULT sq_getclosureinfo(
 SQUIRREL_API SQRESULT sq_setnativeclosurename(HSQUIRRELVM v,SQInteger idx,const SQChar *name);
 SQUIRREL_API SQRESULT sq_setinstanceup(HSQUIRRELVM v, SQInteger idx, SQUserPointer p);
 SQUIRREL_API SQRESULT sq_getinstanceup(HSQUIRRELVM v, SQInteger idx, SQUserPointer *p,SQUserPointer typetag);
+SQUIRREL_API SQRESULT sq_setclassudsize(HSQUIRRELVM v, SQInteger idx, SQInteger udsize);
 SQUIRREL_API SQRESULT sq_newclass(HSQUIRRELVM v,SQBool hasbase);
 SQUIRREL_API SQRESULT sq_createinstance(HSQUIRRELVM v,SQInteger idx);
 SQUIRREL_API SQRESULT sq_setattributes(HSQUIRRELVM v,SQInteger idx);
@@ -336,9 +340,10 @@ SQUIRREL_API SQRESULT sq_getdefaultdeleg
 /*object manipulation*/
 SQUIRREL_API void sq_pushroottable(HSQUIRRELVM v);
 SQUIRREL_API void sq_pushregistrytable(HSQUIRRELVM v);
+SQUIRREL_API void sq_pushconsttable(HSQUIRRELVM v);
 SQUIRREL_API SQRESULT sq_setroottable(HSQUIRRELVM v);
-/*SQUIRREL_API SQRESULT sq_createslot(HSQUIRRELVM v,SQInteger idx);*/
-SQRESULT sq_newslot(HSQUIRRELVM v, SQInteger idx, SQBool bstatic);
+SQUIRREL_API SQRESULT sq_setconsttable(HSQUIRRELVM v);
+SQUIRREL_API SQRESULT sq_newslot(HSQUIRRELVM v, SQInteger idx, SQBool bstatic);
 SQUIRREL_API SQRESULT sq_deleteslot(HSQUIRRELVM v,SQInteger idx,SQBool pushval);
 SQUIRREL_API SQRESULT sq_set(HSQUIRRELVM v,SQInteger idx);
 SQUIRREL_API SQRESULT sq_get(HSQUIRRELVM v,SQInteger idx);
@@ -349,12 +354,15 @@ SQUIRREL_API SQRESULT sq_arrayappend(HSQ
 SQUIRREL_API SQRESULT sq_arraypop(HSQUIRRELVM v,SQInteger idx,SQBool pushval); 
 SQUIRREL_API SQRESULT sq_arrayresize(HSQUIRRELVM v,SQInteger idx,SQInteger newsize); 
 SQUIRREL_API SQRESULT sq_arrayreverse(HSQUIRRELVM v,SQInteger idx); 
+SQUIRREL_API SQRESULT sq_arrayremove(HSQUIRRELVM v,SQInteger idx,SQInteger itemidx);
+SQUIRREL_API SQRESULT sq_arrayinsert(HSQUIRRELVM v,SQInteger idx,SQInteger destpos);
 SQUIRREL_API SQRESULT sq_setdelegate(HSQUIRRELVM v,SQInteger idx);
 SQUIRREL_API SQRESULT sq_getdelegate(HSQUIRRELVM v,SQInteger idx);
 SQUIRREL_API SQRESULT sq_clone(HSQUIRRELVM v,SQInteger idx);
 SQUIRREL_API SQRESULT sq_setfreevariable(HSQUIRRELVM v,SQInteger idx,SQUnsignedInteger nval);
 SQUIRREL_API SQRESULT sq_next(HSQUIRRELVM v,SQInteger idx);
 SQUIRREL_API SQRESULT sq_getweakrefval(HSQUIRRELVM v,SQInteger idx);
+SQUIRREL_API SQRESULT sq_clear(HSQUIRRELVM v,SQInteger idx);
 
 /*calls*/
 SQUIRREL_API SQRESULT sq_call(HSQUIRRELVM v,SQInteger params,SQBool retval,SQBool raiseerror);
diff -rupwN ../dnl3/SqPlus/sq/Makefile SqPlus/sq/Makefile
--- ../dnl3/SqPlus/sq/Makefile	2006-03-19 14:32:58.000000000 -0500
+++ SqPlus/sq/Makefile	1969-12-31 19:00:00.000000000 -0500
@@ -1,21 +0,0 @@
-SQUIRREL= ..
-
-
-OUT= $(SQUIRREL)/bin/sq
-INCZ= -I$(SQUIRREL)/include -I. -I$(SQUIRREL)/sqlibs
-LIBZ= -L$(SQUIRREL)/lib 
-LIB= -lsquirrel -lsqstdlib
-
-OBJS= sq.o
-	
-SRCS= sq.c
-	
-	
-sq32:
-	g++ -O2 -fno-rtti -o $(OUT) $(SRCS) $(INCZ) $(LIBZ) $(LIB)
-
-sqprof:
-	g++ -O2 -pg -fno-rtti -pie -gstabs -g3 -o $(OUT) $(SRCS) $(INCZ) $(LIBZ) $(LIB)
-	
-sq64:
-	g++ -O2 -fno-rtti -D_SQ64 -o $(OUT) $(SRCS) $(INCZ) $(LIBZ) $(LIB)
\ No newline at end of file
diff -rupwN ../dnl3/SqPlus/sq/sq71.vcproj SqPlus/sq/sq71.vcproj
--- ../dnl3/SqPlus/sq/sq71.vcproj	2006-05-29 15:10:46.000000000 -0400
+++ SqPlus/sq/sq71.vcproj	1969-12-31 19:00:00.000000000 -0500
@@ -1,317 +0,0 @@
-<?xml version="1.0" encoding="Windows-1252"?>
-<VisualStudioProject
-	ProjectType="Visual C++"
-	Version="7.10"
-	Name="sq"
-	RootNamespace="sq"
-	SccProjectName=""
-	SccLocalPath="..">
-	<Platforms>
-		<Platform
-			Name="Win32"/>
-	</Platforms>
-	<Configurations>
-		<Configuration
-			Name="Release|Win32"
-			OutputDirectory="$(ConfigurationName)"
-			IntermediateDirectory="$(ConfigurationName)"
-			ConfigurationType="1"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="FALSE"
-			CharacterSet="2">
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="2"
-				InlineFunctionExpansion="1"
-				AdditionalIncludeDirectories="..\include,..\sqstdlib"
-				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE"
-				StringPooling="TRUE"
-				RuntimeLibrary="0"
-				EnableFunctionLevelLinking="TRUE"
-				UsePrecompiledHeader="0"
-				PrecompiledHeaderFile=".\Release/sq.pch"
-				AssemblerListingLocation="$(IntDir)/"
-				ObjectFile="$(IntDir)/"
-				ProgramDataBaseFileName="$(IntDir)/"
-				WarningLevel="3"
-				SuppressStartupBanner="TRUE"
-				CompileAs="0"/>
-			<Tool
-				Name="VCCustomBuildTool"/>
-			<Tool
-				Name="VCLinkerTool"
-				OutputFile="../bin/sq.exe"
-				LinkIncremental="1"
-				SuppressStartupBanner="TRUE"
-				AdditionalLibraryDirectories="../lib"
-				ProgramDatabaseFile=".\Release/sq.pdb"
-				SubSystem="1"
-				TargetMachine="1"/>
-			<Tool
-				Name="VCMIDLTool"
-				TypeLibraryName=".\Release/sq.tlb"
-				HeaderFileName=""/>
-			<Tool
-				Name="VCPostBuildEventTool"/>
-			<Tool
-				Name="VCPreBuildEventTool"/>
-			<Tool
-				Name="VCPreLinkEventTool"/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="NDEBUG"
-				Culture="1040"/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"/>
-			<Tool
-				Name="VCWebDeploymentTool"/>
-			<Tool
-				Name="VCManagedWrapperGeneratorTool"/>
-			<Tool
-				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
-		</Configuration>
-		<Configuration
-			Name="Debug|Win32"
-			OutputDirectory="$(ConfigurationName)"
-			IntermediateDirectory="$(ConfigurationName)"
-			ConfigurationType="1"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="FALSE"
-			CharacterSet="2">
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="..\include,..\sqstdlib"
-				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE"
-				BasicRuntimeChecks="3"
-				RuntimeLibrary="1"
-				UsePrecompiledHeader="2"
-				PrecompiledHeaderFile=".\Debug/sq.pch"
-				AssemblerListingLocation="$(IntDir)/"
-				ObjectFile="$(IntDir)/"
-				ProgramDataBaseFileName="$(IntDir)/"
-				WarningLevel="3"
-				SuppressStartupBanner="TRUE"
-				DebugInformationFormat="4"
-				CompileAs="0"/>
-			<Tool
-				Name="VCCustomBuildTool"/>
-			<Tool
-				Name="VCLinkerTool"
-				OutputFile="../bin/sqD.exe"
-				LinkIncremental="2"
-				SuppressStartupBanner="TRUE"
-				AdditionalLibraryDirectories="../lib"
-				GenerateDebugInformation="TRUE"
-				ProgramDatabaseFile=".\Debug/sq.pdb"
-				SubSystem="1"
-				TargetMachine="1"/>
-			<Tool
-				Name="VCMIDLTool"
-				TypeLibraryName=".\Debug/sq.tlb"
-				HeaderFileName=""/>
-			<Tool
-				Name="VCPostBuildEventTool"/>
-			<Tool
-				Name="VCPreBuildEventTool"/>
-			<Tool
-				Name="VCPreLinkEventTool"/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="_DEBUG"
-				Culture="1040"/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"/>
-			<Tool
-				Name="VCWebDeploymentTool"/>
-			<Tool
-				Name="VCManagedWrapperGeneratorTool"/>
-			<Tool
-				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
-		</Configuration>
-		<Configuration
-			Name="Debug - Unicode|Win32"
-			OutputDirectory="$(ConfigurationName)"
-			IntermediateDirectory="$(ConfigurationName)"
-			ConfigurationType="1"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="FALSE"
-			CharacterSet="1">
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="..\include,..\sqstdlib"
-				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE"
-				BasicRuntimeChecks="3"
-				RuntimeLibrary="1"
-				UsePrecompiledHeader="2"
-				PrecompiledHeaderFile=".\Debug/sq.pch"
-				AssemblerListingLocation="$(IntDir)/"
-				ObjectFile="$(IntDir)/"
-				ProgramDataBaseFileName="$(IntDir)/"
-				WarningLevel="3"
-				SuppressStartupBanner="TRUE"
-				DebugInformationFormat="4"
-				CompileAs="0"/>
-			<Tool
-				Name="VCCustomBuildTool"/>
-			<Tool
-				Name="VCLinkerTool"
-				OutputFile="../bin/sqDU.exe"
-				LinkIncremental="2"
-				SuppressStartupBanner="TRUE"
-				AdditionalLibraryDirectories="../lib"
-				GenerateDebugInformation="TRUE"
-				ProgramDatabaseFile=".\Debug/sq.pdb"
-				SubSystem="1"
-				TargetMachine="1"/>
-			<Tool
-				Name="VCMIDLTool"
-				TypeLibraryName=".\Debug/sq.tlb"
-				HeaderFileName=""/>
-			<Tool
-				Name="VCPostBuildEventTool"/>
-			<Tool
-				Name="VCPreBuildEventTool"/>
-			<Tool
-				Name="VCPreLinkEventTool"/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="_DEBUG"
-				Culture="1040"/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"/>
-			<Tool
-				Name="VCWebDeploymentTool"/>
-			<Tool
-				Name="VCManagedWrapperGeneratorTool"/>
-			<Tool
-				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
-		</Configuration>
-		<Configuration
-			Name="Release - Unicode|Win32"
-			OutputDirectory="$(ConfigurationName)"
-			IntermediateDirectory="$(ConfigurationName)"
-			ConfigurationType="1"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="FALSE"
-			CharacterSet="1">
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="2"
-				InlineFunctionExpansion="1"
-				AdditionalIncludeDirectories="..\include,..\sqstdlib"
-				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE"
-				StringPooling="TRUE"
-				RuntimeLibrary="0"
-				EnableFunctionLevelLinking="TRUE"
-				UsePrecompiledHeader="0"
-				PrecompiledHeaderFile=".\Release/sq.pch"
-				AssemblerListingLocation="$(IntDir)/"
-				ObjectFile="$(IntDir)/"
-				ProgramDataBaseFileName="$(IntDir)/"
-				WarningLevel="3"
-				SuppressStartupBanner="TRUE"
-				CompileAs="0"/>
-			<Tool
-				Name="VCCustomBuildTool"/>
-			<Tool
-				Name="VCLinkerTool"
-				OutputFile="../bin/sqU.exe"
-				LinkIncremental="1"
-				SuppressStartupBanner="TRUE"
-				AdditionalLibraryDirectories="../lib"
-				ProgramDatabaseFile=".\Release/sq.pdb"
-				SubSystem="1"
-				TargetMachine="1"/>
-			<Tool
-				Name="VCMIDLTool"
-				TypeLibraryName=".\Release/sq.tlb"
-				HeaderFileName=""/>
-			<Tool
-				Name="VCPostBuildEventTool"/>
-			<Tool
-				Name="VCPreBuildEventTool"/>
-			<Tool
-				Name="VCPreLinkEventTool"/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="NDEBUG"
-				Culture="1040"/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"/>
-			<Tool
-				Name="VCWebDeploymentTool"/>
-			<Tool
-				Name="VCManagedWrapperGeneratorTool"/>
-			<Tool
-				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
-		</Configuration>
-	</Configurations>
-	<References>
-	</References>
-	<Files>
-		<Filter
-			Name="Source Files"
-			Filter="cpp;c;cxx;rc;def;r;odl;idl;hpj;bat">
-			<File
-				RelativePath="sq.c">
-				<FileConfiguration
-					Name="Release|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug - Unicode|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release - Unicode|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""/>
-				</FileConfiguration>
-			</File>
-		</Filter>
-		<Filter
-			Name="Header Files"
-			Filter="h;hpp;hxx;hm;inl">
-		</Filter>
-		<Filter
-			Name="Resource Files"
-			Filter="ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe">
-		</Filter>
-		<File
-			RelativePath="..\etc\test.nut">
-		</File>
-	</Files>
-	<Globals>
-	</Globals>
-</VisualStudioProject>
diff -rupwN ../dnl3/SqPlus/sq/sq.c SqPlus/sq/sq.c
--- ../dnl3/SqPlus/sq/sq.c	2006-04-25 13:38:08.000000000 -0400
+++ SqPlus/sq/sq.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,325 +0,0 @@
-/*	see copyright notice in squirrel.h */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <stdarg.h>
-
-#if defined(_MSC_VER) && defined(_DEBUG)
-#include <crtdbg.h>
-#include <conio.h>
-#endif
-#include <squirrel.h>
-#include <sqstdblob.h>
-#include <sqstdsystem.h>
-#include <sqstdio.h>
-#include <sqstdmath.h>	
-#include <sqstdstring.h>
-#include <sqstdaux.h>
-
-#ifdef SQUNICODE
-#define scfprintf fwprintf
-#define scfopen	_wfopen
-#define scvprintf vwprintf
-#else
-#define scfprintf fprintf
-#define scfopen	fopen
-#define scvprintf vprintf
-#endif
-
-
-void PrintVersionInfos();
-
-#if defined(_MSC_VER) && defined(_DEBUG)
-int MemAllocHook( int allocType, void *userData, size_t size, int blockType, 
-   long requestNumber, const unsigned char *filename, int lineNumber)
-{
-//	if(requestNumber==585)_asm int 3;
-	return 1;
-}
-#endif
-
-
-SQInteger quit(HSQUIRRELVM v)
-{
-	int *done;
-	sq_getuserpointer(v,-1,(SQUserPointer*)&done);
-	*done=1;
-	return 0;
-}
-
-void printfunc(HSQUIRRELVM v,const SQChar *s,...)
-{
-	va_list vl;
-	va_start(vl, s);
-	scvprintf( s, vl);
-	va_end(vl);
-}
-
-void PrintVersionInfos()
-{
-	scfprintf(stdout,_SC("%s %s (%d bits)\n"),SQUIRREL_VERSION,SQUIRREL_COPYRIGHT,sizeof(SQInteger)*8);
-}
-
-void PrintUsage()
-{
-	scfprintf(stderr,_SC("usage: sq <options> <scriptpath [args]>.\n")
-		_SC("Available options are:\n")
-		_SC("   -c              compiles the file to bytecode(default output 'out.cnut')\n")
-		_SC("   -o              specifies output file for the -c option\n")
-		_SC("   -c              compiles only\n")
-		_SC("   -d              generates debug infos\n")
-		_SC("   -v              displays version infos\n")
-		_SC("   -h              prints help\n"));
-}
-
-#define _INTERACTIVE 0
-#define _DONE 2
-//<<FIXME>> this func is a mess
-int getargs(HSQUIRRELVM v,int argc, char* argv[])
-{
-	int i;
-	int compiles_only = 0;
-	static SQChar temp[500];
-	const SQChar *ret=NULL;
-	char * output = NULL;
-	int lineinfo=0;
-	if(argc>1)
-	{
-		int arg=1,exitloop=0;
-		while(arg < argc && !exitloop)
-		{
-
-			if(argv[arg][0]=='-')
-			{
-				switch(argv[arg][1])
-				{
-				case 'd': //DEBUG(debug infos)
-					sq_enabledebuginfo(v,1);
-					break;
-				case 'c':
-					compiles_only = 1;
-					break;
-				case 'o':
-					if(arg < argc) {
-						arg++;
-						output = argv[arg];
-					}
-					break;
-				case 'v':
-					PrintVersionInfos();
-					return _DONE;
-				
-				case 'h':
-					PrintVersionInfos();
-					PrintUsage();
-					return _DONE;
-				default:
-					PrintVersionInfos();
-					scprintf(_SC("unknown prameter '-%c'\n"),argv[arg][1]);
-					PrintUsage();
-					return _DONE;
-				}
-			}else break;
-			arg++;
-		}
-
-		// src file
-		
-		if(arg<argc) {
-			const SQChar *filename=NULL;
-#ifdef SQUNICODE
-			mbstowcs(temp,argv[arg],strlen(argv[arg]));
-			filename=temp;
-#else
-			filename=argv[arg];
-#endif
-
-			arg++;
-			sq_pushroottable(v);
-			sq_pushstring(v,_SC("ARGS"),-1);
-			sq_newarray(v,0);
-			for(i=arg;i<argc;i++)
-			{
-				const SQChar *a;
-#ifdef SQUNICODE
-				int alen=strlen(argv[i]);
-				a=sq_getscratchpad(v,alen*sizeof(SQChar));
-				mbstowcs(sq_getscratchpad(v,-1),argv[i],alen);
-				sq_getscratchpad(v,-1)[alen] = _SC('\0');
-#else
-				a=argv[i];
-#endif
-				sq_pushstring(v,a,-1);
-
-				sq_arrayappend(v,-2);
-			}
-			sq_createslot(v,-3);
-			sq_pop(v,1);
-			if(compiles_only) {
-				if(SQ_SUCCEEDED(sqstd_loadfile(v,filename,SQTrue))){
-					SQChar *outfile = _SC("out.cnut");
-					if(output) {
-#ifdef SQUNICODE
-						int len = strlen(output)+1;
-						mbstowcs(sq_getscratchpad(v,len*sizeof(SQChar)),output,len);
-						outfile = sq_getscratchpad(v,-1);
-#else
-						outfile = output;
-#endif
-					}
-					if(SQ_SUCCEEDED(sqstd_writeclosuretofile(v,outfile)))
-						return _DONE;
-				}
-			}
-			else {
-				if(SQ_SUCCEEDED(sqstd_dofile(v,filename,SQFalse,SQTrue))) {
-					return _DONE;
-				}
-			}
-			//if this point is reached an error occured
-			{
-				const SQChar *err;
-				sq_getlasterror(v);
-				if(SQ_SUCCEEDED(sq_getstring(v,-1,&err))) {
-					scprintf(_SC("Error [%s]\n"),err);
-					return _DONE;
-				}
-			}
-			
-		}
-	}
-
-	return _INTERACTIVE;
-}
-
-void Interactive(HSQUIRRELVM v)
-{
-	
-#define MAXINPUT 1024
-	SQChar buffer[MAXINPUT];
-	SQInteger blocks =0;
-	SQInteger string=0;
-	SQInteger retval=0;
-	SQInteger done=0;
-	PrintVersionInfos();
-		
-	sq_pushroottable(v);
-	sq_pushstring(v,_SC("quit"),-1);
-	sq_pushuserpointer(v,&done);
-	sq_newclosure(v,quit,1);
-	sq_setparamscheck(v,1,NULL);
-	sq_createslot(v,-3);
-	sq_pop(v,1);
-
-    while (!done) 
-	{
-		SQInteger i = 0;
-		scprintf(_SC("\nsq>"));
-		for(;;) {
-			int c;
-			if(done)return;
-			c = getchar();
-			if (c == _SC('\n')) {
-				if (i>0 && buffer[i-1] == _SC('\\'))
-				{
-					buffer[i-1] = _SC('\n');
-				}
-				else if(blocks==0)break;
-				buffer[i++] = _SC('\n');
-			}
-			else if (c==_SC('}')) {blocks--; buffer[i++] = (SQChar)c;}
-			else if(c==_SC('{') && !string){
-					blocks++;
-					buffer[i++] = (SQChar)c;
-			}
-			else if(c==_SC('"') || c==_SC('\'')){
-					string=!string;
-					buffer[i++] = (SQChar)c;
-			}
-			else if (i >= MAXINPUT-1) {
-				scfprintf(stderr, _SC("sq : input line too long\n"));
-				break;
-			}
-			else{
-				buffer[i++] = (SQChar)c;
-			}
-		}
-		buffer[i] = _SC('\0');
-		
-		if(buffer[0]==_SC('=')){
-#ifdef SQUNICODE_VS8
-			scsprintf(sq_getscratchpad(v,MAXINPUT),(size_t)_SC("return (%s)"),&buffer[1]);
-#else
-      scsprintf(sq_getscratchpad(v,MAXINPUT),_SC("return (%s)"),&buffer[1]);
-#endif
-			memcpy(buffer,sq_getscratchpad(v,-1),(scstrlen(sq_getscratchpad(v,-1))+1)*sizeof(SQChar));
-			retval=1;
-		}
-		i=scstrlen(buffer);
-		if(i>0){
-			SQInteger oldtop=sq_gettop(v);
-			if(SQ_SUCCEEDED(sq_compilebuffer(v,buffer,i,_SC("interactive console"),SQTrue))){
-				sq_pushroottable(v);
-				if(SQ_SUCCEEDED(sq_call(v,1,retval,SQTrue)) &&	retval){
-					scprintf(_SC("\n"));
-					sq_pushroottable(v);
-					sq_pushstring(v,_SC("print"),-1);
-					sq_get(v,-2);
-					sq_pushroottable(v);
-					sq_push(v,-4);
-					sq_call(v,2,SQFalse,SQTrue);
-					retval=0;
-					scprintf(_SC("\n"));
-				}
-			}
-			
-			sq_settop(v,oldtop);
-		}
-	}
-}
-
-int main(int argc, char* argv[])
-{
-	HSQUIRRELVM v;
-	
-	const SQChar *filename=NULL;
-#if defined(_MSC_VER) && defined(_DEBUG)
-	_CrtSetAllocHook(MemAllocHook);
-#endif
-	
-	v=sq_open(1024);
-	sq_setprintfunc(v,printfunc);
-
-	sq_pushroottable(v);
-
-	sqstd_register_bloblib(v);
-	sqstd_register_iolib(v);
-	sqstd_register_systemlib(v);
-	sqstd_register_mathlib(v);
-	sqstd_register_stringlib(v);
-
-	//aux library
-	//sets error handlers
-	sqstd_seterrorhandlers(v);
-
-	//gets arguments
-	switch(getargs(v,argc,argv))
-	{
-	case _INTERACTIVE:
-		Interactive(v);
-		break;
-	case _DONE:
-	default: 
-		break;
-	}
-
-	sq_close(v);
-	
-#if defined(_MSC_VER) && defined(_DEBUG)
-	_getch();
-	_CrtMemDumpAllObjectsSince( NULL );
-#endif
-	return 0;
-}
-
diff -rupwN ../dnl3/SqPlus/sq/sq.cbp SqPlus/sq/sq.cbp
--- ../dnl3/SqPlus/sq/sq.cbp	2006-04-25 17:05:30.000000000 -0400
+++ SqPlus/sq/sq.cbp	1969-12-31 19:00:00.000000000 -0500
@@ -1,129 +0,0 @@
-<?xml version="1.0"?>
-<!DOCTYPE CodeBlocks_project_file>
-<CodeBlocks_project_file>
-	<FileVersion major="1" minor="1"/>
-	<Project>
-		<Option title="sq"/>
-		<Option makefile="Makefile"/>
-		<Option makefile_is_custom="0"/>
-		<Option compiler="0"/>
-		<Build>
-			<Target title="Release">
-				<Option output="..\bin\sq.exe"/>
-				<Option working_dir="."/>
-				<Option object_output="Release"/>
-				<Option deps_output=".deps"/>
-				<Option external_deps="..\lib\libsquirrel.a;..\lib\libsqstdlib.a;"/>
-				<Option type="1"/>
-				<Option compiler="0"/>
-				<Option projectResourceIncludeDirsRelation="1"/>
-				<Compiler>
-					<Add option="-DWIN32"/>
-					<Add option="-DNDEBUG"/>
-					<Add option="-D_CONSOLE"/>
-					<Add option="-D_CRT_SECURE_NO_DEPRECATE"/>
-					<Add option="-W"/>
-					<Add option="-O2"/>
-					<Add directory="..\include"/>
-					<Add directory="..\sqstdlib"/>
-				</Compiler>
-				<Linker>
-					<Add library="..\lib\libsquirrel.a"/>
-					<Add library="..\lib\libsqstdlib.a"/>
-					<Add directory="..\lib"/>
-				</Linker>
-			</Target>
-			<Target title="Debug">
-				<Option output="..\bin\sqD.exe"/>
-				<Option working_dir="."/>
-				<Option object_output="Debug"/>
-				<Option deps_output=".deps"/>
-				<Option external_deps="..\lib\libsquirrelD.a;..\lib\libsqstdlibD.a;"/>
-				<Option type="1"/>
-				<Option compiler="0"/>
-				<Option projectResourceIncludeDirsRelation="1"/>
-				<Compiler>
-					<Add option="-DWIN32"/>
-					<Add option="-D_DEBUG"/>
-					<Add option="-D_CONSOLE"/>
-					<Add option="-D_CRT_SECURE_NO_DEPRECATE"/>
-					<Add option="-W"/>
-					<Add option="-O0"/>
-					<Add directory="..\include"/>
-					<Add directory="..\sqstdlib"/>
-				</Compiler>
-				<Linker>
-					<Add library="..\lib\libsquirrelD.a"/>
-					<Add library="..\lib\libsqstdlibD.a"/>
-					<Add directory="..\lib"/>
-				</Linker>
-			</Target>
-			<Target title="Debug - Unicode">
-				<Option output="..\bin\sqDU.exe"/>
-				<Option working_dir="."/>
-				<Option object_output="Debug - Unicode"/>
-				<Option deps_output=".deps"/>
-				<Option external_deps="..\lib\libsquirrelDU.a;..\lib\libsqstdlibDU.a;"/>
-				<Option type="1"/>
-				<Option compiler="0"/>
-				<Option projectResourceIncludeDirsRelation="1"/>
-				<Compiler>
-					<Add option="-DWIN32"/>
-					<Add option="-D_DEBUG"/>
-					<Add option="-D_CONSOLE"/>
-					<Add option="-D_CRT_SECURE_NO_DEPRECATE"/>
-					<Add option="-W"/>
-					<Add option="-O0"/>
-					<Add directory="..\include"/>
-					<Add directory="..\sqstdlib"/>
-				</Compiler>
-				<Linker>
-					<Add library="..\lib\libsquirrelDU.a"/>
-					<Add library="..\lib\libsqstdlibDU.a"/>
-					<Add directory="..\lib"/>
-				</Linker>
-			</Target>
-			<Target title="Release - Unicode">
-				<Option output="..\bin\sqU.exe"/>
-				<Option working_dir="."/>
-				<Option object_output="Release - Unicode"/>
-				<Option deps_output=".deps"/>
-				<Option external_deps="..\lib\libsquirrelU.a;..\lib\libsqstdlibU.a;"/>
-				<Option type="1"/>
-				<Option compiler="0"/>
-				<Option projectResourceIncludeDirsRelation="1"/>
-				<Compiler>
-					<Add option="-DWIN32"/>
-					<Add option="-DNDEBUG"/>
-					<Add option="-D_CONSOLE"/>
-					<Add option="-D_CRT_SECURE_NO_DEPRECATE"/>
-					<Add option="-W"/>
-					<Add option="-O2"/>
-					<Add directory="..\include"/>
-					<Add directory="..\sqstdlib"/>
-				</Compiler>
-				<Linker>
-					<Add library="..\lib\libsquirrelU.a"/>
-					<Add library="..\lib\libsqstdlibU.a"/>
-					<Add directory="..\lib"/>
-				</Linker>
-			</Target>
-		</Build>
-		<Unit filename="..\etc\test.nut">
-			<Option compilerVar=""/>
-			<Option compile="0"/>
-			<Option link="0"/>
-			<Option target="Release"/>
-			<Option target="Debug"/>
-			<Option target="Debug - Unicode"/>
-			<Option target="Release - Unicode"/>
-		</Unit>
-		<Unit filename="sq.c">
-			<Option compilerVar="CC"/>
-			<Option target="Release"/>
-			<Option target="Debug"/>
-			<Option target="Debug - Unicode"/>
-			<Option target="Release - Unicode"/>
-		</Unit>
-	</Project>
-</CodeBlocks_project_file>
diff -rupwN ../dnl3/SqPlus/sq/sq.vcproj SqPlus/sq/sq.vcproj
--- ../dnl3/SqPlus/sq/sq.vcproj	2006-03-26 18:21:16.000000000 -0500
+++ SqPlus/sq/sq.vcproj	1969-12-31 19:00:00.000000000 -0500
@@ -1,454 +0,0 @@
-<?xml version="1.0" encoding="Windows-1252"?>
-<VisualStudioProject
-	ProjectType="Visual C++"
-	Version="8.00"
-	Name="sq"
-	ProjectGUID="{984683B6-E68A-4CCB-89C9-2D89527144A6}"
-	RootNamespace="sq"
-	SccLocalPath=".."
-	>
-	<Platforms>
-		<Platform
-			Name="Win32"
-		/>
-	</Platforms>
-	<ToolFiles>
-	</ToolFiles>
-	<Configurations>
-		<Configuration
-			Name="Release|Win32"
-			OutputDirectory="$(ConfigurationName)"
-			IntermediateDirectory="$(ConfigurationName)"
-			ConfigurationType="1"
-			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC71.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			CharacterSet="2"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TypeLibraryName=".\Release/sq.tlb"
-				HeaderFileName=""
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="2"
-				InlineFunctionExpansion="1"
-				AdditionalIncludeDirectories="..\include,..\sqstdlib"
-				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE"
-				StringPooling="true"
-				RuntimeLibrary="0"
-				EnableFunctionLevelLinking="true"
-				UsePrecompiledHeader="0"
-				PrecompiledHeaderFile=".\Release/sq.pch"
-				AssemblerListingLocation="$(IntDir)/"
-				ObjectFile="$(IntDir)/"
-				ProgramDataBaseFileName="$(IntDir)/"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-				CompileAs="0"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="NDEBUG"
-				Culture="1040"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				OutputFile="../bin/sq.exe"
-				LinkIncremental="1"
-				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories="../lib"
-				ProgramDatabaseFile=".\Release/sq.pdb"
-				SubSystem="1"
-				TargetMachine="1"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Debug|Win32"
-			OutputDirectory="$(ConfigurationName)"
-			IntermediateDirectory="$(ConfigurationName)"
-			ConfigurationType="1"
-			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC71.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			CharacterSet="2"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TypeLibraryName=".\Debug/sq.tlb"
-				HeaderFileName=""
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="..\include,..\sqstdlib"
-				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE"
-				BasicRuntimeChecks="3"
-				RuntimeLibrary="1"
-				UsePrecompiledHeader="0"
-				PrecompiledHeaderFile=".\Debug/sq.pch"
-				AssemblerListingLocation="$(IntDir)/"
-				ObjectFile="$(IntDir)/"
-				ProgramDataBaseFileName="$(IntDir)/"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-				DebugInformationFormat="4"
-				CompileAs="0"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="_DEBUG"
-				Culture="1040"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				OutputFile="../bin/sqD.exe"
-				LinkIncremental="2"
-				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories="../lib"
-				GenerateDebugInformation="true"
-				ProgramDatabaseFile=".\Debug/sq.pdb"
-				SubSystem="1"
-				TargetMachine="1"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Debug - Unicode|Win32"
-			OutputDirectory="$(ConfigurationName)"
-			IntermediateDirectory="$(ConfigurationName)"
-			ConfigurationType="1"
-			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC71.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			CharacterSet="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TypeLibraryName=".\Debug/sq.tlb"
-				HeaderFileName=""
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="..\include,..\sqstdlib"
-				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE"
-				BasicRuntimeChecks="3"
-				RuntimeLibrary="1"
-				UsePrecompiledHeader="0"
-				PrecompiledHeaderFile=".\Debug/sq.pch"
-				AssemblerListingLocation="$(IntDir)/"
-				ObjectFile="$(IntDir)/"
-				ProgramDataBaseFileName="$(IntDir)/"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-				DebugInformationFormat="4"
-				CompileAs="0"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="_DEBUG"
-				Culture="1040"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				OutputFile="../bin/sqDU.exe"
-				LinkIncremental="2"
-				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories="../lib"
-				GenerateDebugInformation="true"
-				ProgramDatabaseFile=".\Debug/sq.pdb"
-				SubSystem="1"
-				TargetMachine="1"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release - Unicode|Win32"
-			OutputDirectory="$(ConfigurationName)"
-			IntermediateDirectory="$(ConfigurationName)"
-			ConfigurationType="1"
-			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC71.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			CharacterSet="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TypeLibraryName=".\Release/sq.tlb"
-				HeaderFileName=""
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="2"
-				InlineFunctionExpansion="1"
-				AdditionalIncludeDirectories="..\include,..\sqstdlib"
-				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE"
-				StringPooling="true"
-				RuntimeLibrary="0"
-				EnableFunctionLevelLinking="true"
-				UsePrecompiledHeader="0"
-				PrecompiledHeaderFile=".\Release/sq.pch"
-				AssemblerListingLocation="$(IntDir)/"
-				ObjectFile="$(IntDir)/"
-				ProgramDataBaseFileName="$(IntDir)/"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-				CompileAs="0"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="NDEBUG"
-				Culture="1040"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				OutputFile="../bin/sqU.exe"
-				LinkIncremental="1"
-				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories="../lib"
-				ProgramDatabaseFile=".\Release/sq.pdb"
-				SubSystem="1"
-				TargetMachine="1"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-	</Configurations>
-	<References>
-	</References>
-	<Files>
-		<Filter
-			Name="Source Files"
-			Filter="cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
-			>
-			<File
-				RelativePath="sq.c"
-				>
-				<FileConfiguration
-					Name="Release|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug - Unicode|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release - Unicode|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-					/>
-				</FileConfiguration>
-			</File>
-		</Filter>
-		<Filter
-			Name="Header Files"
-			Filter="h;hpp;hxx;hm;inl"
-			>
-		</Filter>
-		<Filter
-			Name="Resource Files"
-			Filter="ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe"
-			>
-		</Filter>
-		<File
-			RelativePath="..\etc\test.nut"
-			>
-		</File>
-	</Files>
-	<Globals>
-	</Globals>
-</VisualStudioProject>
diff -rupwN ../dnl3/SqPlus/_sq/Makefile SqPlus/_sq/Makefile
--- ../dnl3/SqPlus/_sq/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ SqPlus/_sq/Makefile	2006-03-19 14:32:58.000000000 -0500
@@ -0,0 +1,21 @@
+SQUIRREL= ..
+
+
+OUT= $(SQUIRREL)/bin/sq
+INCZ= -I$(SQUIRREL)/include -I. -I$(SQUIRREL)/sqlibs
+LIBZ= -L$(SQUIRREL)/lib 
+LIB= -lsquirrel -lsqstdlib
+
+OBJS= sq.o
+	
+SRCS= sq.c
+	
+	
+sq32:
+	g++ -O2 -fno-rtti -o $(OUT) $(SRCS) $(INCZ) $(LIBZ) $(LIB)
+
+sqprof:
+	g++ -O2 -pg -fno-rtti -pie -gstabs -g3 -o $(OUT) $(SRCS) $(INCZ) $(LIBZ) $(LIB)
+	
+sq64:
+	g++ -O2 -fno-rtti -D_SQ64 -o $(OUT) $(SRCS) $(INCZ) $(LIBZ) $(LIB)
\ No newline at end of file
diff -rupwN ../dnl3/SqPlus/_sq/sq71.vcproj SqPlus/_sq/sq71.vcproj
--- ../dnl3/SqPlus/_sq/sq71.vcproj	1969-12-31 19:00:00.000000000 -0500
+++ SqPlus/_sq/sq71.vcproj	2006-05-29 15:10:46.000000000 -0400
@@ -0,0 +1,317 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="7.10"
+	Name="sq"
+	RootNamespace="sq"
+	SccProjectName=""
+	SccLocalPath="..">
+	<Platforms>
+		<Platform
+			Name="Win32"/>
+	</Platforms>
+	<Configurations>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="1"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="FALSE"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="1"
+				AdditionalIncludeDirectories="..\include,..\sqstdlib"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE"
+				StringPooling="TRUE"
+				RuntimeLibrary="0"
+				EnableFunctionLevelLinking="TRUE"
+				UsePrecompiledHeader="0"
+				PrecompiledHeaderFile=".\Release/sq.pch"
+				AssemblerListingLocation="$(IntDir)/"
+				ObjectFile="$(IntDir)/"
+				ProgramDataBaseFileName="$(IntDir)/"
+				WarningLevel="3"
+				SuppressStartupBanner="TRUE"
+				CompileAs="0"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				OutputFile="../bin/sq.exe"
+				LinkIncremental="1"
+				SuppressStartupBanner="TRUE"
+				AdditionalLibraryDirectories="../lib"
+				ProgramDatabaseFile=".\Release/sq.pdb"
+				SubSystem="1"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\Release/sq.tlb"
+				HeaderFileName=""/>
+			<Tool
+				Name="VCPostBuildEventTool"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG"
+				Culture="1040"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="1"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="FALSE"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\include,..\sqstdlib"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				UsePrecompiledHeader="2"
+				PrecompiledHeaderFile=".\Debug/sq.pch"
+				AssemblerListingLocation="$(IntDir)/"
+				ObjectFile="$(IntDir)/"
+				ProgramDataBaseFileName="$(IntDir)/"
+				WarningLevel="3"
+				SuppressStartupBanner="TRUE"
+				DebugInformationFormat="4"
+				CompileAs="0"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				OutputFile="../bin/sqD.exe"
+				LinkIncremental="2"
+				SuppressStartupBanner="TRUE"
+				AdditionalLibraryDirectories="../lib"
+				GenerateDebugInformation="TRUE"
+				ProgramDatabaseFile=".\Debug/sq.pdb"
+				SubSystem="1"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\Debug/sq.tlb"
+				HeaderFileName=""/>
+			<Tool
+				Name="VCPostBuildEventTool"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="1040"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+		<Configuration
+			Name="Debug - Unicode|Win32"
+			OutputDirectory="$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="1"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="FALSE"
+			CharacterSet="1">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\include,..\sqstdlib"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				UsePrecompiledHeader="2"
+				PrecompiledHeaderFile=".\Debug/sq.pch"
+				AssemblerListingLocation="$(IntDir)/"
+				ObjectFile="$(IntDir)/"
+				ProgramDataBaseFileName="$(IntDir)/"
+				WarningLevel="3"
+				SuppressStartupBanner="TRUE"
+				DebugInformationFormat="4"
+				CompileAs="0"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				OutputFile="../bin/sqDU.exe"
+				LinkIncremental="2"
+				SuppressStartupBanner="TRUE"
+				AdditionalLibraryDirectories="../lib"
+				GenerateDebugInformation="TRUE"
+				ProgramDatabaseFile=".\Debug/sq.pdb"
+				SubSystem="1"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\Debug/sq.tlb"
+				HeaderFileName=""/>
+			<Tool
+				Name="VCPostBuildEventTool"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="1040"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+		<Configuration
+			Name="Release - Unicode|Win32"
+			OutputDirectory="$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="1"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="FALSE"
+			CharacterSet="1">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="1"
+				AdditionalIncludeDirectories="..\include,..\sqstdlib"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE"
+				StringPooling="TRUE"
+				RuntimeLibrary="0"
+				EnableFunctionLevelLinking="TRUE"
+				UsePrecompiledHeader="0"
+				PrecompiledHeaderFile=".\Release/sq.pch"
+				AssemblerListingLocation="$(IntDir)/"
+				ObjectFile="$(IntDir)/"
+				ProgramDataBaseFileName="$(IntDir)/"
+				WarningLevel="3"
+				SuppressStartupBanner="TRUE"
+				CompileAs="0"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				OutputFile="../bin/sqU.exe"
+				LinkIncremental="1"
+				SuppressStartupBanner="TRUE"
+				AdditionalLibraryDirectories="../lib"
+				ProgramDatabaseFile=".\Release/sq.pdb"
+				SubSystem="1"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\Release/sq.tlb"
+				HeaderFileName=""/>
+			<Tool
+				Name="VCPostBuildEventTool"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG"
+				Culture="1040"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;rc;def;r;odl;idl;hpj;bat">
+			<File
+				RelativePath="sq.c">
+				<FileConfiguration
+					Name="Release|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug - Unicode|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release - Unicode|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""/>
+				</FileConfiguration>
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl">
+		</Filter>
+		<Filter
+			Name="Resource Files"
+			Filter="ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe">
+		</Filter>
+		<File
+			RelativePath="..\etc\test.nut">
+		</File>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -rupwN ../dnl3/SqPlus/_sq/sq.c SqPlus/_sq/sq.c
--- ../dnl3/SqPlus/_sq/sq.c	1969-12-31 19:00:00.000000000 -0500
+++ SqPlus/_sq/sq.c	2006-04-25 13:38:08.000000000 -0400
@@ -0,0 +1,325 @@
+/*	see copyright notice in squirrel.h */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdarg.h>
+
+#if defined(_MSC_VER) && defined(_DEBUG)
+#include <crtdbg.h>
+#include <conio.h>
+#endif
+#include <squirrel.h>
+#include <sqstdblob.h>
+#include <sqstdsystem.h>
+#include <sqstdio.h>
+#include <sqstdmath.h>	
+#include <sqstdstring.h>
+#include <sqstdaux.h>
+
+#ifdef SQUNICODE
+#define scfprintf fwprintf
+#define scfopen	_wfopen
+#define scvprintf vwprintf
+#else
+#define scfprintf fprintf
+#define scfopen	fopen
+#define scvprintf vprintf
+#endif
+
+
+void PrintVersionInfos();
+
+#if defined(_MSC_VER) && defined(_DEBUG)
+int MemAllocHook( int allocType, void *userData, size_t size, int blockType, 
+   long requestNumber, const unsigned char *filename, int lineNumber)
+{
+//	if(requestNumber==585)_asm int 3;
+	return 1;
+}
+#endif
+
+
+SQInteger quit(HSQUIRRELVM v)
+{
+	int *done;
+	sq_getuserpointer(v,-1,(SQUserPointer*)&done);
+	*done=1;
+	return 0;
+}
+
+void printfunc(HSQUIRRELVM v,const SQChar *s,...)
+{
+	va_list vl;
+	va_start(vl, s);
+	scvprintf( s, vl);
+	va_end(vl);
+}
+
+void PrintVersionInfos()
+{
+	scfprintf(stdout,_SC("%s %s (%d bits)\n"),SQUIRREL_VERSION,SQUIRREL_COPYRIGHT,sizeof(SQInteger)*8);
+}
+
+void PrintUsage()
+{
+	scfprintf(stderr,_SC("usage: sq <options> <scriptpath [args]>.\n")
+		_SC("Available options are:\n")
+		_SC("   -c              compiles the file to bytecode(default output 'out.cnut')\n")
+		_SC("   -o              specifies output file for the -c option\n")
+		_SC("   -c              compiles only\n")
+		_SC("   -d              generates debug infos\n")
+		_SC("   -v              displays version infos\n")
+		_SC("   -h              prints help\n"));
+}
+
+#define _INTERACTIVE 0
+#define _DONE 2
+//<<FIXME>> this func is a mess
+int getargs(HSQUIRRELVM v,int argc, char* argv[])
+{
+	int i;
+	int compiles_only = 0;
+	static SQChar temp[500];
+	const SQChar *ret=NULL;
+	char * output = NULL;
+	int lineinfo=0;
+	if(argc>1)
+	{
+		int arg=1,exitloop=0;
+		while(arg < argc && !exitloop)
+		{
+
+			if(argv[arg][0]=='-')
+			{
+				switch(argv[arg][1])
+				{
+				case 'd': //DEBUG(debug infos)
+					sq_enabledebuginfo(v,1);
+					break;
+				case 'c':
+					compiles_only = 1;
+					break;
+				case 'o':
+					if(arg < argc) {
+						arg++;
+						output = argv[arg];
+					}
+					break;
+				case 'v':
+					PrintVersionInfos();
+					return _DONE;
+				
+				case 'h':
+					PrintVersionInfos();
+					PrintUsage();
+					return _DONE;
+				default:
+					PrintVersionInfos();
+					scprintf(_SC("unknown prameter '-%c'\n"),argv[arg][1]);
+					PrintUsage();
+					return _DONE;
+				}
+			}else break;
+			arg++;
+		}
+
+		// src file
+		
+		if(arg<argc) {
+			const SQChar *filename=NULL;
+#ifdef SQUNICODE
+			mbstowcs(temp,argv[arg],strlen(argv[arg]));
+			filename=temp;
+#else
+			filename=argv[arg];
+#endif
+
+			arg++;
+			sq_pushroottable(v);
+			sq_pushstring(v,_SC("ARGS"),-1);
+			sq_newarray(v,0);
+			for(i=arg;i<argc;i++)
+			{
+				const SQChar *a;
+#ifdef SQUNICODE
+				int alen=strlen(argv[i]);
+				a=sq_getscratchpad(v,alen*sizeof(SQChar));
+				mbstowcs(sq_getscratchpad(v,-1),argv[i],alen);
+				sq_getscratchpad(v,-1)[alen] = _SC('\0');
+#else
+				a=argv[i];
+#endif
+				sq_pushstring(v,a,-1);
+
+				sq_arrayappend(v,-2);
+			}
+			sq_createslot(v,-3);
+			sq_pop(v,1);
+			if(compiles_only) {
+				if(SQ_SUCCEEDED(sqstd_loadfile(v,filename,SQTrue))){
+					SQChar *outfile = _SC("out.cnut");
+					if(output) {
+#ifdef SQUNICODE
+						int len = strlen(output)+1;
+						mbstowcs(sq_getscratchpad(v,len*sizeof(SQChar)),output,len);
+						outfile = sq_getscratchpad(v,-1);
+#else
+						outfile = output;
+#endif
+					}
+					if(SQ_SUCCEEDED(sqstd_writeclosuretofile(v,outfile)))
+						return _DONE;
+				}
+			}
+			else {
+				if(SQ_SUCCEEDED(sqstd_dofile(v,filename,SQFalse,SQTrue))) {
+					return _DONE;
+				}
+			}
+			//if this point is reached an error occured
+			{
+				const SQChar *err;
+				sq_getlasterror(v);
+				if(SQ_SUCCEEDED(sq_getstring(v,-1,&err))) {
+					scprintf(_SC("Error [%s]\n"),err);
+					return _DONE;
+				}
+			}
+			
+		}
+	}
+
+	return _INTERACTIVE;
+}
+
+void Interactive(HSQUIRRELVM v)
+{
+	
+#define MAXINPUT 1024
+	SQChar buffer[MAXINPUT];
+	SQInteger blocks =0;
+	SQInteger string=0;
+	SQInteger retval=0;
+	SQInteger done=0;
+	PrintVersionInfos();
+		
+	sq_pushroottable(v);
+	sq_pushstring(v,_SC("quit"),-1);
+	sq_pushuserpointer(v,&done);
+	sq_newclosure(v,quit,1);
+	sq_setparamscheck(v,1,NULL);
+	sq_createslot(v,-3);
+	sq_pop(v,1);
+
+    while (!done) 
+	{
+		SQInteger i = 0;
+		scprintf(_SC("\nsq>"));
+		for(;;) {
+			int c;
+			if(done)return;
+			c = getchar();
+			if (c == _SC('\n')) {
+				if (i>0 && buffer[i-1] == _SC('\\'))
+				{
+					buffer[i-1] = _SC('\n');
+				}
+				else if(blocks==0)break;
+				buffer[i++] = _SC('\n');
+			}
+			else if (c==_SC('}')) {blocks--; buffer[i++] = (SQChar)c;}
+			else if(c==_SC('{') && !string){
+					blocks++;
+					buffer[i++] = (SQChar)c;
+			}
+			else if(c==_SC('"') || c==_SC('\'')){
+					string=!string;
+					buffer[i++] = (SQChar)c;
+			}
+			else if (i >= MAXINPUT-1) {
+				scfprintf(stderr, _SC("sq : input line too long\n"));
+				break;
+			}
+			else{
+				buffer[i++] = (SQChar)c;
+			}
+		}
+		buffer[i] = _SC('\0');
+		
+		if(buffer[0]==_SC('=')){
+#ifdef SQUNICODE_VS8
+			scsprintf(sq_getscratchpad(v,MAXINPUT),(size_t)_SC("return (%s)"),&buffer[1]);
+#else
+      scsprintf(sq_getscratchpad(v,MAXINPUT),_SC("return (%s)"),&buffer[1]);
+#endif
+			memcpy(buffer,sq_getscratchpad(v,-1),(scstrlen(sq_getscratchpad(v,-1))+1)*sizeof(SQChar));
+			retval=1;
+		}
+		i=scstrlen(buffer);
+		if(i>0){
+			SQInteger oldtop=sq_gettop(v);
+			if(SQ_SUCCEEDED(sq_compilebuffer(v,buffer,i,_SC("interactive console"),SQTrue))){
+				sq_pushroottable(v);
+				if(SQ_SUCCEEDED(sq_call(v,1,retval,SQTrue)) &&	retval){
+					scprintf(_SC("\n"));
+					sq_pushroottable(v);
+					sq_pushstring(v,_SC("print"),-1);
+					sq_get(v,-2);
+					sq_pushroottable(v);
+					sq_push(v,-4);
+					sq_call(v,2,SQFalse,SQTrue);
+					retval=0;
+					scprintf(_SC("\n"));
+				}
+			}
+			
+			sq_settop(v,oldtop);
+		}
+	}
+}
+
+int main(int argc, char* argv[])
+{
+	HSQUIRRELVM v;
+	
+	const SQChar *filename=NULL;
+#if defined(_MSC_VER) && defined(_DEBUG)
+	_CrtSetAllocHook(MemAllocHook);
+#endif
+	
+	v=sq_open(1024);
+	sq_setprintfunc(v,printfunc);
+
+	sq_pushroottable(v);
+
+	sqstd_register_bloblib(v);
+	sqstd_register_iolib(v);
+	sqstd_register_systemlib(v);
+	sqstd_register_mathlib(v);
+	sqstd_register_stringlib(v);
+
+	//aux library
+	//sets error handlers
+	sqstd_seterrorhandlers(v);
+
+	//gets arguments
+	switch(getargs(v,argc,argv))
+	{
+	case _INTERACTIVE:
+		Interactive(v);
+		break;
+	case _DONE:
+	default: 
+		break;
+	}
+
+	sq_close(v);
+	
+#if defined(_MSC_VER) && defined(_DEBUG)
+	_getch();
+	_CrtMemDumpAllObjectsSince( NULL );
+#endif
+	return 0;
+}
+
diff -rupwN ../dnl3/SqPlus/_sq/sq.cbp SqPlus/_sq/sq.cbp
--- ../dnl3/SqPlus/_sq/sq.cbp	1969-12-31 19:00:00.000000000 -0500
+++ SqPlus/_sq/sq.cbp	2006-04-25 17:05:30.000000000 -0400
@@ -0,0 +1,129 @@
+<?xml version="1.0"?>
+<!DOCTYPE CodeBlocks_project_file>
+<CodeBlocks_project_file>
+	<FileVersion major="1" minor="1"/>
+	<Project>
+		<Option title="sq"/>
+		<Option makefile="Makefile"/>
+		<Option makefile_is_custom="0"/>
+		<Option compiler="0"/>
+		<Build>
+			<Target title="Release">
+				<Option output="..\bin\sq.exe"/>
+				<Option working_dir="."/>
+				<Option object_output="Release"/>
+				<Option deps_output=".deps"/>
+				<Option external_deps="..\lib\libsquirrel.a;..\lib\libsqstdlib.a;"/>
+				<Option type="1"/>
+				<Option compiler="0"/>
+				<Option projectResourceIncludeDirsRelation="1"/>
+				<Compiler>
+					<Add option="-DWIN32"/>
+					<Add option="-DNDEBUG"/>
+					<Add option="-D_CONSOLE"/>
+					<Add option="-D_CRT_SECURE_NO_DEPRECATE"/>
+					<Add option="-W"/>
+					<Add option="-O2"/>
+					<Add directory="..\include"/>
+					<Add directory="..\sqstdlib"/>
+				</Compiler>
+				<Linker>
+					<Add library="..\lib\libsquirrel.a"/>
+					<Add library="..\lib\libsqstdlib.a"/>
+					<Add directory="..\lib"/>
+				</Linker>
+			</Target>
+			<Target title="Debug">
+				<Option output="..\bin\sqD.exe"/>
+				<Option working_dir="."/>
+				<Option object_output="Debug"/>
+				<Option deps_output=".deps"/>
+				<Option external_deps="..\lib\libsquirrelD.a;..\lib\libsqstdlibD.a;"/>
+				<Option type="1"/>
+				<Option compiler="0"/>
+				<Option projectResourceIncludeDirsRelation="1"/>
+				<Compiler>
+					<Add option="-DWIN32"/>
+					<Add option="-D_DEBUG"/>
+					<Add option="-D_CONSOLE"/>
+					<Add option="-D_CRT_SECURE_NO_DEPRECATE"/>
+					<Add option="-W"/>
+					<Add option="-O0"/>
+					<Add directory="..\include"/>
+					<Add directory="..\sqstdlib"/>
+				</Compiler>
+				<Linker>
+					<Add library="..\lib\libsquirrelD.a"/>
+					<Add library="..\lib\libsqstdlibD.a"/>
+					<Add directory="..\lib"/>
+				</Linker>
+			</Target>
+			<Target title="Debug - Unicode">
+				<Option output="..\bin\sqDU.exe"/>
+				<Option working_dir="."/>
+				<Option object_output="Debug - Unicode"/>
+				<Option deps_output=".deps"/>
+				<Option external_deps="..\lib\libsquirrelDU.a;..\lib\libsqstdlibDU.a;"/>
+				<Option type="1"/>
+				<Option compiler="0"/>
+				<Option projectResourceIncludeDirsRelation="1"/>
+				<Compiler>
+					<Add option="-DWIN32"/>
+					<Add option="-D_DEBUG"/>
+					<Add option="-D_CONSOLE"/>
+					<Add option="-D_CRT_SECURE_NO_DEPRECATE"/>
+					<Add option="-W"/>
+					<Add option="-O0"/>
+					<Add directory="..\include"/>
+					<Add directory="..\sqstdlib"/>
+				</Compiler>
+				<Linker>
+					<Add library="..\lib\libsquirrelDU.a"/>
+					<Add library="..\lib\libsqstdlibDU.a"/>
+					<Add directory="..\lib"/>
+				</Linker>
+			</Target>
+			<Target title="Release - Unicode">
+				<Option output="..\bin\sqU.exe"/>
+				<Option working_dir="."/>
+				<Option object_output="Release - Unicode"/>
+				<Option deps_output=".deps"/>
+				<Option external_deps="..\lib\libsquirrelU.a;..\lib\libsqstdlibU.a;"/>
+				<Option type="1"/>
+				<Option compiler="0"/>
+				<Option projectResourceIncludeDirsRelation="1"/>
+				<Compiler>
+					<Add option="-DWIN32"/>
+					<Add option="-DNDEBUG"/>
+					<Add option="-D_CONSOLE"/>
+					<Add option="-D_CRT_SECURE_NO_DEPRECATE"/>
+					<Add option="-W"/>
+					<Add option="-O2"/>
+					<Add directory="..\include"/>
+					<Add directory="..\sqstdlib"/>
+				</Compiler>
+				<Linker>
+					<Add library="..\lib\libsquirrelU.a"/>
+					<Add library="..\lib\libsqstdlibU.a"/>
+					<Add directory="..\lib"/>
+				</Linker>
+			</Target>
+		</Build>
+		<Unit filename="..\etc\test.nut">
+			<Option compilerVar=""/>
+			<Option compile="0"/>
+			<Option link="0"/>
+			<Option target="Release"/>
+			<Option target="Debug"/>
+			<Option target="Debug - Unicode"/>
+			<Option target="Release - Unicode"/>
+		</Unit>
+		<Unit filename="sq.c">
+			<Option compilerVar="CC"/>
+			<Option target="Release"/>
+			<Option target="Debug"/>
+			<Option target="Debug - Unicode"/>
+			<Option target="Release - Unicode"/>
+		</Unit>
+	</Project>
+</CodeBlocks_project_file>
diff -rupwN ../dnl3/SqPlus/_sq/sq.vcproj SqPlus/_sq/sq.vcproj
--- ../dnl3/SqPlus/_sq/sq.vcproj	1969-12-31 19:00:00.000000000 -0500
+++ SqPlus/_sq/sq.vcproj	2006-03-26 18:21:16.000000000 -0500
@@ -0,0 +1,454 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="8.00"
+	Name="sq"
+	ProjectGUID="{984683B6-E68A-4CCB-89C9-2D89527144A6}"
+	RootNamespace="sq"
+	SccLocalPath=".."
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="1"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC71.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\Release/sq.tlb"
+				HeaderFileName=""
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="1"
+				AdditionalIncludeDirectories="..\include,..\sqstdlib"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE"
+				StringPooling="true"
+				RuntimeLibrary="0"
+				EnableFunctionLevelLinking="true"
+				UsePrecompiledHeader="0"
+				PrecompiledHeaderFile=".\Release/sq.pch"
+				AssemblerListingLocation="$(IntDir)/"
+				ObjectFile="$(IntDir)/"
+				ProgramDataBaseFileName="$(IntDir)/"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+				CompileAs="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG"
+				Culture="1040"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				OutputFile="../bin/sq.exe"
+				LinkIncremental="1"
+				SuppressStartupBanner="true"
+				AdditionalLibraryDirectories="../lib"
+				ProgramDatabaseFile=".\Release/sq.pdb"
+				SubSystem="1"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="1"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC71.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\Debug/sq.tlb"
+				HeaderFileName=""
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\include,..\sqstdlib"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				UsePrecompiledHeader="0"
+				PrecompiledHeaderFile=".\Debug/sq.pch"
+				AssemblerListingLocation="$(IntDir)/"
+				ObjectFile="$(IntDir)/"
+				ProgramDataBaseFileName="$(IntDir)/"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+				DebugInformationFormat="4"
+				CompileAs="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="1040"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				OutputFile="../bin/sqD.exe"
+				LinkIncremental="2"
+				SuppressStartupBanner="true"
+				AdditionalLibraryDirectories="../lib"
+				GenerateDebugInformation="true"
+				ProgramDatabaseFile=".\Debug/sq.pdb"
+				SubSystem="1"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug - Unicode|Win32"
+			OutputDirectory="$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="1"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC71.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\Debug/sq.tlb"
+				HeaderFileName=""
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\include,..\sqstdlib"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				UsePrecompiledHeader="0"
+				PrecompiledHeaderFile=".\Debug/sq.pch"
+				AssemblerListingLocation="$(IntDir)/"
+				ObjectFile="$(IntDir)/"
+				ProgramDataBaseFileName="$(IntDir)/"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+				DebugInformationFormat="4"
+				CompileAs="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="1040"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				OutputFile="../bin/sqDU.exe"
+				LinkIncremental="2"
+				SuppressStartupBanner="true"
+				AdditionalLibraryDirectories="../lib"
+				GenerateDebugInformation="true"
+				ProgramDatabaseFile=".\Debug/sq.pdb"
+				SubSystem="1"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release - Unicode|Win32"
+			OutputDirectory="$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="1"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC71.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\Release/sq.tlb"
+				HeaderFileName=""
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="1"
+				AdditionalIncludeDirectories="..\include,..\sqstdlib"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE"
+				StringPooling="true"
+				RuntimeLibrary="0"
+				EnableFunctionLevelLinking="true"
+				UsePrecompiledHeader="0"
+				PrecompiledHeaderFile=".\Release/sq.pch"
+				AssemblerListingLocation="$(IntDir)/"
+				ObjectFile="$(IntDir)/"
+				ProgramDataBaseFileName="$(IntDir)/"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+				CompileAs="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG"
+				Culture="1040"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				OutputFile="../bin/sqU.exe"
+				LinkIncremental="1"
+				SuppressStartupBanner="true"
+				AdditionalLibraryDirectories="../lib"
+				ProgramDatabaseFile=".\Release/sq.pdb"
+				SubSystem="1"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
+			>
+			<File
+				RelativePath="sq.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug - Unicode|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release - Unicode|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl"
+			>
+		</Filter>
+		<Filter
+			Name="Resource Files"
+			Filter="ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe"
+			>
+		</Filter>
+		<File
+			RelativePath="..\etc\test.nut"
+			>
+		</File>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -rupwN ../dnl3/SqPlus/sqplus/sqplus.h SqPlus/sqplus/sqplus.h
--- ../dnl3/SqPlus/sqplus/sqplus.h	2006-07-08 02:28:32.000000000 -0400
+++ SqPlus/sqplus/sqplus.h	2009-07-02 14:20:20.000000000 -0400
@@ -18,7 +18,7 @@
   #include <malloc.h>
 #endif
 #include <memory.h>
-#if defined(_MSC_VER) || defined(__BORLANDC__) 
+#if defined(_MSC_VER) || defined(__BORLANDC__) || defined( _WIN32_WCE )
   #include <tchar.h>
   #ifndef UNICODE
     #define SCSNPRINTF _snprintf
@@ -28,10 +28,16 @@
     #define SCPUTS _putws
   #endif
 #else
+  #ifndef UNICODE
   #define _T(n) n
   #define SCSNPRINTF snprintf
-  #include <stdio.h> // for snprintf
   #define SCPUTS puts
+  #else
+  	#define _T(n) L##n
+    #define SCSNPRINTF wprintf
+    #define SCPUTS wputs
+  #endif
+  #include <stdio.h> // for snprintf
 #endif
 
 #ifndef _WINDEF_
@@ -48,6 +54,7 @@
 #define SQ_CALL_RAISE_ERROR SQFalse
 #endif
 
+#include <string>
 #include "squirrel.h"
 
 #include "SquirrelObject.h"
@@ -76,7 +83,7 @@ namespace SqPlus {
 //#define SQPLUS_CONST_OPT
 
 // === Uncomment to support std::string ===
-//#define SQPLUS_SUPPORT_STD_STRING
+#define SQPLUS_SUPPORT_STD_STRING
 
 // === Uncomment to support NULL INSTANCE arguments ===
 //#define SQPLUS_SUPPORT_NULL_INSTANCES
@@ -585,86 +592,6 @@ T * GetInstance(HSQUIRRELVM v,SQInteger 
 //////////// END Generalized Class/Struct Instance Support ///////////////
 //////////////////////////////////////////////////////////////////////////
 
-// === BEGIN Function Call Handlers ===
-
-inline void Push(HSQUIRRELVM v,char value)           { sq_pushinteger(v,value); }
-inline void Push(HSQUIRRELVM v,unsigned char value)  { sq_pushinteger(v,value); }
-inline void Push(HSQUIRRELVM v,short value)          { sq_pushinteger(v,value); }
-inline void Push(HSQUIRRELVM v,unsigned short value) { sq_pushinteger(v,value); }
-inline void Push(HSQUIRRELVM v,int value)            { sq_pushinteger(v,value); }
-inline void Push(HSQUIRRELVM v,unsigned int value)   { sq_pushinteger(v,value); }
-inline void Push(HSQUIRRELVM v,long value)           { sq_pushinteger(v,value); }
-inline void Push(HSQUIRRELVM v,unsigned long value)  { sq_pushinteger(v,value); }
-inline void Push(HSQUIRRELVM v,double value)         { sq_pushfloat(v,(FLOAT)value); }
-inline void Push(HSQUIRRELVM v,float value)          { sq_pushfloat(v,(FLOAT)value); }
-inline void Push(HSQUIRRELVM v,const SQChar * value) { sq_pushstring(v,value,-1); }
-inline void Push(HSQUIRRELVM v,const SquirrelNull &) { sq_pushnull(v); }
-inline void Push(HSQUIRRELVM v,SQFUNCTION value)     { sq_pushuserpointer(v,(void*)value); }
-inline void Push(HSQUIRRELVM v,SQAnythingPtr value)  { sq_pushuserpointer(v,(void*)value); } // Cast to SQAnythingPtr instead of void * if USE_ARGUMENT_DEPENDANT_OVERLOADS can't be used by your compiler.
-inline void Push(HSQUIRRELVM v,SquirrelObject & so)  { sq_pushobject(v,so.GetObjectHandle()); }
-
-
-#define USE_ARGUMENT_DEPENDANT_OVERLOADS
-#ifdef USE_ARGUMENT_DEPENDANT_OVERLOADS
-#ifdef _MSC_VER
-#pragma warning (disable:4675) // Disable warning: "resolved overload was found by argument-dependent lookup" when class/struct pointers are used as function arguments.
-#endif
-// === BEGIN Argument Dependent Overloads ===
-inline void Push(HSQUIRRELVM v,bool value)                  { sq_pushbool(v,value); }               // Pass bool as int if USE_ARGUMENT_DEPENDANT_OVERLOADS can't be used by your compiler.
-inline void Push(HSQUIRRELVM v,const void * value)          { sq_pushuserpointer(v,(void*)value); } // Pass SQAnythingPtr instead of void * "                                             "
-inline void Push(HSQUIRRELVM v,const SQUserPointer & value) { sq_pushuserpointer(v,(void*)value); }
-// === END Argument Dependent Overloads ===
-#endif
-
-#define SQPLUS_CHECK_GET(res) if (!SQ_SUCCEEDED(res)) throw SquirrelError(_T("sq_get*() failed (type error)"))
-
-inline bool	Match(TypeWrapper<bool>,HSQUIRRELVM v,int idx)           { return sq_gettype(v,idx) == OT_BOOL; }
-inline bool	Match(TypeWrapper<char>,HSQUIRRELVM v,int idx)           { return sq_gettype(v,idx) == OT_INTEGER; }
-inline bool	Match(TypeWrapper<unsigned char>,HSQUIRRELVM v, int idx) { return sq_gettype(v,idx) == OT_INTEGER; }
-inline bool	Match(TypeWrapper<short>,HSQUIRRELVM v,int idx)          { return sq_gettype(v,idx) == OT_INTEGER; }
-inline bool	Match(TypeWrapper<unsigned short>,HSQUIRRELVM v,int idx) { return sq_gettype(v,idx) == OT_INTEGER; }
-inline bool	Match(TypeWrapper<int>,HSQUIRRELVM v,int idx)            { return sq_gettype(v,idx) == OT_INTEGER; }
-inline bool	Match(TypeWrapper<unsigned int>,HSQUIRRELVM v,int idx)   { return sq_gettype(v,idx) == OT_INTEGER; }
-inline bool	Match(TypeWrapper<long>,HSQUIRRELVM v,int idx)           { return sq_gettype(v,idx) == OT_INTEGER; }
-inline bool	Match(TypeWrapper<unsigned long>,HSQUIRRELVM v,int idx)  { return sq_gettype(v,idx) == OT_INTEGER; }
-inline bool	Match(TypeWrapper<float>,HSQUIRRELVM v,int idx)          { int type = sq_gettype(v,idx); return type == OT_FLOAT; }
-inline bool	Match(TypeWrapper<double>,HSQUIRRELVM v,int idx)         { int type = sq_gettype(v,idx); return type == OT_FLOAT; }
-inline bool	Match(TypeWrapper<const SQChar *>,HSQUIRRELVM v,int idx) { return sq_gettype(v,idx) == OT_STRING; }
-inline bool	Match(TypeWrapper<HSQUIRRELVM>,HSQUIRRELVM v,int idx)    { return true; } // See Get() for HSQUIRRELVM below (v is always present).
-inline bool	Match(TypeWrapper<void*>,HSQUIRRELVM v,int idx)          { return sq_gettype(v,idx) == OT_USERPOINTER; }
-inline bool	Match(TypeWrapper<SquirrelObject>,HSQUIRRELVM v,int idx) { return true; } // See sq_getstackobj(): always returns true.
-
-inline void           Get(TypeWrapper<void>,HSQUIRRELVM v,int)                {}
-inline bool           Get(TypeWrapper<bool>,HSQUIRRELVM v,int idx)            { SQBool b; SQPLUS_CHECK_GET(sq_getbool(v,idx,&b)); return b != 0; }
-inline char           Get(TypeWrapper<char>,HSQUIRRELVM v,int idx)            { INT i; SQPLUS_CHECK_GET(sq_getinteger(v,idx,&i)); return static_cast<char>(i); }
-inline unsigned char  Get(TypeWrapper<unsigned char>,HSQUIRRELVM v,int idx)   { INT i; SQPLUS_CHECK_GET(sq_getinteger(v,idx,&i)); return static_cast<unsigned char>(i); }
-inline short          Get(TypeWrapper<short>,HSQUIRRELVM v,int idx)           { INT i; SQPLUS_CHECK_GET(sq_getinteger(v,idx,&i)); return static_cast<short>(i); }
-inline unsigned short	Get(TypeWrapper<unsigned short>,HSQUIRRELVM v,int idx)  { INT i; SQPLUS_CHECK_GET(sq_getinteger(v,idx,&i)); return static_cast<unsigned short>(i); }
-inline int            Get(TypeWrapper<int>,HSQUIRRELVM v,int idx)             { INT i; SQPLUS_CHECK_GET(sq_getinteger(v,idx,&i)); return i; }
-inline unsigned int   Get(TypeWrapper<unsigned int>,HSQUIRRELVM v,int idx)    { INT i; SQPLUS_CHECK_GET(sq_getinteger(v,idx,&i)); return static_cast<unsigned int>(i); }
-inline long           Get(TypeWrapper<long>,HSQUIRRELVM v,int idx)            { INT i; SQPLUS_CHECK_GET(sq_getinteger(v,idx,&i)); return static_cast<long>(i); }
-inline unsigned long  Get(TypeWrapper<unsigned long>,HSQUIRRELVM v,int idx)   { INT i; SQPLUS_CHECK_GET(sq_getinteger(v,idx,&i)); return static_cast<unsigned long>(i); }
-inline float          Get(TypeWrapper<float>,HSQUIRRELVM v,int idx)           { FLOAT f; SQPLUS_CHECK_GET(sq_getfloat(v,idx,&f)); return f; }
-inline double         Get(TypeWrapper<double>,HSQUIRRELVM v,int idx)          { FLOAT f; SQPLUS_CHECK_GET(sq_getfloat(v,idx,&f)); return static_cast<double>(f); }
-inline const SQChar * Get(TypeWrapper<const SQChar *>,HSQUIRRELVM v,int idx)  { const SQChar * s; SQPLUS_CHECK_GET(sq_getstring(v,idx,&s)); return s; }
-inline SquirrelNull   Get(TypeWrapper<SquirrelNull>,HSQUIRRELVM v,int idx)    { (void)v, (void)idx; return SquirrelNull();  }
-inline void *         Get(TypeWrapper<void *>,HSQUIRRELVM v,int idx)          { SQUserPointer p; SQPLUS_CHECK_GET(sq_getuserpointer(v,idx,&p)); return p; }
-inline HSQUIRRELVM    Get(TypeWrapper<HSQUIRRELVM>,HSQUIRRELVM v,int /*idx*/) { sq_poptop(v); return v; } // sq_poptop(v): remove UserData from stack so GetParamCount() matches normal behavior.
-inline SquirrelObject Get(TypeWrapper<SquirrelObject>,HSQUIRRELVM v,int idx)  { HSQOBJECT o; SQPLUS_CHECK_GET(sq_getstackobj(v,idx,&o)); return SquirrelObject(v,o); }
-
-#ifdef SQPLUS_SUPPORT_STD_STRING
-inline void Push(HSQUIRRELVM v,const std::string& value) { sq_pushstring(v,value.c_str(),-1); }
-inline bool Match(TypeWrapper<const std::string&>, HSQUIRRELVM v, int idx) { return sq_gettype(v,idx) == OT_STRING; }
-inline std::string Get(TypeWrapper<const std::string&>,HSQUIRRELVM v,int idx) { const SQChar * s; SQPLUS_CHECK_GET(sq_getstring(v,idx,&s)); return std::string(s); } 
-#endif
-
-// GetRet() restores the stack for SquirrelFunction<>() calls.
-template<typename RT>
-inline RT GetRet(TypeWrapper<RT>,HSQUIRRELVM v,int idx) { RT ret = Get(TypeWrapper<RT>(),v,idx); sq_pop(v,2); return ret; } // sq_pop(v,2): restore stack after function call.
-
-// Specialization to support void return type.
-inline void GetRet(TypeWrapper<void>,HSQUIRRELVM v,int idx) { sq_pop(v,2); }
-
 #ifndef SQ_SKIP_ARG_ASSERT
   #define sq_argassert(arg,_index_) if (!Match(TypeWrapper<P##arg>(),v,_index_)) return sq_throwerror(v,_T("Incorrect function argument"))
 #else
@@ -790,7 +717,7 @@ struct ReturnSpecialization {
       Get(TypeWrapper<P4>(),v,index + 3),
       Get(TypeWrapper<P5>(),v,index + 4),
       Get(TypeWrapper<P6>(),v,index + 5),
-      Get(TypeWrapper<P6>(),v,index + 6)
+      Get(TypeWrapper<P7>(),v,index + 6)
     );
     Push(v,ret);
     return 1;
@@ -1514,7 +1441,7 @@ struct SquirrelFunction {
   // Since some constructors require a SquirrelVM to be passed in, it seems reasonable to require all constructors to require it.
   SquirrelFunction(SquirrelVM& vm) : v(vm.GetVMHandle()), pSquirrelVM(&vm), func(v), object(v) {}
   SquirrelFunction(SquirrelVM& vm,const SquirrelObject & _object,const SquirrelObject & _func) : v(vm.GetVMHandle()), pSquirrelVM(&vm), object(_object), func(_func) {}
-  SquirrelFunction(SquirrelVM& vm,const SquirrelObject & _object,const SQChar * name) : v(vm.GetVMHandle()), pSquirrelVM(&vm), object(_object), func(v) {
+  SquirrelFunction(SquirrelVM& vm,const SquirrelObject & _object,const SQChar * name) : v(vm.GetVMHandle()), pSquirrelVM(&vm), func(v), object(_object) {
     func   = object.GetValue(name);
   }
   SquirrelFunction(SquirrelVM& vm,const SQChar * name) : v(vm.GetVMHandle()), pSquirrelVM(&vm), object(v), func(v) {
@@ -1881,6 +1808,92 @@ struct SQClassDef {
 
 };
 
+// === BEGIN Function Call Handlers ===
+
+inline void Push(HSQUIRRELVM v,char value)           { sq_pushinteger(v,value); }
+inline void Push(HSQUIRRELVM v,unsigned char value)  { sq_pushinteger(v,value); }
+inline void Push(HSQUIRRELVM v,short value)          { sq_pushinteger(v,value); }
+inline void Push(HSQUIRRELVM v,unsigned short value) { sq_pushinteger(v,value); }
+inline void Push(HSQUIRRELVM v,int value)            { sq_pushinteger(v,value); }
+inline void Push(HSQUIRRELVM v,unsigned int value)   { sq_pushinteger(v,value); }
+inline void Push(HSQUIRRELVM v,long value)           { sq_pushinteger(v,value); }
+inline void Push(HSQUIRRELVM v,unsigned long value)  { sq_pushinteger(v,value); }
+inline void Push(HSQUIRRELVM v,double value)         { sq_pushfloat(v,(FLOAT)value); }
+inline void Push(HSQUIRRELVM v,float value)          { sq_pushfloat(v,(FLOAT)value); }
+inline void Push(HSQUIRRELVM v,const SQChar * value) { sq_pushstring(v,value,-1); }
+inline void Push(HSQUIRRELVM v,const SquirrelNull &) { sq_pushnull(v); }
+inline void Push(HSQUIRRELVM v,SQFUNCTION value)     { sq_pushuserpointer(v,(void*)value); }
+inline void Push(HSQUIRRELVM v,SQAnythingPtr value)  { sq_pushuserpointer(v,(void*)value); } // Cast to SQAnythingPtr instead of void * if USE_ARGUMENT_DEPENDANT_OVERLOADS can't be used by your compiler.
+inline void Push(HSQUIRRELVM v,SquirrelObject & so)  { sq_pushobject(v,so.GetObjectHandle()); }
+
+
+#define USE_ARGUMENT_DEPENDANT_OVERLOADS
+#ifdef USE_ARGUMENT_DEPENDANT_OVERLOADS
+#ifdef _MSC_VER
+#pragma warning (disable:4675) // Disable warning: "resolved overload was found by argument-dependent lookup" when class/struct pointers are used as function arguments.
+#endif
+// === BEGIN Argument Dependent Overloads ===
+inline void Push(HSQUIRRELVM v,bool value)                  { sq_pushbool(v,value); }               // Pass bool as int if USE_ARGUMENT_DEPENDANT_OVERLOADS can't be used by your compiler.
+inline void Push(HSQUIRRELVM v,const void * value)          { sq_pushuserpointer(v,(void*)value); } // Pass SQAnythingPtr instead of void * "                                             "
+inline void Push(HSQUIRRELVM v,const SQUserPointer & value) { sq_pushuserpointer(v,(void*)value); }
+// === END Argument Dependent Overloads ===
+#endif
+
+#define SQPLUS_CHECK_GET(res) if (!SQ_SUCCEEDED(res)) throw SquirrelError(_T("sq_get*() failed (type error)"))
+
+inline bool	Match(TypeWrapper<bool>,HSQUIRRELVM v,int idx)           { return sq_gettype(v,idx) == OT_BOOL; }
+inline bool	Match(TypeWrapper<char>,HSQUIRRELVM v,int idx)           { return sq_gettype(v,idx) == OT_INTEGER; }
+inline bool	Match(TypeWrapper<unsigned char>,HSQUIRRELVM v, int idx) { return sq_gettype(v,idx) == OT_INTEGER; }
+inline bool	Match(TypeWrapper<short>,HSQUIRRELVM v,int idx)          { return sq_gettype(v,idx) == OT_INTEGER; }
+inline bool	Match(TypeWrapper<unsigned short>,HSQUIRRELVM v,int idx) { return sq_gettype(v,idx) == OT_INTEGER; }
+inline bool	Match(TypeWrapper<int>,HSQUIRRELVM v,int idx)            { return sq_gettype(v,idx) == OT_INTEGER; }
+inline bool	Match(TypeWrapper<unsigned int>,HSQUIRRELVM v,int idx)   { return sq_gettype(v,idx) == OT_INTEGER; }
+inline bool	Match(TypeWrapper<long>,HSQUIRRELVM v,int idx)           { return sq_gettype(v,idx) == OT_INTEGER; }
+inline bool	Match(TypeWrapper<unsigned long>,HSQUIRRELVM v,int idx)  { return sq_gettype(v,idx) == OT_INTEGER; }
+inline bool	Match(TypeWrapper<float>,HSQUIRRELVM v,int idx)          { int type = sq_gettype(v,idx); return type == OT_FLOAT; }
+inline bool	Match(TypeWrapper<double>,HSQUIRRELVM v,int idx)         { int type = sq_gettype(v,idx); return type == OT_FLOAT; }
+inline bool	Match(TypeWrapper<const SQChar *>,HSQUIRRELVM v,int idx) { return sq_gettype(v,idx) == OT_STRING; }
+inline bool	Match(TypeWrapper<HSQUIRRELVM>,HSQUIRRELVM v,int idx)    { return true; } // See Get() for HSQUIRRELVM below (v is always present).
+inline bool	Match(TypeWrapper<void*>,HSQUIRRELVM v,int idx)          { return sq_gettype(v,idx) == OT_USERPOINTER; }
+inline bool	Match(TypeWrapper<SquirrelObject>,HSQUIRRELVM v,int idx) { return true; } // See sq_getstackobj(): always returns true.
+
+inline void           Get(TypeWrapper<void>,HSQUIRRELVM v,int)                {}
+inline bool           Get(TypeWrapper<bool>,HSQUIRRELVM v,int idx)            { SQBool b; SQPLUS_CHECK_GET(sq_getbool(v,idx,&b)); return b != 0; }
+inline char           Get(TypeWrapper<char>,HSQUIRRELVM v,int idx)            { INT i; SQPLUS_CHECK_GET(sq_getinteger(v,idx,&i)); return static_cast<char>(i); }
+inline unsigned char  Get(TypeWrapper<unsigned char>,HSQUIRRELVM v,int idx)   { INT i; SQPLUS_CHECK_GET(sq_getinteger(v,idx,&i)); return static_cast<unsigned char>(i); }
+inline short          Get(TypeWrapper<short>,HSQUIRRELVM v,int idx)           { INT i; SQPLUS_CHECK_GET(sq_getinteger(v,idx,&i)); return static_cast<short>(i); }
+inline unsigned short	Get(TypeWrapper<unsigned short>,HSQUIRRELVM v,int idx)  { INT i; SQPLUS_CHECK_GET(sq_getinteger(v,idx,&i)); return static_cast<unsigned short>(i); }
+inline int            Get(TypeWrapper<int>,HSQUIRRELVM v,int idx)             { INT i; SQPLUS_CHECK_GET(sq_getinteger(v,idx,&i)); return i; }
+inline unsigned int   Get(TypeWrapper<unsigned int>,HSQUIRRELVM v,int idx)    { INT i; SQPLUS_CHECK_GET(sq_getinteger(v,idx,&i)); return static_cast<unsigned int>(i); }
+inline long           Get(TypeWrapper<long>,HSQUIRRELVM v,int idx)            { INT i; SQPLUS_CHECK_GET(sq_getinteger(v,idx,&i)); return static_cast<long>(i); }
+inline unsigned long  Get(TypeWrapper<unsigned long>,HSQUIRRELVM v,int idx)   { INT i; SQPLUS_CHECK_GET(sq_getinteger(v,idx,&i)); return static_cast<unsigned long>(i); }
+inline float          Get(TypeWrapper<float>,HSQUIRRELVM v,int idx)           { FLOAT f; SQPLUS_CHECK_GET(sq_getfloat(v,idx,&f)); return f; }
+inline double         Get(TypeWrapper<double>,HSQUIRRELVM v,int idx)          { FLOAT f; SQPLUS_CHECK_GET(sq_getfloat(v,idx,&f)); return static_cast<double>(f); }
+inline const SQChar * Get(TypeWrapper<const SQChar *>,HSQUIRRELVM v,int idx)  { const SQChar * s; SQPLUS_CHECK_GET(sq_getstring(v,idx,&s)); return s; }
+inline SquirrelNull   Get(TypeWrapper<SquirrelNull>,HSQUIRRELVM v,int idx)    { (void)v, (void)idx; return SquirrelNull();  }
+inline void *         Get(TypeWrapper<void *>,HSQUIRRELVM v,int idx)          { SQUserPointer p; SQPLUS_CHECK_GET(sq_getuserpointer(v,idx,&p)); return p; }
+inline HSQUIRRELVM    Get(TypeWrapper<HSQUIRRELVM>,HSQUIRRELVM v,int /*idx*/) { sq_poptop(v); return v; } // sq_poptop(v): remove UserData from stack so GetParamCount() matches normal behavior.
+inline SquirrelObject Get(TypeWrapper<SquirrelObject>,HSQUIRRELVM v,int idx)  { HSQOBJECT o; SQPLUS_CHECK_GET(sq_getstackobj(v,idx,&o)); return SquirrelObject(v,o); }
+
+#ifdef SQPLUS_SUPPORT_STD_STRING
+#   ifdef _UNICODE
+inline void Push(HSQUIRRELVM v,const std::wstring& value) { sq_pushstring(v,value.c_str(),-1); }
+inline bool Match(TypeWrapper<const std::wstring&>, HSQUIRRELVM v, int idx) { return sq_gettype(v,idx) == OT_STRING; }
+inline std::wstring Get(TypeWrapper<const std::wstring&>,HSQUIRRELVM v,int idx) { const SQChar * s; SQPLUS_CHECK_GET(sq_getstring(v,idx,&s)); return std::wstring(s); }
+#   else
+inline void Push(HSQUIRRELVM v,const std::string& value) { sq_pushstring(v,value.c_str(),-1); }
+inline bool Match(TypeWrapper<const std::string&>, HSQUIRRELVM v, int idx) { return sq_gettype(v,idx) == OT_STRING; }
+inline std::string Get(TypeWrapper<const std::string&>,HSQUIRRELVM v,int idx) { const SQChar * s; SQPLUS_CHECK_GET(sq_getstring(v,idx,&s)); return std::string(s); }
+#   endif
+#endif
+
+// GetRet() restores the stack for SquirrelFunction<>() calls.
+template<typename RT>
+inline RT GetRet(TypeWrapper<RT>,HSQUIRRELVM v,int idx) { RT ret = Get(TypeWrapper<RT>(),v,idx); sq_pop(v,2); return ret; } // sq_pop(v,2): restore stack after function call.
+
+// Specialization to support void return type.
+inline void GetRet(TypeWrapper<void>,HSQUIRRELVM v,int idx) { sq_pop(v,2); }
+
 // === Example SQClassDef usage (see testSqPlus2.cpp): ===
 
 #if 0
diff -rupwN ../dnl3/SqPlus/sqplus/SquirrelObject.h SqPlus/sqplus/SquirrelObject.h
--- ../dnl3/SqPlus/sqplus/SquirrelObject.h	2006-07-08 01:43:40.000000000 -0400
+++ SqPlus/sqplus/SquirrelObject.h	2009-02-18 09:51:45.000000000 -0500
@@ -1,6 +1,7 @@
 #ifndef _SQUIRREL_OBJECT_H_
 #define _SQUIRREL_OBJECT_H_
 
+class SquirrelVM;
 class SquirrelObject
 {
 	friend class SquirrelVM;
diff -rupwN ../dnl3/SqPlus/sqplus/SquirrelVM.cpp SqPlus/sqplus/SquirrelVM.cpp
--- ../dnl3/SqPlus/sqplus/SquirrelVM.cpp	2006-07-08 02:37:02.000000000 -0400
+++ SqPlus/sqplus/SquirrelVM.cpp	2009-04-17 16:57:20.000000000 -0400
@@ -14,8 +14,12 @@
 #ifdef _MSC_VER
 #define STRLEN(n) _tcslen(n)
 #else
+#ifdef SQUNICODE
+  #define STRLEN(n) wcslen(n)
+#else
 #define STRLEN(n) strlen(n)
 #endif
+#endif
 
 SquirrelError::SquirrelError(const HSQUIRRELVM hvm) 
 {
@@ -79,12 +83,14 @@ void SquirrelVM::Shutdown()
 
 void SquirrelVM::PrintFunc(HSQUIRRELVM v,const SQChar* s,...)
 {
+#if !defined( SQUNICODE )
 	static SQChar temp[2048];
 	va_list vl;
 	va_start(vl, s);
 	scvsprintf( temp,s, vl);
 	SCPUTS(temp);
 	va_end(vl);
+#endif
 }
 
 SquirrelObject SquirrelVM::CompileScript(const SQChar* s)
diff -rupwN ../dnl3/SqPlus/sqstdlib/sqstdaux.cpp SqPlus/sqstdlib/sqstdaux.cpp
--- ../dnl3/SqPlus/sqstdlib/sqstdaux.cpp	2006-03-19 14:32:58.000000000 -0500
+++ SqPlus/sqstdlib/sqstdaux.cpp	2007-08-03 13:18:39.000000000 -0400
@@ -65,7 +65,7 @@ void sqstd_printcallstack(HSQUIRRELVM v)
 					pf(v,_SC("[%s] NATIVECLOSURE\n"),name);
 					break;
 				case OT_GENERATOR:
-					pf(v,_SC("[%s] NATIVECLOSURE\n"),name);
+					pf(v,_SC("[%s] GENERATOR\n"),name);
 					break;
 				case OT_USERDATA:
 					pf(v,_SC("[%s] USERDATA\n"),name);
@@ -80,7 +80,7 @@ void sqstd_printcallstack(HSQUIRRELVM v)
 					pf(v,_SC("[%s] INSTANCE\n"),name);
 					break;
 				case OT_WEAKREF:
-					pf(v,_SC("[%s] INSTANCE\n"),name);
+					pf(v,_SC("[%s] WEAKREF\n"),name);
 					break;
 				case OT_BOOL:{
 					sq_getinteger(v,-1,&i);
diff -rupwN ../dnl3/SqPlus/sqstdlib/sqstdblob.cpp SqPlus/sqstdlib/sqstdblob.cpp
--- ../dnl3/SqPlus/sqstdlib/sqstdblob.cpp	2006-03-19 14:32:58.000000000 -0500
+++ SqPlus/sqstdlib/sqstdblob.cpp	2007-03-11 09:15:07.000000000 -0400
@@ -237,7 +237,6 @@ SQUserPointer sqstd_createblob(HSQUIRREL
 		if(SQ_SUCCEEDED(sq_call(v,2,SQTrue,SQFalse))
 			&& SQ_SUCCEEDED(sq_getinstanceup(v,-1,(SQUserPointer *)&blob,(SQUserPointer)SQSTD_BLOB_TYPE_TAG))) {
 			sq_remove(v,-2);
-			sq_remove(v,-2);
 			return blob->GetBuf();
 		}
 	}
diff -rupwN ../dnl3/SqPlus/sqstdlib/sqstdio.cpp SqPlus/sqstdlib/sqstdio.cpp
--- ../dnl3/SqPlus/sqstdlib/sqstdio.cpp	2006-03-19 14:32:58.000000000 -0500
+++ SqPlus/sqstdlib/sqstdio.cpp	2009-06-24 17:36:32.000000000 -0400
@@ -1,6 +1,8 @@
 /* see copyright notice in squirrel.h */
 #include <new>
 #include <stdio.h>
+#include <stdlib.h>
+#include <wchar.h>
 #include <squirrel.h>
 #include <sqstdio.h>
 #include "sqstdstream.h"
@@ -11,8 +13,25 @@ SQFILE sqstd_fopen(const SQChar *filenam
 {
 #ifndef _UNICODE
 	return (SQFILE)fopen(filename,mode);
-#else
+#elif defined( _MSC_VER )
 	return (SQFILE)_wfopen(filename,mode);
+#else
+	size_t nFilename = wcstombs( NULL, filename, 0 );
+	char * mbFilename = new char[ nFilename + 1 ];
+	if ( 0 >= wcstombs( mbFilename, filename, nFilename + 1 ) )
+		return 0;
+
+	size_t nMode = wcstombs( NULL, mode, 0 );
+	char * mbMode = new char[ nMode + 1 ];
+	if ( 0 >= wcstombs( mbMode, mode, nMode + 1 ) )
+		return 0;
+
+	SQFILE fd = fopen( mbFilename, mbMode );
+
+	delete [] mbFilename;
+	delete [] mbMode;
+
+	return fd;
 #endif
 }
 
diff -rupwN ../dnl3/SqPlus/sqstdlib/sqstdlib71.vcproj SqPlus/sqstdlib/sqstdlib71.vcproj
--- ../dnl3/SqPlus/sqstdlib/sqstdlib71.vcproj	2006-05-29 15:10:46.000000000 -0400
+++ SqPlus/sqstdlib/sqstdlib71.vcproj	1969-12-31 19:00:00.000000000 -0500
@@ -1,503 +0,0 @@
-<?xml version="1.0" encoding="Windows-1252"?>
-<VisualStudioProject
-	ProjectType="Visual C++"
-	Version="7.10"
-	Name="sqstdlib"
-	ProjectGUID="{21FFCF49-0D09-41D3-8A04-F47A0890F27A}"
-	SccProjectName=""
-	SccLocalPath="..">
-	<Platforms>
-		<Platform
-			Name="Win32"/>
-	</Platforms>
-	<Configurations>
-		<Configuration
-			Name="Release|Win32"
-			OutputDirectory="$(ConfigurationName)"
-			IntermediateDirectory="$(ConfigurationName)"
-			ConfigurationType="4"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="FALSE"
-			CharacterSet="2">
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="2"
-				InlineFunctionExpansion="1"
-				AdditionalIncludeDirectories="..\include"
-				PreprocessorDefinitions="WIN32;NDEBUG;_LIB"
-				StringPooling="TRUE"
-				RuntimeLibrary="0"
-				EnableFunctionLevelLinking="TRUE"
-				UsePrecompiledHeader="0"
-				PrecompiledHeaderFile=".\Release/sqstdlib.pch"
-				AssemblerListingLocation="$(IntDir)/"
-				ObjectFile="$(IntDir)/"
-				ProgramDataBaseFileName="$(IntDir)/"
-				WarningLevel="3"
-				SuppressStartupBanner="TRUE"
-				CompileAs="0"/>
-			<Tool
-				Name="VCCustomBuildTool"/>
-			<Tool
-				Name="VCLibrarianTool"
-				OutputFile="..\lib\sqstdlib.lib"
-				SuppressStartupBanner="TRUE"/>
-			<Tool
-				Name="VCMIDLTool"/>
-			<Tool
-				Name="VCPostBuildEventTool"/>
-			<Tool
-				Name="VCPreBuildEventTool"/>
-			<Tool
-				Name="VCPreLinkEventTool"/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="NDEBUG"
-				Culture="1040"/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"/>
-			<Tool
-				Name="VCManagedWrapperGeneratorTool"/>
-			<Tool
-				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
-		</Configuration>
-		<Configuration
-			Name="Debug|Win32"
-			OutputDirectory="$(ConfigurationName)"
-			IntermediateDirectory="$(ConfigurationName)"
-			ConfigurationType="4"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="FALSE"
-			CharacterSet="2">
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="..\include"
-				PreprocessorDefinitions="WIN32;_DEBUG;_LIB"
-				BasicRuntimeChecks="3"
-				RuntimeLibrary="1"
-				UsePrecompiledHeader="0"
-				PrecompiledHeaderFile=".\Debug/sqstdlib.pch"
-				AssemblerListingLocation="$(IntDir)/"
-				ObjectFile="$(IntDir)/"
-				ProgramDataBaseFileName="$(IntDir)/"
-				WarningLevel="3"
-				SuppressStartupBanner="TRUE"
-				DebugInformationFormat="4"
-				CompileAs="0"/>
-			<Tool
-				Name="VCCustomBuildTool"/>
-			<Tool
-				Name="VCLibrarianTool"
-				OutputFile="..\lib\sqstdlibD.lib"
-				SuppressStartupBanner="TRUE"/>
-			<Tool
-				Name="VCMIDLTool"/>
-			<Tool
-				Name="VCPostBuildEventTool"/>
-			<Tool
-				Name="VCPreBuildEventTool"/>
-			<Tool
-				Name="VCPreLinkEventTool"/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="_DEBUG"
-				Culture="1040"/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"/>
-			<Tool
-				Name="VCManagedWrapperGeneratorTool"/>
-			<Tool
-				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
-		</Configuration>
-		<Configuration
-			Name="Debug - Unicode|Win32"
-			OutputDirectory="$(ConfigurationName)"
-			IntermediateDirectory="$(ConfigurationName)"
-			ConfigurationType="4"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="FALSE"
-			CharacterSet="1">
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="..\include"
-				PreprocessorDefinitions="WIN32;_DEBUG;_LIB"
-				BasicRuntimeChecks="3"
-				RuntimeLibrary="1"
-				UsePrecompiledHeader="0"
-				PrecompiledHeaderFile=".\Debug/sqstdlib.pch"
-				AssemblerListingLocation="$(IntDir)/"
-				ObjectFile="$(IntDir)/"
-				ProgramDataBaseFileName="$(IntDir)/"
-				WarningLevel="3"
-				SuppressStartupBanner="TRUE"
-				DebugInformationFormat="4"
-				CompileAs="0"/>
-			<Tool
-				Name="VCCustomBuildTool"/>
-			<Tool
-				Name="VCLibrarianTool"
-				OutputFile="..\lib\sqstdlibDU.lib"
-				SuppressStartupBanner="TRUE"/>
-			<Tool
-				Name="VCMIDLTool"/>
-			<Tool
-				Name="VCPostBuildEventTool"/>
-			<Tool
-				Name="VCPreBuildEventTool"/>
-			<Tool
-				Name="VCPreLinkEventTool"/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="_DEBUG"
-				Culture="1040"/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"/>
-			<Tool
-				Name="VCManagedWrapperGeneratorTool"/>
-			<Tool
-				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
-		</Configuration>
-		<Configuration
-			Name="Release - Unicode|Win32"
-			OutputDirectory="$(ConfigurationName)"
-			IntermediateDirectory="$(ConfigurationName)"
-			ConfigurationType="4"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="FALSE"
-			CharacterSet="1">
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="2"
-				InlineFunctionExpansion="1"
-				AdditionalIncludeDirectories="..\include"
-				PreprocessorDefinitions="WIN32;NDEBUG;_LIB"
-				StringPooling="TRUE"
-				RuntimeLibrary="0"
-				EnableFunctionLevelLinking="TRUE"
-				UsePrecompiledHeader="0"
-				PrecompiledHeaderFile=".\Release/sqstdlib.pch"
-				AssemblerListingLocation="$(IntDir)/"
-				ObjectFile="$(IntDir)/"
-				ProgramDataBaseFileName="$(IntDir)/"
-				WarningLevel="3"
-				SuppressStartupBanner="TRUE"
-				CompileAs="0"/>
-			<Tool
-				Name="VCCustomBuildTool"/>
-			<Tool
-				Name="VCLibrarianTool"
-				OutputFile="..\lib\sqstdlibU.lib"
-				SuppressStartupBanner="TRUE"/>
-			<Tool
-				Name="VCMIDLTool"/>
-			<Tool
-				Name="VCPostBuildEventTool"/>
-			<Tool
-				Name="VCPreBuildEventTool"/>
-			<Tool
-				Name="VCPreLinkEventTool"/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="NDEBUG"
-				Culture="1040"/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"/>
-			<Tool
-				Name="VCManagedWrapperGeneratorTool"/>
-			<Tool
-				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
-		</Configuration>
-	</Configurations>
-	<References>
-	</References>
-	<Files>
-		<Filter
-			Name="Source Files"
-			Filter="cpp;c;cxx;rc;def;r;odl;idl;hpj;bat">
-			<File
-				RelativePath="sqstdaux.cpp">
-				<FileConfiguration
-					Name="Release|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug - Unicode|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release - Unicode|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""/>
-				</FileConfiguration>
-			</File>
-			<File
-				RelativePath="sqstdblob.cpp">
-				<FileConfiguration
-					Name="Release|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug - Unicode|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release - Unicode|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""/>
-				</FileConfiguration>
-			</File>
-			<File
-				RelativePath="sqstdio.cpp">
-				<FileConfiguration
-					Name="Release|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug - Unicode|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release - Unicode|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""/>
-				</FileConfiguration>
-			</File>
-			<File
-				RelativePath="sqstdmath.cpp">
-				<FileConfiguration
-					Name="Release|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug - Unicode|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release - Unicode|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""/>
-				</FileConfiguration>
-			</File>
-			<File
-				RelativePath=".\sqstdrex.cpp">
-			</File>
-			<File
-				RelativePath="sqstdstream.cpp">
-				<FileConfiguration
-					Name="Release|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug - Unicode|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release - Unicode|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""/>
-				</FileConfiguration>
-			</File>
-			<File
-				RelativePath="sqstdstring.cpp">
-				<FileConfiguration
-					Name="Release|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug - Unicode|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release - Unicode|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""/>
-				</FileConfiguration>
-			</File>
-			<File
-				RelativePath="sqstdsystem.cpp">
-				<FileConfiguration
-					Name="Release|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug - Unicode|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release - Unicode|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""/>
-				</FileConfiguration>
-			</File>
-		</Filter>
-		<Filter
-			Name="Header Files"
-			Filter="h;hpp;hxx;hm;inl">
-			<File
-				RelativePath="sqstdblobimpl.h">
-			</File>
-			<File
-				RelativePath="sqstdstream.h">
-			</File>
-		</Filter>
-	</Files>
-	<Globals>
-	</Globals>
-</VisualStudioProject>
diff -rupwN ../dnl3/SqPlus/sqstdlib/sqstdlib.cbp SqPlus/sqstdlib/sqstdlib.cbp
--- ../dnl3/SqPlus/sqstdlib/sqstdlib.cbp	2006-04-25 17:05:30.000000000 -0400
+++ SqPlus/sqstdlib/sqstdlib.cbp	1969-12-31 19:00:00.000000000 -0500
@@ -1,166 +0,0 @@
-<?xml version="1.0"?>
-<!DOCTYPE CodeBlocks_project_file>
-<CodeBlocks_project_file>
-	<FileVersion major="1" minor="1"/>
-	<Project>
-		<Option title="sqstdlib"/>
-		<Option makefile="Makefile"/>
-		<Option makefile_is_custom="0"/>
-		<Option default_target="-1"/>
-		<Option compiler="0"/>
-		<Build>
-			<Target title="Release">
-				<Option output="..\lib\libsqstdlib.a"/>
-				<Option working_dir=""/>
-				<Option object_output="Release"/>
-				<Option deps_output=".deps"/>
-				<Option type="2"/>
-				<Option compiler="0"/>
-				<Option createDefFile="1"/>
-				<Option projectResourceIncludeDirsRelation="2"/>
-				<Compiler>
-					<Add option="-O2"/>
-					<Add option="-W"/>
-					<Add option="-DWIN32"/>
-					<Add option="-DNDEBUG"/>
-					<Add option="-D_LIB"/>
-					<Add option="-D_CRT_SECURE_NO_DEPRECATE"/>
-					<Add directory="..\include"/>
-				</Compiler>
-			</Target>
-			<Target title="Debug">
-				<Option output="..\lib\libsqstdlibD.a"/>
-				<Option working_dir=""/>
-				<Option object_output="Debug"/>
-				<Option deps_output=".deps"/>
-				<Option type="2"/>
-				<Option compiler="0"/>
-				<Option createDefFile="1"/>
-				<Option projectResourceIncludeDirsRelation="2"/>
-				<Compiler>
-					<Add option="-W"/>
-					<Add option="-O0"/>
-					<Add option="-DWIN32"/>
-					<Add option="-D_DEBUG"/>
-					<Add option="-D_LIB"/>
-					<Add option="-D_CRT_SECURE_NO_DEPRECATE"/>
-					<Add directory="..\include"/>
-				</Compiler>
-			</Target>
-			<Target title="Debug - Unicode">
-				<Option output="..\lib\libsqstdlibDU.a"/>
-				<Option working_dir=""/>
-				<Option object_output="Debug - Unicode"/>
-				<Option deps_output=".deps"/>
-				<Option type="2"/>
-				<Option compiler="0"/>
-				<Option createDefFile="1"/>
-				<Option projectResourceIncludeDirsRelation="2"/>
-				<Compiler>
-					<Add option="-W"/>
-					<Add option="-O0"/>
-					<Add option="-DWIN32"/>
-					<Add option="-D_DEBUG"/>
-					<Add option="-D_LIB"/>
-					<Add option="-D_CRT_SECURE_NO_DEPRECATE"/>
-					<Add option="-D_CRT_NON_CONFORMING_SWPRINTFS"/>
-					<Add directory="..\include"/>
-				</Compiler>
-			</Target>
-			<Target title="Release - Unicode">
-				<Option output="..\lib\libsqstdlibU.a"/>
-				<Option working_dir=""/>
-				<Option object_output="Release - Unicode"/>
-				<Option deps_output=".deps"/>
-				<Option type="2"/>
-				<Option compiler="0"/>
-				<Option createDefFile="1"/>
-				<Option projectResourceIncludeDirsRelation="2"/>
-				<Compiler>
-					<Add option="-O2"/>
-					<Add option="-W"/>
-					<Add option="-DWIN32"/>
-					<Add option="-DNDEBUG"/>
-					<Add option="-D_LIB"/>
-					<Add option="-D_CRT_SECURE_NO_DEPRECATE"/>
-					<Add option="-D_CRT_NON_CONFORMING_SWPRINTFS"/>
-					<Add directory="..\include"/>
-				</Compiler>
-			</Target>
-		</Build>
-		<Unit filename="sqstdaux.cpp">
-			<Option compilerVar="CPP"/>
-			<Option target="Release"/>
-			<Option target="Debug"/>
-			<Option target="Debug - Unicode"/>
-			<Option target="Release - Unicode"/>
-		</Unit>
-		<Unit filename="sqstdblob.cpp">
-			<Option compilerVar="CPP"/>
-			<Option target="Release"/>
-			<Option target="Debug"/>
-			<Option target="Debug - Unicode"/>
-			<Option target="Release - Unicode"/>
-		</Unit>
-		<Unit filename="sqstdblobimpl.h">
-			<Option compilerVar=""/>
-			<Option compile="0"/>
-			<Option link="0"/>
-			<Option target="Release"/>
-			<Option target="Debug"/>
-			<Option target="Debug - Unicode"/>
-			<Option target="Release - Unicode"/>
-		</Unit>
-		<Unit filename="sqstdio.cpp">
-			<Option compilerVar="CPP"/>
-			<Option target="Release"/>
-			<Option target="Debug"/>
-			<Option target="Debug - Unicode"/>
-			<Option target="Release - Unicode"/>
-		</Unit>
-		<Unit filename="sqstdmath.cpp">
-			<Option compilerVar="CPP"/>
-			<Option target="Release"/>
-			<Option target="Debug"/>
-			<Option target="Debug - Unicode"/>
-			<Option target="Release - Unicode"/>
-		</Unit>
-		<Unit filename="sqstdrex.cpp">
-			<Option compilerVar="CPP"/>
-			<Option target="Release"/>
-			<Option target="Debug"/>
-			<Option target="Debug - Unicode"/>
-			<Option target="Release - Unicode"/>
-		</Unit>
-		<Unit filename="sqstdstream.cpp">
-			<Option compilerVar="CPP"/>
-			<Option target="Release"/>
-			<Option target="Debug"/>
-			<Option target="Debug - Unicode"/>
-			<Option target="Release - Unicode"/>
-		</Unit>
-		<Unit filename="sqstdstream.h">
-			<Option compilerVar=""/>
-			<Option compile="0"/>
-			<Option link="0"/>
-			<Option target="Release"/>
-			<Option target="Debug"/>
-			<Option target="Debug - Unicode"/>
-			<Option target="Release - Unicode"/>
-		</Unit>
-		<Unit filename="sqstdstring.cpp">
-			<Option compilerVar="CPP"/>
-			<Option target="Release"/>
-			<Option target="Debug"/>
-			<Option target="Debug - Unicode"/>
-			<Option target="Release - Unicode"/>
-		</Unit>
-		<Unit filename="sqstdsystem.cpp">
-			<Option compilerVar="CPP"/>
-			<Option target="Release"/>
-			<Option target="Debug"/>
-			<Option target="Debug - Unicode"/>
-			<Option target="Release - Unicode"/>
-		</Unit>
-	</Project>
-</CodeBlocks_project_file>
diff -rupwN ../dnl3/SqPlus/sqstdlib/sqstdlib.dsp SqPlus/sqstdlib/sqstdlib.dsp
--- ../dnl3/SqPlus/sqstdlib/sqstdlib.dsp	1969-12-31 19:00:00.000000000 -0500
+++ SqPlus/sqstdlib/sqstdlib.dsp	2006-03-18 10:29:17.000000000 -0500
@@ -0,0 +1,131 @@
+# Microsoft Developer Studio Project File - Name="sqstdlib" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE "Win32 (x86) Static Library" 0x0104
+
+CFG=sqstdlib - Win32 Release
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f "sqstdlib.mak".
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f "sqstdlib.mak" CFG="sqstdlib - Win32 Release"
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE "sqstdlib - Win32 Release" (based on "Win32 (x86) Static Library")
+!MESSAGE "sqstdlib - Win32 Debug" (based on "Win32 (x86) Static Library")
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_LocalPath ".."
+CPP=cl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "sqstdlib - Win32 Release"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir "Release"
+# PROP BASE Intermediate_Dir "Release"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir "Release"
+# PROP Intermediate_Dir "Release"
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_MBCS" /D "_LIB" /YX /FD /c
+# ADD CPP /nologo /W3 /GX /O2 /I "..\include" /D "WIN32" /D "NDEBUG" /D "_MBCS" /D "_LIB" /YX /FD /c
+# ADD BASE RSC /l 0x410 /d "NDEBUG"
+# ADD RSC /l 0x410 /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LIB32=link.exe -lib
+# ADD BASE LIB32 /nologo
+# ADD LIB32 /nologo /out:"..\lib\sqstdlib.lib"
+
+!ELSEIF  "$(CFG)" == "sqstdlib - Win32 Debug"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "Debug"
+# PROP BASE Intermediate_Dir "Debug"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "Debug"
+# PROP Intermediate_Dir "Debug"
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_MBCS" /D "_LIB" /YX /FD /GZ /c
+# ADD CPP /nologo /W3 /Gm /GX /ZI /Od /I "..\include" /D "WIN32" /D "_DEBUG" /D "_MBCS" /D "_LIB" /YX /FD /GZ /c
+# ADD BASE RSC /l 0x410 /d "_DEBUG"
+# ADD RSC /l 0x410 /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LIB32=link.exe -lib
+# ADD BASE LIB32 /nologo
+# ADD LIB32 /nologo /out:"..\lib\sqstdlib.lib"
+
+!ENDIF 
+
+# Begin Target
+
+# Name "sqstdlib - Win32 Release"
+# Name "sqstdlib - Win32 Debug"
+# Begin Group "Source Files"
+
+# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
+# Begin Source File
+
+SOURCE=.\sqstdblob.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqstdio.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqstdmath.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqstdrex.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqstdstream.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqstdstring.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqstdaux.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqstdsystem.cpp
+# End Source File
+# End Group
+# Begin Group "Header Files"
+
+# PROP Default_Filter "h;hpp;hxx;hm;inl"
+# Begin Source File
+
+SOURCE=.\sqstdblobimpl.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqstdstream.h
+# End Source File
+# End Group
+# End Target
+# End Project
diff -rupwN ../dnl3/SqPlus/sqstdlib/sqstdlib.vcproj SqPlus/sqstdlib/sqstdlib.vcproj
--- ../dnl3/SqPlus/sqstdlib/sqstdlib.vcproj	2006-03-26 18:21:16.000000000 -0500
+++ SqPlus/sqstdlib/sqstdlib.vcproj	1969-12-31 19:00:00.000000000 -0500
@@ -1,666 +0,0 @@
-<?xml version="1.0" encoding="Windows-1252"?>
-<VisualStudioProject
-	ProjectType="Visual C++"
-	Version="8.00"
-	Name="sqstdlib"
-	ProjectGUID="{B6DA293C-F1BB-4800-8134-70CBE80F70A0}"
-	SccLocalPath=".."
-	>
-	<Platforms>
-		<Platform
-			Name="Win32"
-		/>
-	</Platforms>
-	<ToolFiles>
-	</ToolFiles>
-	<Configurations>
-		<Configuration
-			Name="Release|Win32"
-			OutputDirectory="$(ConfigurationName)"
-			IntermediateDirectory="$(ConfigurationName)"
-			ConfigurationType="4"
-			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC71.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			CharacterSet="2"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="2"
-				InlineFunctionExpansion="1"
-				AdditionalIncludeDirectories="..\include"
-				PreprocessorDefinitions="WIN32;NDEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE"
-				StringPooling="true"
-				RuntimeLibrary="0"
-				EnableFunctionLevelLinking="true"
-				UsePrecompiledHeader="0"
-				PrecompiledHeaderFile=".\Release/sqstdlib.pch"
-				AssemblerListingLocation="$(IntDir)/"
-				ObjectFile="$(IntDir)/"
-				ProgramDataBaseFileName="$(IntDir)/"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-				CompileAs="0"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="NDEBUG"
-				Culture="1040"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLibrarianTool"
-				OutputFile="..\lib\sqstdlib.lib"
-				SuppressStartupBanner="true"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Debug|Win32"
-			OutputDirectory="$(ConfigurationName)"
-			IntermediateDirectory="$(ConfigurationName)"
-			ConfigurationType="4"
-			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC71.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			CharacterSet="2"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="..\include"
-				PreprocessorDefinitions="WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE"
-				BasicRuntimeChecks="3"
-				RuntimeLibrary="1"
-				UsePrecompiledHeader="0"
-				PrecompiledHeaderFile=".\Debug/sqstdlib.pch"
-				AssemblerListingLocation="$(IntDir)/"
-				ObjectFile="$(IntDir)/"
-				ProgramDataBaseFileName="$(IntDir)/"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-				DebugInformationFormat="4"
-				CompileAs="0"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="_DEBUG"
-				Culture="1040"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLibrarianTool"
-				OutputFile="..\lib\sqstdlibD.lib"
-				SuppressStartupBanner="true"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Debug - Unicode|Win32"
-			OutputDirectory="$(ConfigurationName)"
-			IntermediateDirectory="$(ConfigurationName)"
-			ConfigurationType="4"
-			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC71.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			CharacterSet="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="..\include"
-				PreprocessorDefinitions="WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE;_CRT_NON_CONFORMING_SWPRINTFS"
-				BasicRuntimeChecks="3"
-				RuntimeLibrary="1"
-				UsePrecompiledHeader="0"
-				PrecompiledHeaderFile=".\Debug/sqstdlib.pch"
-				AssemblerListingLocation="$(IntDir)/"
-				ObjectFile="$(IntDir)/"
-				ProgramDataBaseFileName="$(IntDir)/"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-				DebugInformationFormat="4"
-				CompileAs="0"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="_DEBUG"
-				Culture="1040"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLibrarianTool"
-				OutputFile="..\lib\sqstdlibDU.lib"
-				SuppressStartupBanner="true"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release - Unicode|Win32"
-			OutputDirectory="$(ConfigurationName)"
-			IntermediateDirectory="$(ConfigurationName)"
-			ConfigurationType="4"
-			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC71.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			CharacterSet="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="2"
-				InlineFunctionExpansion="1"
-				AdditionalIncludeDirectories="..\include"
-				PreprocessorDefinitions="WIN32;NDEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE;_CRT_NON_CONFORMING_SWPRINTFS"
-				StringPooling="true"
-				RuntimeLibrary="0"
-				EnableFunctionLevelLinking="true"
-				UsePrecompiledHeader="0"
-				PrecompiledHeaderFile=".\Release/sqstdlib.pch"
-				AssemblerListingLocation="$(IntDir)/"
-				ObjectFile="$(IntDir)/"
-				ProgramDataBaseFileName="$(IntDir)/"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-				CompileAs="0"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="NDEBUG"
-				Culture="1040"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLibrarianTool"
-				OutputFile="..\lib\sqstdlibU.lib"
-				SuppressStartupBanner="true"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-	</Configurations>
-	<References>
-	</References>
-	<Files>
-		<Filter
-			Name="Source Files"
-			Filter="cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
-			>
-			<File
-				RelativePath="sqstdaux.cpp"
-				>
-				<FileConfiguration
-					Name="Release|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug - Unicode|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release - Unicode|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-					/>
-				</FileConfiguration>
-			</File>
-			<File
-				RelativePath="sqstdblob.cpp"
-				>
-				<FileConfiguration
-					Name="Release|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug - Unicode|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release - Unicode|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-					/>
-				</FileConfiguration>
-			</File>
-			<File
-				RelativePath="sqstdio.cpp"
-				>
-				<FileConfiguration
-					Name="Release|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug - Unicode|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release - Unicode|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-					/>
-				</FileConfiguration>
-			</File>
-			<File
-				RelativePath="sqstdmath.cpp"
-				>
-				<FileConfiguration
-					Name="Release|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug - Unicode|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release - Unicode|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-					/>
-				</FileConfiguration>
-			</File>
-			<File
-				RelativePath=".\sqstdrex.cpp"
-				>
-			</File>
-			<File
-				RelativePath="sqstdstream.cpp"
-				>
-				<FileConfiguration
-					Name="Release|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug - Unicode|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release - Unicode|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-					/>
-				</FileConfiguration>
-			</File>
-			<File
-				RelativePath="sqstdstring.cpp"
-				>
-				<FileConfiguration
-					Name="Release|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug - Unicode|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release - Unicode|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-					/>
-				</FileConfiguration>
-			</File>
-			<File
-				RelativePath="sqstdsystem.cpp"
-				>
-				<FileConfiguration
-					Name="Release|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug - Unicode|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release - Unicode|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-					/>
-				</FileConfiguration>
-			</File>
-		</Filter>
-		<Filter
-			Name="Header Files"
-			Filter="h;hpp;hxx;hm;inl"
-			>
-			<File
-				RelativePath="sqstdblobimpl.h"
-				>
-			</File>
-			<File
-				RelativePath="sqstdstream.h"
-				>
-			</File>
-		</Filter>
-	</Files>
-	<Globals>
-	</Globals>
-</VisualStudioProject>
diff -rupwN ../dnl3/SqPlus/sqstdlib/sqstdmath.cpp SqPlus/sqstdlib/sqstdmath.cpp
--- ../dnl3/SqPlus/sqstdlib/sqstdmath.cpp	2006-03-19 14:32:58.000000000 -0500
+++ SqPlus/sqstdlib/sqstdmath.cpp	2007-08-03 13:20:42.000000000 -0400
@@ -22,7 +22,8 @@
 static SQInteger math_srand(HSQUIRRELVM v)
 {
 	SQInteger i;
-	if(!sq_getinteger(v,2,&i))return sq_throwerror(v,_SC("invalid param"));
+	if(SQ_FAILED(sq_getinteger(v,2,&i)))
+		return sq_throwerror(v,_SC("invalid param"));
 	srand((unsigned int)i);
 	return 0;
 }
diff -rupwN ../dnl3/SqPlus/sqstdlib/sqstdrex.cpp SqPlus/sqstdlib/sqstdrex.cpp
--- ../dnl3/SqPlus/sqstdlib/sqstdrex.cpp	2006-03-19 14:42:14.000000000 -0500
+++ SqPlus/sqstdlib/sqstdrex.cpp	2009-06-24 17:39:13.000000000 -0400
@@ -1,8 +1,11 @@
 /* see copyright notice in squirrel.h */
 #include <squirrel.h>
 #include <string.h>
+#include <wchar.h>
 #include <ctype.h>
+#if !defined ( SQNOSETJMP )
 #include <setjmp.h>
+#endif
 #include "sqstdstring.h"
 
 #ifdef _UINCODE
@@ -24,28 +27,28 @@ static const SQChar *g_nnames[] =
 
 #endif
 
-#define OP_GREEDY		MAX_CHAR+1 // * + ? {n}
-#define OP_OR			MAX_CHAR+2
-#define OP_EXPR			MAX_CHAR+3 //parentesis ()
-#define OP_NOCAPEXPR	MAX_CHAR+4 //parentesis (?:)
-#define OP_DOT			MAX_CHAR+5
-#define OP_CLASS		MAX_CHAR+6
-#define OP_CCLASS		MAX_CHAR+7
-#define OP_NCLASS		MAX_CHAR+8 //negates class the [^
-#define OP_RANGE		MAX_CHAR+9
-#define OP_CHAR			MAX_CHAR+10
-#define OP_EOL			MAX_CHAR+11
-#define OP_BOL			MAX_CHAR+12
-#define OP_WB			MAX_CHAR+13
-
-#define SQREX_SYMBOL_ANY_CHAR '.'
-#define SQREX_SYMBOL_GREEDY_ONE_OR_MORE '+'
-#define SQREX_SYMBOL_GREEDY_ZERO_OR_MORE '*'
-#define SQREX_SYMBOL_GREEDY_ZERO_OR_ONE '?'
-#define SQREX_SYMBOL_BRANCH '|'
-#define SQREX_SYMBOL_END_OF_STRING '$'
-#define SQREX_SYMBOL_BEGINNING_OF_STRING '^'
-#define SQREX_SYMBOL_ESCAPE_CHAR '\\'
+#define OP_GREEDY		(MAX_CHAR+1) // * + ? {n}
+#define OP_OR			(MAX_CHAR+2)
+#define OP_EXPR			(MAX_CHAR+3) //parentesis ()
+#define OP_NOCAPEXPR	(MAX_CHAR+4) //parentesis (?:)
+#define OP_DOT			(MAX_CHAR+5)
+#define OP_CLASS		(MAX_CHAR+6)
+#define OP_CCLASS		(MAX_CHAR+7)
+#define OP_NCLASS		(MAX_CHAR+8) //negates class the [^
+#define OP_RANGE		(MAX_CHAR+9)
+#define OP_CHAR			(MAX_CHAR+10)
+#define OP_EOL			(MAX_CHAR+11)
+#define OP_BOL			(MAX_CHAR+12)
+#define OP_WB			(MAX_CHAR+13)
+
+#define SQREX_SYMBOL_ANY_CHAR ('.')
+#define SQREX_SYMBOL_GREEDY_ONE_OR_MORE ('+')
+#define SQREX_SYMBOL_GREEDY_ZERO_OR_MORE ('*')
+#define SQREX_SYMBOL_GREEDY_ZERO_OR_ONE ('?')
+#define SQREX_SYMBOL_BRANCH ('|')
+#define SQREX_SYMBOL_END_OF_STRING ('$')
+#define SQREX_SYMBOL_BEGINNING_OF_STRING ('^')
+#define SQREX_SYMBOL_ESCAPE_CHAR ('\\')
 
 
 typedef int SQRexNodeType;
@@ -69,7 +72,9 @@ struct SQRex{
 	SQInteger _nsubexpr;
 	SQRexMatch *_matches;
 	SQInteger _currsubexp;
+#if !defined ( SQNOSETJMP )
 	void *_jmpbuf;
+#endif
 	const SQChar **_error;
 };
 
@@ -88,13 +93,18 @@ static SQInteger sqstd_rex_newnode(SQRex
 		exp->_nodes = (SQRexNode *)sq_realloc(exp->_nodes, oldsize * sizeof(SQRexNode) ,exp->_nallocated * sizeof(SQRexNode));
 	}
 	exp->_nodes[exp->_nsize++] = n;
-	return (SQInteger)exp->_nsize - 1;
+	SQInteger newid = exp->_nsize - 1;
+	return (SQInteger)newid;
 }
 
 static void sqstd_rex_error(SQRex *exp,const SQChar *error)
 {
 	if(exp->_error) *exp->_error = error;
+#if !defined ( SQNOSETJMP )
 	longjmp(*((jmp_buf*)exp->_jmpbuf),-1);
+#else
+	throw -1;
+#endif
 }
 
 static void sqstd_rex_expect(SQRex *exp, SQInteger n){
@@ -103,18 +113,6 @@ static void sqstd_rex_expect(SQRex *exp,
 	exp->_p++;
 }
 
-/*static SQBool sqstd_rex_ischar(SQChar c)
-{
-	switch(c) {
-	case SQREX_SYMBOL_BRANCH:case SQREX_SYMBOL_GREEDY_ZERO_OR_MORE:
-	case SQREX_SYMBOL_GREEDY_ZERO_OR_ONE:case SQREX_SYMBOL_GREEDY_ONE_OR_MORE:
-	case SQREX_SYMBOL_BEGINNING_OF_STRING:case SQREX_SYMBOL_END_OF_STRING:
-	case SQREX_SYMBOL_ANY_CHAR:case SQREX_SYMBOL_ESCAPE_CHAR:case '(':case ')':case '[':case '{': case '}':
-		return SQFalse;
-    }
-	return SQTrue;
-}*/
-
 static SQChar sqstd_rex_escapechar(SQRex *exp)
 {
 	if(*exp->_p == SQREX_SYMBOL_ESCAPE_CHAR){
@@ -140,6 +138,7 @@ static SQInteger sqstd_rex_charclass(SQR
 
 static SQInteger sqstd_rex_charnode(SQRex *exp,SQBool isclass)
 {
+	SQChar t;
 	if(*exp->_p == SQREX_SYMBOL_ESCAPE_CHAR) {
 		exp->_p++;
 		switch(*exp->_p) {
@@ -152,8 +151,7 @@ static SQInteger sqstd_rex_charnode(SQRe
 			case 'd': case 'D': case 'x': case 'X': case 'c': case 'C': 
 			case 'p': case 'P': case 'l': case 'u': 
 				{
-				SQChar t = *exp->_p;
-				exp->_p++; 
+				t = *exp->_p; exp->_p++;
 				return sqstd_rex_charclass(exp,t);
 				}
 			case 'b': 
@@ -164,14 +162,17 @@ static SQInteger sqstd_rex_charnode(SQRe
 					exp->_p++; 
 					return node;
 				} //else default
-			default: return sqstd_rex_newnode(exp,(*exp->_p++));
+			default:
+				t = *exp->_p; exp->_p++;
+				return sqstd_rex_newnode(exp,t);
 		}
 	}
 	else if(!scisprint(*exp->_p)) {
 		
 		sqstd_rex_error(exp,_SC("letter expected"));
 	}
-	return sqstd_rex_newnode(exp,*exp->_p++);
+	t = *exp->_p; exp->_p++;
+	return sqstd_rex_newnode(exp,t);
 }
 static SQInteger sqstd_rex_class(SQRex *exp)
 {
@@ -192,7 +193,8 @@ static SQInteger sqstd_rex_class(SQRex *
 			if(first>*exp->_p) sqstd_rex_error(exp,_SC("invalid range"));
 			if(exp->_nodes[first].type == OP_CCLASS) sqstd_rex_error(exp,_SC("cannot use character classes in ranges"));
 			exp->_nodes[r].left = exp->_nodes[first].type;
-			exp->_nodes[r].right = sqstd_rex_escapechar(exp);
+			SQInteger t = sqstd_rex_escapechar(exp);
+			exp->_nodes[r].right = t;
             exp->_nodes[chain].next = r;
 			chain = r;
 			first = -1;
@@ -236,7 +238,7 @@ static SQInteger sqstd_rex_parsenumber(S
 
 static SQInteger sqstd_rex_element(SQRex *exp)
 {
-	SQInteger ret;
+	SQInteger ret = -1;
 	switch(*exp->_p)
 	{
 	case '(': {
@@ -251,7 +253,8 @@ static SQInteger sqstd_rex_element(SQRex
 		}
 		else
 			expr = sqstd_rex_newnode(exp,OP_EXPR);
-		exp->_nodes[expr].left = sqstd_rex_list(exp);
+		SQInteger newn = sqstd_rex_list(exp);
+		exp->_nodes[expr].left = newn;
 		ret = expr;
 		sqstd_rex_expect(exp,')');
 	}
@@ -267,22 +270,24 @@ static SQInteger sqstd_rex_element(SQRex
 		ret = sqstd_rex_charnode(exp,SQFalse);
 		break;
 	}
-	/* scope block */
-	{
+
+
 		SQInteger op;
+	SQBool isgreedy = SQFalse;
 		unsigned short p0 = 0, p1 = 0;
 		switch(*exp->_p){
-		case SQREX_SYMBOL_GREEDY_ZERO_OR_MORE: p0 = 0; p1 = 0xFFFF; exp->_p++; goto __end;
-		case SQREX_SYMBOL_GREEDY_ONE_OR_MORE: p0 = 1; p1 = 0xFFFF; exp->_p++; goto __end;
-		case SQREX_SYMBOL_GREEDY_ZERO_OR_ONE: p0 = 0; p1 = 1; exp->_p++; goto __end;
-		case '{':{
+		case SQREX_SYMBOL_GREEDY_ZERO_OR_MORE: p0 = 0; p1 = 0xFFFF; exp->_p++; isgreedy = SQTrue; break;
+		case SQREX_SYMBOL_GREEDY_ONE_OR_MORE: p0 = 1; p1 = 0xFFFF; exp->_p++; isgreedy = SQTrue; break;
+		case SQREX_SYMBOL_GREEDY_ZERO_OR_ONE: p0 = 0; p1 = 1; exp->_p++; isgreedy = SQTrue; break;
+		case '{':
 			exp->_p++;
 			if(!isdigit(*exp->_p)) sqstd_rex_error(exp,_SC("number expected"));
 			p0 = (unsigned short)sqstd_rex_parsenumber(exp);
+			/*******************************/
 			switch(*exp->_p) {
 			case '}':
 				p1 = p0; exp->_p++;
-				goto __end;
+			break;
 			case ',':
 				exp->_p++;
 				p1 = 0xFFFF;
@@ -290,22 +295,28 @@ static SQInteger sqstd_rex_element(SQRex
 					p1 = (unsigned short)sqstd_rex_parsenumber(exp);
 				}
 				sqstd_rex_expect(exp,'}');
-				goto __end;
+			break;
 			default:
 				sqstd_rex_error(exp,_SC(", or } expected"));
 			}
+			/*******************************/
+			isgreedy = SQTrue;
+			break;
+
 		}
-		__end: {
+	if(isgreedy) {
 				SQInteger nnode = sqstd_rex_newnode(exp,OP_GREEDY);
 				op = OP_GREEDY;
 				exp->_nodes[nnode].left = ret;
 				exp->_nodes[nnode].right = ((p0)<<16)|p1;
 				ret = nnode;
 			}
+
+	if((*exp->_p != SQREX_SYMBOL_BRANCH) && (*exp->_p != ')') && (*exp->_p != SQREX_SYMBOL_GREEDY_ZERO_OR_MORE) && (*exp->_p != SQREX_SYMBOL_GREEDY_ONE_OR_MORE) && (*exp->_p != '\0')) {
+		SQInteger nnode = sqstd_rex_element(exp);
+		exp->_nodes[ret].next = nnode;
 		}
-	}
-	if(*exp->_p != SQREX_SYMBOL_BRANCH && *exp->_p != ')' && *exp->_p != SQREX_SYMBOL_GREEDY_ZERO_OR_MORE && *exp->_p != SQREX_SYMBOL_GREEDY_ONE_OR_MORE && *exp->_p != '\0')
-		exp->_nodes[ret].next = sqstd_rex_element(exp);
+
 	return ret;
 }
 
@@ -323,11 +334,12 @@ static SQInteger sqstd_rex_list(SQRex *e
 	else ret = e;
 
 	if(*exp->_p == SQREX_SYMBOL_BRANCH) {
-		SQInteger temp;
+		SQInteger temp,tright;
 		exp->_p++;
 		temp = sqstd_rex_newnode(exp,OP_OR);
 		exp->_nodes[temp].left = ret;
-		exp->_nodes[temp].right = sqstd_rex_list(exp);
+		tright = sqstd_rex_list(exp);
+		exp->_nodes[temp].right = tright;
 		ret = temp;
 	}
 	return ret;
@@ -531,9 +543,14 @@ SQRex *sqstd_rex_compile(const SQChar *p
 	exp->_nsubexpr = 0;
 	exp->_first = sqstd_rex_newnode(exp,OP_EXPR);
 	exp->_error = error;
+#if !defined ( SQNOSETJMP )
 	exp->_jmpbuf = sq_malloc(sizeof(jmp_buf));
 	if(setjmp(*((jmp_buf*)exp->_jmpbuf)) == 0) {
-		exp->_nodes[exp->_first].left=sqstd_rex_list(exp);
+#else
+	try {
+#endif
+		SQInteger res = sqstd_rex_list(exp);
+		exp->_nodes[exp->_first].left = res;
 		if(*exp->_p!='\0')
 			sqstd_rex_error(exp,_SC("unexpected character"));
 #ifdef _DEBUG
@@ -556,7 +573,11 @@ SQRex *sqstd_rex_compile(const SQChar *p
 		exp->_matches = (SQRexMatch *) sq_malloc(exp->_nsubexpr * sizeof(SQRexMatch));
 		memset(exp->_matches,0,exp->_nsubexpr * sizeof(SQRexMatch));
 	}
+#if !defined ( SQNOSETJMP )
 	else{
+#else
+	catch( ... ) {
+#endif
 		sqstd_rex_free(exp);
 		return NULL;
 	}
diff -rupwN ../dnl3/SqPlus/sqstdlib/sqstdstream.cpp SqPlus/sqstdlib/sqstdstream.cpp
--- ../dnl3/SqPlus/sqstdlib/sqstdstream.cpp	2006-03-19 14:32:58.000000000 -0500
+++ SqPlus/sqstdlib/sqstdstream.cpp	2006-05-07 16:31:18.000000000 -0400
@@ -163,7 +163,7 @@ SQInteger _stream_writen(HSQUIRRELVM v)
 	case 'f': {
 		float f;
 		sq_getfloat(v, 2, &tf);
-		f = tf;
+		f = (float)tf;
 		self->Write(&f, sizeof(float));
 			  }
 		break;
diff -rupwN ../dnl3/SqPlus/sqstdlib/sqstdstring.cpp SqPlus/sqstdlib/sqstdstring.cpp
--- ../dnl3/SqPlus/sqstdlib/sqstdstring.cpp	2006-03-19 14:32:58.000000000 -0500
+++ SqPlus/sqstdlib/sqstdstring.cpp	2009-04-02 12:49:04.000000000 -0400
@@ -2,15 +2,16 @@
 #include <squirrel.h>
 #include <sqstdstring.h>
 #include <string.h>
+#include <wchar.h>
+#include <wctype.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <ctype.h>
 #include <assert.h>
 
-#ifdef _UNICODE
+#ifdef SQUNICODE
 #define scstrchr wcschr
 #define scsnprintf wsnprintf
-#define scatoi _wtoi
 #define scstrtok wcstok
 #else
 #define scstrchr strchr
@@ -121,9 +122,15 @@ static SQInteger _string_format(HSQUIRRE
 			allocated += addlen;
 			dest = sq_getscratchpad(v,allocated);
 			switch(valtype) {
+#if !defined( SQUNICODE ) || defined( _MSC_VER ) || defined( _WIN32_WCE )
 			case 's': i += scsprintf(&dest[i],fmt,ts); break;
 			case 'i': i += scsprintf(&dest[i],fmt,ti); break;
 			case 'f': i += scsprintf(&dest[i],fmt,tf); break;
+#else
+			case 's': i += scsprintf(&dest[i],allocated,fmt,ts); break;
+			case 'i': i += scsprintf(&dest[i],allocated,fmt,ti); break;
+			case 'f': i += scsprintf(&dest[i],allocated,fmt,tf); break;
+#endif
 			};
 			nparam ++;
 		}
@@ -183,19 +190,27 @@ static SQInteger _string_rstrip(HSQUIRRE
 static SQInteger _string_split(HSQUIRRELVM v)
 {
 	const SQChar *str,*seps;
-	SQChar *stemp,*tok;
+	SQChar *stemp,*tok,*tokptr;
 	sq_getstring(v,2,&str);
 	sq_getstring(v,3,&seps);
 	if(sq_getsize(v,3) == 0) return sq_throwerror(v,_SC("empty separators string"));
 	SQInteger memsize = (sq_getsize(v,2)+1)*sizeof(SQChar);
 	stemp = sq_getscratchpad(v,memsize);
 	memcpy(stemp,str,memsize);
+#if defined( _MSC_VER ) || defined( _WIN32_WCE ) || !defined( SQUNICODE )
 	tok = scstrtok(stemp,seps);
+#else
+	tok = scstrtok(stemp,seps,&tokptr);
+#endif
 	sq_newarray(v,0);
 	while( tok != NULL ) {
 		sq_pushstring(v,tok,-1);
 		sq_arrayappend(v,-2);
+#if defined( _MSC_VER ) || defined( _WIN32_WCE ) || !defined( SQUNICODE )
 		tok = scstrtok( NULL, seps );
+#else
+		tok = scstrtok( NULL, seps, &tokptr );
+#endif
 	}
 	return 1;
 }
diff -rupwN ../dnl3/SqPlus/sqstdlib/sqstdsystem.cpp SqPlus/sqstdlib/sqstdsystem.cpp
--- ../dnl3/SqPlus/sqstdlib/sqstdsystem.cpp	2006-03-19 14:32:58.000000000 -0500
+++ SqPlus/sqstdlib/sqstdsystem.cpp	2009-07-13 16:57:25.000000000 -0400
@@ -22,29 +22,41 @@
 
 static SQInteger _system_getenv(HSQUIRRELVM v)
 {
+#if !defined( SQUNICODE ) || defined( _MSC_VER )
 	const SQChar *s;
 	if(SQ_SUCCEEDED(sq_getstring(v,2,&s))){
         sq_pushstring(v,scgetenv(s),-1);
 		return 1;
 	}
 	return 0;
+#else
+	return sq_throwerror(v,_SC("not implemented on this platform"));
+#endif
 }
 
 
 static SQInteger _system_system(HSQUIRRELVM v)
 {
+#if !defined( SQUNICODE ) || defined( _MSC_VER )
 	const SQChar *s;
 	if(SQ_SUCCEEDED(sq_getstring(v,2,&s))){
 		sq_pushinteger(v,scsystem(s));
 		return 1;
 	}
 	return sq_throwerror(v,_SC("wrong param"));
+#else
+	return sq_throwerror(v,_SC("not implemented on this platform"));
+#endif
 }
 
 
 static SQInteger _system_clock(HSQUIRRELVM v)
 {
+#if defined( _WIN32_WCE )
+	sq_pushfloat(v,((SQFloat)time(0)));
+#else
 	sq_pushfloat(v,((SQFloat)clock())/(SQFloat)CLOCKS_PER_SEC);
+#endif
 	return 1;
 }
 
@@ -58,21 +70,31 @@ static SQInteger _system_time(HSQUIRRELV
 
 static SQInteger _system_remove(HSQUIRRELVM v)
 {
+#if !defined( SQUNICODE ) || defined( _MSC_VER )
 	const SQChar *s;
 	sq_getstring(v,2,&s);
 	if(scremove(s)==-1)
 		return sq_throwerror(v,_SC("remove() failed"));
 	return 0;
+	
+#else
+
+	return sq_throwerror(v,_SC("not implemented on this platform"));
+	
+#endif
 }
 
 static SQInteger _system_rename(HSQUIRRELVM v)
 {
-	const SQChar *oldn,*newn;
+#if !defined( SQUNICODE ) || defined( _MSC_VER )	const SQChar *oldn,*newn;
 	sq_getstring(v,2,&oldn);
 	sq_getstring(v,3,&newn);
 	if(screname(oldn,newn)==-1)
 		return sq_throwerror(v,_SC("rename() failed"));
 	return 0;
+#else
+	return sq_throwerror(v,_SC("not implemented on this platform"));
+#endif
 }
 
 static void _set_integer_slot(HSQUIRRELVM v,const SQChar *name,SQInteger val)
diff -rupwN ../dnl3/SqPlus/_sqstdlib/Makefile SqPlus/_sqstdlib/Makefile
--- ../dnl3/SqPlus/_sqstdlib/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ SqPlus/_sqstdlib/Makefile	2006-03-19 14:32:58.000000000 -0500
@@ -0,0 +1,30 @@
+SQUIRREL= ..
+
+
+OUT= $(SQUIRREL)/lib/libsqstdlib.a
+INCZ= -I$(SQUIRREL)/include -I. -Iinclude
+
+SRCS= \
+	sqstdblob.cpp \
+	sqstdio.cpp \
+	sqstdstream.cpp \
+	sqstdmath.cpp \
+	sqstdsystem.cpp \
+	sqstdstring.cpp \
+	sqstdaux.cpp \
+	sqstdrex.cpp
+	
+	
+sq32:
+	gcc -O2  -fno-rtti -Wall -c $(SRCS) $(INCZ)
+	ar rc $(OUT) *.o
+	rm *.o
+
+sqprof:
+	gcc -O2 -pg -fno-rtti -pie -gstabs -g3 -Wall -c $(SRCS) $(INCZ)
+	ar rc $(OUT) *.o
+	rm *.o
+sq64:
+	gcc -O2 -D_SQ64 -fno-rtti -Wall -c $(SRCS) $(INCZ)
+	ar rc $(OUT) *.o
+	rm *.o
diff -rupwN ../dnl3/SqPlus/_sqstdlib/sqstdaux.cpp SqPlus/_sqstdlib/sqstdaux.cpp
--- ../dnl3/SqPlus/_sqstdlib/sqstdaux.cpp	1969-12-31 19:00:00.000000000 -0500
+++ SqPlus/_sqstdlib/sqstdaux.cpp	2006-03-19 14:32:58.000000000 -0500
@@ -0,0 +1,129 @@
+/* see copyright notice in squirrel.h */
+#include <squirrel.h>
+#include <sqstdaux.h>
+#include <assert.h>
+
+void sqstd_printcallstack(HSQUIRRELVM v)
+{
+	SQPRINTFUNCTION pf = sq_getprintfunc(v);
+	if(pf) {
+		SQStackInfos si;
+		SQInteger i;
+		SQFloat f;
+		const SQChar *s;
+		SQInteger level=1; //1 is to skip this function that is level 0
+		const SQChar *name=0; 
+		SQInteger seq=0;
+		pf(v,_SC("\nCALLSTACK\n"));
+		while(SQ_SUCCEEDED(sq_stackinfos(v,level,&si)))
+		{
+			const SQChar *fn=_SC("unknown");
+			const SQChar *src=_SC("unknown");
+			if(si.funcname)fn=si.funcname;
+			if(si.source)src=si.source;
+			pf(v,_SC("*FUNCTION [%s()] %s line [%d]\n"),fn,src,si.line);
+			level++;
+		}
+		level=0;
+		pf(v,_SC("\nLOCALS\n"));
+
+		for(level=0;level<10;level++){
+			seq=0;
+			while((name = sq_getlocal(v,level,seq)))
+			{
+				seq++;
+				switch(sq_gettype(v,-1))
+				{
+				case OT_NULL:
+					pf(v,_SC("[%s] NULL\n"),name);
+					break;
+				case OT_INTEGER:
+					sq_getinteger(v,-1,&i);
+					pf(v,_SC("[%s] %d\n"),name,i);
+					break;
+				case OT_FLOAT:
+					sq_getfloat(v,-1,&f);
+					pf(v,_SC("[%s] %.14g\n"),name,f);
+					break;
+				case OT_USERPOINTER:
+					pf(v,_SC("[%s] USERPOINTER\n"),name);
+					break;
+				case OT_STRING:
+					sq_getstring(v,-1,&s);
+					pf(v,_SC("[%s] \"%s\"\n"),name,s);
+					break;
+				case OT_TABLE:
+					pf(v,_SC("[%s] TABLE\n"),name);
+					break;
+				case OT_ARRAY:
+					pf(v,_SC("[%s] ARRAY\n"),name);
+					break;
+				case OT_CLOSURE:
+					pf(v,_SC("[%s] CLOSURE\n"),name);
+					break;
+				case OT_NATIVECLOSURE:
+					pf(v,_SC("[%s] NATIVECLOSURE\n"),name);
+					break;
+				case OT_GENERATOR:
+					pf(v,_SC("[%s] NATIVECLOSURE\n"),name);
+					break;
+				case OT_USERDATA:
+					pf(v,_SC("[%s] USERDATA\n"),name);
+					break;
+				case OT_THREAD:
+					pf(v,_SC("[%s] THREAD\n"),name);
+					break;
+				case OT_CLASS:
+					pf(v,_SC("[%s] CLASS\n"),name);
+					break;
+				case OT_INSTANCE:
+					pf(v,_SC("[%s] INSTANCE\n"),name);
+					break;
+				case OT_WEAKREF:
+					pf(v,_SC("[%s] INSTANCE\n"),name);
+					break;
+				case OT_BOOL:{
+					sq_getinteger(v,-1,&i);
+					pf(v,_SC("[%s] %s\n"),name,i?_SC("true"):_SC("false"));
+							 }
+					break;
+				default: assert(0); break;
+				}
+				sq_pop(v,1);
+			}
+		}
+	}
+}
+
+static SQInteger _sqstd_aux_printerror(HSQUIRRELVM v)
+{
+	SQPRINTFUNCTION pf = sq_getprintfunc(v);
+	if(pf) {
+		const SQChar *sErr = 0;
+		if(sq_gettop(v)>=1) {
+			if(SQ_SUCCEEDED(sq_getstring(v,2,&sErr)))	{
+				pf(v,_SC("\nAN ERROR HAS OCCURED [%s]\n"),sErr);
+			}
+			else{
+				pf(v,_SC("\nAN ERROR HAS OCCURED [unknown]\n"));
+			}
+			sqstd_printcallstack(v);
+		}
+	}
+	return 0;
+}
+
+void _sqstd_compiler_error(HSQUIRRELVM v,const SQChar *sErr,const SQChar *sSource,SQInteger line,SQInteger column)
+{
+	SQPRINTFUNCTION pf = sq_getprintfunc(v);
+	if(pf) {
+		pf(v,_SC("%s line = (%d) column = (%d) : error %s\n"),sSource,line,column,sErr);
+	}
+}
+
+void sqstd_seterrorhandlers(HSQUIRRELVM v)
+{
+	sq_setcompilererrorhandler(v,_sqstd_compiler_error);
+	sq_newclosure(v,_sqstd_aux_printerror,0);
+	sq_seterrorhandler(v);
+}
diff -rupwN ../dnl3/SqPlus/_sqstdlib/sqstdblob.cpp SqPlus/_sqstdlib/sqstdblob.cpp
--- ../dnl3/SqPlus/_sqstdlib/sqstdblob.cpp	1969-12-31 19:00:00.000000000 -0500
+++ SqPlus/_sqstdlib/sqstdblob.cpp	2006-03-19 14:32:58.000000000 -0500
@@ -0,0 +1,252 @@
+/* see copyright notice in squirrel.h */
+#include <new>
+#include <squirrel.h>
+#include <sqstdio.h>
+#include <string.h>
+#include <sqstdblob.h>
+#include "sqstdstream.h"
+#include "sqstdblobimpl.h"
+
+#define SQSTD_BLOB_TYPE_TAG (SQSTD_STREAM_TYPE_TAG | 0x00000002)
+
+//Blob
+
+
+#define SETUP_BLOB(v) \
+	SQBlob *self = NULL; \
+	{ if(SQ_FAILED(sq_getinstanceup(v,1,(SQUserPointer*)&self,(SQUserPointer)SQSTD_BLOB_TYPE_TAG))) \
+		return SQ_ERROR; }
+
+
+static SQInteger _blob_resize(HSQUIRRELVM v)
+{
+	SETUP_BLOB(v);
+	SQInteger size;
+	sq_getinteger(v,2,&size);
+	if(!self->Resize(size))
+		return sq_throwerror(v,_SC("resize failed"));
+	return 0;
+}
+
+static void __swap_dword(unsigned int *n)
+{
+	*n=(unsigned int)(((*n&0xFF000000)>>24)  |
+			((*n&0x00FF0000)>>8)  |
+			((*n&0x0000FF00)<<8)  |
+			((*n&0x000000FF)<<24));
+}
+
+static void __swap_word(unsigned short *n)
+{
+	*n=(unsigned short)((*n>>8)&0x00FF)| ((*n<<8)&0xFF00);
+}
+
+static SQInteger _blob_swap4(HSQUIRRELVM v)
+{
+	SETUP_BLOB(v);
+	SQInteger num=(self->Len()-(self->Len()%4))>>2;
+	unsigned int *t=(unsigned int *)self->GetBuf();
+	for(SQInteger i = 0; i < num; i++) {
+		__swap_dword(&t[i]);
+	}
+	return 0;
+}
+
+static SQInteger _blob_swap2(HSQUIRRELVM v)
+{
+	SETUP_BLOB(v);
+	SQInteger num=(self->Len()-(self->Len()%2))>>1;
+	unsigned short *t = (unsigned short *)self->GetBuf();
+	for(SQInteger i = 0; i < num; i++) {
+		__swap_word(&t[i]);
+	}
+	return 0;
+}
+
+static SQInteger _blob__set(HSQUIRRELVM v)
+{
+	SETUP_BLOB(v);
+	SQInteger idx,val;
+	sq_getinteger(v,2,&idx);
+	sq_getinteger(v,3,&val);
+	if(idx < 0 || idx >= self->Len())
+		return sq_throwerror(v,_SC("index out of range"));
+	((unsigned char *)self->GetBuf())[idx] = (unsigned char) val;
+	sq_push(v,3);
+	return 1;
+}
+
+static SQInteger _blob__get(HSQUIRRELVM v)
+{
+	SETUP_BLOB(v);
+	SQInteger idx;
+	sq_getinteger(v,2,&idx);
+	if(idx < 0 || idx >= self->Len())
+		return sq_throwerror(v,_SC("index out of range"));
+	sq_pushinteger(v,((unsigned char *)self->GetBuf())[idx]);
+	return 1;
+}
+
+static SQInteger _blob__nexti(HSQUIRRELVM v)
+{
+	SETUP_BLOB(v);
+	if(sq_gettype(v,2) == OT_NULL) {
+		sq_pushinteger(v, 0);
+		return 1;
+	}
+	SQInteger idx;
+	if(SQ_SUCCEEDED(sq_getinteger(v, 2, &idx))) {
+		if(idx+1 < self->Len()) {
+			sq_pushinteger(v, idx+1);
+			return 1;
+		}
+		sq_pushnull(v);
+		return 1;
+	}
+	return sq_throwerror(v,_SC("internal error (_nexti) wrong argument type"));
+}
+
+static SQInteger _blob__typeof(HSQUIRRELVM v)
+{
+	sq_pushstring(v,_SC("blob"),-1);
+	return 1;
+}
+
+static SQInteger _blob_releasehook(SQUserPointer p, SQInteger size)
+{
+	SQBlob *self = (SQBlob*)p;
+	delete self;
+	return 1;
+}
+
+static SQInteger _blob_constructor(HSQUIRRELVM v)
+{
+	SQInteger nparam = sq_gettop(v);
+	SQInteger size = 0;
+	if(nparam == 2) {
+		sq_getinteger(v, 2, &size);
+	}
+	if(size < 0) return sq_throwerror(v, _SC("cannot create blob with negative size"));
+	SQBlob *b = new SQBlob(size);
+	if(SQ_FAILED(sq_setinstanceup(v,1,b))) {
+		delete b;
+		return sq_throwerror(v, _SC("cannot create blob with negative size"));
+	}
+	sq_setreleasehook(v,1,_blob_releasehook);
+	return 0;
+}
+
+#define _DECL_BLOB_FUNC(name,nparams,typecheck) {_SC(#name),_blob_##name,nparams,typecheck}
+static SQRegFunction _blob_methods[] = {
+	_DECL_BLOB_FUNC(constructor,-1,_SC("xn")),
+	_DECL_BLOB_FUNC(resize,2,_SC("xn")),
+	_DECL_BLOB_FUNC(swap2,1,_SC("x")),
+	_DECL_BLOB_FUNC(swap4,1,_SC("x")),
+	_DECL_BLOB_FUNC(_set,3,_SC("xnn")),
+	_DECL_BLOB_FUNC(_get,2,_SC("xn")),
+	_DECL_BLOB_FUNC(_typeof,1,_SC("x")),
+	_DECL_BLOB_FUNC(_nexti,2,_SC("x")),
+	{0,0,0,0}
+};
+
+
+
+//GLOBAL FUNCTIONS
+
+static SQInteger _g_blob_casti2f(HSQUIRRELVM v)
+{
+	SQInteger i;
+	sq_getinteger(v,2,&i);
+	sq_pushfloat(v,*((SQFloat *)&i));
+	return 1;
+}
+
+static SQInteger _g_blob_castf2i(HSQUIRRELVM v)
+{
+	SQFloat f;
+	sq_getfloat(v,2,&f);
+	sq_pushinteger(v,*((SQInteger *)&f));
+	return 1;
+}
+
+static SQInteger _g_blob_swap2(HSQUIRRELVM v)
+{
+	SQInteger i;
+	sq_getinteger(v,2,&i);
+	short s=(short)i;
+	sq_pushinteger(v,(s<<8)|((s>>8)&0x00FF));
+	return 1;
+}
+
+static SQInteger _g_blob_swap4(HSQUIRRELVM v)
+{
+	SQInteger i;
+	sq_getinteger(v,2,&i);
+	unsigned int t4 = (unsigned int)i;
+	__swap_dword(&t4);
+	sq_pushinteger(v,(SQInteger)t4);
+	return 1;
+}
+
+static SQInteger _g_blob_swapfloat(HSQUIRRELVM v)
+{
+	SQFloat f;
+	sq_getfloat(v,2,&f);
+	__swap_dword((unsigned int *)&f);
+	sq_pushfloat(v,f);
+	return 1;
+}
+
+#define _DECL_GLOBALBLOB_FUNC(name,nparams,typecheck) {_SC(#name),_g_blob_##name,nparams,typecheck}
+static SQRegFunction bloblib_funcs[]={
+	_DECL_GLOBALBLOB_FUNC(casti2f,2,_SC(".n")),
+	_DECL_GLOBALBLOB_FUNC(castf2i,2,_SC(".n")),
+	_DECL_GLOBALBLOB_FUNC(swap2,2,_SC(".n")),
+	_DECL_GLOBALBLOB_FUNC(swap4,2,_SC(".n")),
+	_DECL_GLOBALBLOB_FUNC(swapfloat,2,_SC(".n")),
+	{0,0}
+};
+
+SQRESULT sqstd_getblob(HSQUIRRELVM v,SQInteger idx,SQUserPointer *ptr)
+{
+	SQBlob *blob;
+	if(SQ_FAILED(sq_getinstanceup(v,idx,(SQUserPointer *)&blob,(SQUserPointer)SQSTD_BLOB_TYPE_TAG)))
+		return -1;
+	*ptr = blob->GetBuf();
+	return SQ_OK;
+}
+
+SQInteger sqstd_getblobsize(HSQUIRRELVM v,SQInteger idx)
+{
+	SQBlob *blob;
+	if(SQ_FAILED(sq_getinstanceup(v,idx,(SQUserPointer *)&blob,(SQUserPointer)SQSTD_BLOB_TYPE_TAG)))
+		return -1;
+	return blob->Len();
+}
+
+SQUserPointer sqstd_createblob(HSQUIRRELVM v, SQInteger size)
+{
+	SQInteger top = sq_gettop(v);
+	sq_pushregistrytable(v);
+	sq_pushstring(v,_SC("std_blob"),-1);
+	if(SQ_SUCCEEDED(sq_get(v,-2))) {
+		sq_remove(v,-2); //removes the registry
+		sq_push(v,1); // push the this
+		sq_pushinteger(v,size); //size
+		SQBlob *blob = NULL;
+		if(SQ_SUCCEEDED(sq_call(v,2,SQTrue,SQFalse))
+			&& SQ_SUCCEEDED(sq_getinstanceup(v,-1,(SQUserPointer *)&blob,(SQUserPointer)SQSTD_BLOB_TYPE_TAG))) {
+			sq_remove(v,-2);
+			sq_remove(v,-2);
+			return blob->GetBuf();
+		}
+	}
+	sq_settop(v,top);
+	return NULL;
+}
+
+SQRESULT sqstd_register_bloblib(HSQUIRRELVM v)
+{
+	return declare_stream(v,_SC("blob"),(SQUserPointer)SQSTD_BLOB_TYPE_TAG,_SC("std_blob"),_blob_methods,bloblib_funcs);
+}
+
diff -rupwN ../dnl3/SqPlus/_sqstdlib/sqstdblobimpl.h SqPlus/_sqstdlib/sqstdblobimpl.h
--- ../dnl3/SqPlus/_sqstdlib/sqstdblobimpl.h	1969-12-31 19:00:00.000000000 -0500
+++ SqPlus/_sqstdlib/sqstdblobimpl.h	2006-03-19 14:32:58.000000000 -0500
@@ -0,0 +1,108 @@
+/*	see copyright notice in squirrel.h */
+#ifndef _SQSTD_BLOBIMPL_H_
+#define _SQSTD_BLOBIMPL_H_
+
+struct SQBlob : public SQStream
+{
+	SQBlob(SQInteger size) {
+		_size = size;
+		_allocated = size;
+		_buf = (unsigned char *)sq_malloc(size);
+		memset(_buf, 0, _size);
+		_ptr = 0;
+		_owns = true;
+	}
+	virtual ~SQBlob() {
+		sq_free(_buf, _allocated);
+	}
+	SQInteger Write(void *buffer, SQInteger size) {
+		if(!CanAdvance(size)) {
+			GrowBufOf(_ptr + size - _size);
+		}
+		memcpy(&_buf[_ptr], buffer, size);
+		_ptr += size;
+		return size;
+	}
+	SQInteger Read(void *buffer,SQInteger size) {
+		SQInteger n = size;
+		if(!CanAdvance(size)) {
+			if((_size - _ptr) > 0)
+				n = _size - _ptr;
+			else return 0;
+		}
+		memcpy(buffer, &_buf[_ptr], n);
+		_ptr += n;
+		return n;
+	}
+	bool Resize(SQInteger n) {
+		if(!_owns) return false;
+		if(n != _allocated) {
+			unsigned char *newbuf = (unsigned char *)sq_malloc(n);
+			memset(newbuf,0,n);
+			if(_size > n)
+				memcpy(newbuf,_buf,n);
+			else
+				memcpy(newbuf,_buf,_size);
+			sq_free(_buf,_allocated);
+			_buf=newbuf;
+			_allocated = n;
+			if(_size > _allocated)
+				_size = _allocated;
+			if(_ptr > _allocated)
+				_ptr = _allocated;
+		}
+		return true;
+	}
+	bool GrowBufOf(SQInteger n)
+	{
+		bool ret = true;
+		if(_size + n > _allocated) {
+			if(_size + n > _size * 2)
+				ret = Resize(_size + n);
+			else
+				ret = Resize(_size * 2);
+		}
+		_size = _size + n;
+		return ret;
+	}
+	bool CanAdvance(SQInteger n) {
+		if(_ptr+n>_size)return false;
+		return true;
+	}
+	SQInteger Seek(SQInteger offset, SQInteger origin) {
+		switch(origin) {
+			case SQ_SEEK_SET:
+				if(offset > _size || offset < 0) return -1;
+				_ptr = offset;
+				break;
+			case SQ_SEEK_CUR:
+				if(_ptr + offset > _size || _ptr + offset < 0) return -1;
+				_ptr += offset;
+				break;
+			case SQ_SEEK_END:
+				if(_size + offset > _size || _size + offset < 0) return -1;
+				_ptr = _size + offset;
+				break;
+			default: return -1;
+		}
+		return 0;
+	}
+	bool IsValid() {
+		return _buf?true:false;
+	}
+	bool EOS() {
+		return _ptr == _size;
+	}
+	SQInteger Flush() { return 0; }
+	SQInteger Tell() { return _ptr; }
+	SQInteger Len() { return _size; }
+	SQUserPointer GetBuf(){ return _buf; }
+private:
+	SQInteger _size;
+	SQInteger _allocated;
+	SQInteger _ptr;
+	unsigned char *_buf;
+	bool _owns;
+};
+
+#endif //_SQSTD_BLOBIMPL_H_
diff -rupwN ../dnl3/SqPlus/_sqstdlib/sqstdio.cpp SqPlus/_sqstdlib/sqstdio.cpp
--- ../dnl3/SqPlus/_sqstdlib/sqstdio.cpp	1969-12-31 19:00:00.000000000 -0500
+++ SqPlus/_sqstdlib/sqstdio.cpp	2009-03-30 14:03:43.000000000 -0400
@@ -0,0 +1,428 @@
+/* see copyright notice in squirrel.h */
+#include <new>
+#include <stdio.h>
+#include <stdlib.h>
+#include <squirrel.h>
+#include <sqstdio.h>
+#include "sqstdstream.h"
+
+#define SQSTD_FILE_TYPE_TAG (SQSTD_STREAM_TYPE_TAG | 0x00000001)
+//basic API
+SQFILE sqstd_fopen(const SQChar *filename ,const SQChar *mode)
+{
+#ifndef _UNICODE
+	return (SQFILE)fopen(filename,mode);
+#elif defined( _MSC_VER )
+	return (SQFILE)_wfopen(filename,mode);
+#else
+	size_t nFilename = wcstombs( NULL, filename, 0 );
+	char * mbFilename = new char[ nFilename + 1 ];
+	if ( 0 >= wcstombs( mbFilename, filename, nFilename + 1 ) )
+		return 0;
+	
+	size_t nMode = wcstombs( NULL, mode, 0 );
+	char * mbMode = new char[ nMode + 1 ];
+	if ( 0 >= wcstombs( mbMode, mode, nMode + 1 ) )
+		return 0;
+	
+	SQFILE fd = fopen( mbFilename, mbMode );
+		
+	delete [] mbFilename;
+	delete [] mbMode;
+	
+	return fd;
+#endif
+}
+
+SQInteger sqstd_fread(void* buffer, SQInteger size, SQInteger count, SQFILE file)
+{
+	return (SQInteger)fread(buffer,size,count,(FILE *)file);
+}
+
+SQInteger sqstd_fwrite(const SQUserPointer buffer, SQInteger size, SQInteger count, SQFILE file)
+{
+	return (SQInteger)fwrite(buffer,size,count,(FILE *)file);
+}
+
+SQInteger sqstd_fseek(SQFILE file, SQInteger offset, SQInteger origin)
+{
+	SQInteger realorigin;
+	switch(origin) {
+		case SQ_SEEK_CUR: realorigin = SEEK_CUR; break;
+		case SQ_SEEK_END: realorigin = SEEK_END; break;
+		case SQ_SEEK_SET: realorigin = SEEK_SET; break;
+		default: return -1; //failed
+	}
+	return fseek((FILE *)file,(long)offset,(int)realorigin);
+}
+
+SQInteger sqstd_ftell(SQFILE file)
+{
+	return ftell((FILE *)file);
+}
+
+SQInteger sqstd_fflush(SQFILE file)
+{
+	return fflush((FILE *)file);
+}
+
+SQInteger sqstd_fclose(SQFILE file)
+{
+	return fclose((FILE *)file);
+}
+
+SQInteger sqstd_feof(SQFILE file)
+{
+	return feof((FILE *)file);
+}
+
+//File
+struct SQFile : public SQStream {
+	SQFile() { _handle = NULL; _owns = false;}
+	SQFile(SQFILE file, bool owns) { _handle = file; _owns = owns;}
+	virtual ~SQFile() { Close(); }
+	bool Open(const SQChar *filename ,const SQChar *mode) {
+		Close();
+		if( (_handle = sqstd_fopen(filename,mode)) ) {
+			_owns = true;
+			return true;
+		}
+		return false;
+	}
+	void Close() {
+		if(_handle && _owns) { 
+			sqstd_fclose(_handle);
+			_handle = NULL;
+			_owns = false;
+		}
+	}
+	SQInteger Read(void *buffer,SQInteger size) {
+		return sqstd_fread(buffer,1,size,_handle);
+	}
+	SQInteger Write(void *buffer,SQInteger size) {
+		return sqstd_fwrite(buffer,1,size,_handle);
+	}
+	SQInteger Flush() {
+		return sqstd_fflush(_handle);
+	}
+	SQInteger Tell() {
+		return sqstd_ftell(_handle);
+	}
+	SQInteger Len() {
+		SQInteger prevpos=Tell();
+		Seek(0,SQ_SEEK_END);
+		SQInteger size=Tell();
+		Seek(prevpos,SQ_SEEK_SET);
+		return size;
+	}
+	SQInteger Seek(SQInteger offset, SQInteger origin)	{
+		return sqstd_fseek(_handle,offset,origin);
+	}
+	bool IsValid() { return _handle?true:false; }
+	bool EOS() { return Tell()==Len()?true:false;}
+	SQFILE GetHandle() {return _handle;}
+private:
+	SQFILE _handle;
+	bool _owns;
+};
+
+static SQInteger _file__typeof(HSQUIRRELVM v)
+{
+	sq_pushstring(v,_SC("file"),-1);
+	return 1;
+}
+
+static SQInteger _file_releasehook(SQUserPointer p, SQInteger size)
+{
+	SQFile *self = (SQFile*)p;
+	delete self;
+	return 1;
+}
+
+static SQInteger _file_constructor(HSQUIRRELVM v)
+{
+	const SQChar *filename,*mode;
+	bool owns = true;
+	SQFile *f;
+	SQFILE newf;
+	if(sq_gettype(v,2) == OT_STRING && sq_gettype(v,3) == OT_STRING) {
+		sq_getstring(v, 2, &filename);
+		sq_getstring(v, 3, &mode);
+		newf = sqstd_fopen(filename, mode);
+		if(!newf) return sq_throwerror(v, _SC("cannot open file"));
+	} else if(sq_gettype(v,2) == OT_USERPOINTER) {
+		owns = !(sq_gettype(v,3) == OT_NULL);
+		sq_getuserpointer(v,2,&newf);
+	} else {
+		return sq_throwerror(v,_SC("wrong parameter"));
+	}
+	f = new SQFile(newf,owns);
+	if(SQ_FAILED(sq_setinstanceup(v,1,f))) {
+		delete f;
+		return sq_throwerror(v, _SC("cannot create blob with negative size"));
+	}
+	sq_setreleasehook(v,1,_file_releasehook);
+	return 0;
+}
+
+//bindings
+#define _DECL_FILE_FUNC(name,nparams,typecheck) {_SC(#name),_file_##name,nparams,typecheck}
+static SQRegFunction _file_methods[] = {
+	_DECL_FILE_FUNC(constructor,3,_SC("x")),
+	_DECL_FILE_FUNC(_typeof,1,_SC("x")),
+	{0,0,0,0},
+};
+
+
+
+SQRESULT sqstd_createfile(HSQUIRRELVM v, SQFILE file,SQBool own)
+{
+	SQInteger top = sq_gettop(v);
+	sq_pushregistrytable(v);
+	sq_pushstring(v,_SC("std_file"),-1);
+	if(SQ_SUCCEEDED(sq_get(v,-2))) {
+		sq_remove(v,-2); //removes the registry
+		sq_pushroottable(v); // push the this
+		sq_pushuserpointer(v,file); //file
+		if(own){
+			sq_pushinteger(v,1); //true
+		}
+		else{
+			sq_pushnull(v); //false
+		}
+		if(SQ_SUCCEEDED( sq_call(v,3,SQTrue,SQFalse) )) {
+			sq_remove(v,-2);
+			return SQ_OK;
+		}
+	}
+	sq_settop(v,top);
+	return SQ_OK;
+}
+
+SQRESULT sqstd_getfile(HSQUIRRELVM v, SQInteger idx, SQFILE *file)
+{
+	SQFile *fileobj = NULL;
+	if(SQ_SUCCEEDED(sq_getinstanceup(v,idx,(SQUserPointer*)&fileobj,(SQUserPointer)SQSTD_FILE_TYPE_TAG))) {
+		*file = fileobj->GetHandle();
+		return SQ_OK;
+	}
+	return sq_throwerror(v,_SC("not a file"));
+}
+
+
+
+static SQInteger _io_file_lexfeed_ASCII(SQUserPointer file)
+{
+	SQInteger ret;
+	char c;
+	if( ( ret=sqstd_fread(&c,sizeof(c),1,(FILE *)file )>0) )
+		return c;
+	return 0;
+}
+
+static SQInteger _io_file_lexfeed_UTF8(SQUserPointer file)
+{
+#define READ() \
+	if(sqstd_fread(&inchar,sizeof(inchar),1,(FILE *)file) != 1) \
+		return 0;
+
+	static const SQInteger utf8_lengths[16] =
+	{
+		1,1,1,1,1,1,1,1,        /* 0000 to 0111 : 1 byte (plain ASCII) */
+		0,0,0,0,                /* 1000 to 1011 : not valid */
+		2,2,                    /* 1100, 1101 : 2 bytes */
+		3,                      /* 1110 : 3 bytes */
+		4                       /* 1111 :4 bytes */
+	};
+	static unsigned char byte_masks[5] = {0,0,0x1f,0x0f,0x07};
+	unsigned char inchar;
+	SQInteger c = 0;
+	READ();
+	c = inchar;
+	//
+	if(c >= 0x80) {
+		SQInteger tmp;
+		SQInteger codelen = utf8_lengths[c>>4];
+		if(codelen == 0) 
+			return 0;
+			//"invalid UTF-8 stream";
+		tmp = c&byte_masks[codelen];
+		for(SQInteger n = 0; n < codelen-1; n++) {
+			tmp<<=6;
+			READ();
+			tmp |= inchar & 0x3F;
+		}
+		c = tmp;
+	}
+	return c;
+}
+
+static SQInteger _io_file_lexfeed_UCS2_LE(SQUserPointer file)
+{
+	SQInteger ret;
+	wchar_t c;
+	if( ( ret=sqstd_fread(&c,sizeof(c),1,(FILE *)file )>0) )
+		return (SQChar)c;
+	return 0;
+}
+
+static SQInteger _io_file_lexfeed_UCS2_BE(SQUserPointer file)
+{
+	SQInteger ret;
+	unsigned short c;
+	if( ( ret=sqstd_fread(&c,sizeof(c),1,(FILE *)file )>0) ) {
+		c = ((c>>8)&0x00FF)| ((c<<8)&0xFF00);
+		return (SQChar)c;
+	}
+	return 0;
+}
+
+SQInteger file_read(SQUserPointer file,SQUserPointer buf,SQInteger size)
+{
+	SQInteger ret;
+	if( ( ret = sqstd_fread(buf,1,size,(SQFILE)file ))!=0 )return ret;
+	return -1;
+}
+
+SQInteger file_write(SQUserPointer file,SQUserPointer p,SQInteger size)
+{
+	return sqstd_fwrite(p,1,size,(SQFILE)file);
+}
+
+SQRESULT sqstd_loadfile(HSQUIRRELVM v,const SQChar *filename,SQBool printerror)
+{
+	SQFILE file = sqstd_fopen(filename,_SC("rb"));
+	SQInteger ret;
+	unsigned short us;
+	unsigned char uc;
+	SQLEXREADFUNC func = _io_file_lexfeed_ASCII;
+	if(file){
+		ret = sqstd_fread(&us,1,2,file);
+		if(ret != 2) {
+			//probably an empty file
+			us = 0;
+		}
+		if(us == SQ_BYTECODE_STREAM_TAG) { //BYTECODE
+			sqstd_fseek(file,0,SQ_SEEK_SET);
+			if(SQ_SUCCEEDED(sq_readclosure(v,file_read,file))) {
+				sqstd_fclose(file);
+				return SQ_OK;
+			}
+		}
+		else { //SCRIPT
+			switch(us)
+			{
+				//gotta swap the next 2 lines on BIG endian machines
+				case 0xFFFE: func = _io_file_lexfeed_UCS2_BE; break;//UTF-16 little endian;
+				case 0xFEFF: func = _io_file_lexfeed_UCS2_LE; break;//UTF-16 big endian;
+				case 0xBBEF: 
+					if(sqstd_fread(&uc,1,sizeof(uc),file) == 0) { 
+						sqstd_fclose(file); 
+						return sq_throwerror(v,_SC("io error")); 
+					}
+					if(uc != 0xBF) { 
+						sqstd_fclose(file); 
+						return sq_throwerror(v,_SC("Unrecognozed ecoding")); 
+					}
+					func = _io_file_lexfeed_UTF8;
+					break;//UTF-8 ;
+				default: sqstd_fseek(file,0,SQ_SEEK_SET); break; // ascii
+			}
+
+			if(SQ_SUCCEEDED(sq_compile(v,func,file,filename,printerror))){
+				sqstd_fclose(file);
+				return SQ_OK;
+			}
+		}
+		sqstd_fclose(file);
+		return SQ_ERROR;
+	}
+	return sq_throwerror(v,_SC("cannot open the file"));
+}
+
+SQRESULT sqstd_dofile(HSQUIRRELVM v,const SQChar *filename,SQBool retval,SQBool printerror)
+{
+	if(SQ_SUCCEEDED(sqstd_loadfile(v,filename,printerror))) {
+		sq_push(v,-2);
+		if(SQ_SUCCEEDED(sq_call(v,1,retval,SQTrue))) {
+			sq_remove(v,retval?-2:-1); //removes the closure
+			return 1;
+		}
+		sq_pop(v,1); //removes the closure
+	}
+	return SQ_ERROR;
+}
+
+SQRESULT sqstd_writeclosuretofile(HSQUIRRELVM v,const SQChar *filename)
+{
+	SQFILE file = sqstd_fopen(filename,_SC("wb+"));
+	if(!file) return sq_throwerror(v,_SC("cannot open the file"));
+	if(SQ_SUCCEEDED(sq_writeclosure(v,file_write,file))) {
+		sqstd_fclose(file);
+		return SQ_OK;
+	}
+	sqstd_fclose(file);
+	return SQ_ERROR; //forward the error
+}
+
+SQInteger _g_io_loadfile(HSQUIRRELVM v)
+{
+	const SQChar *filename;
+	SQBool printerror = SQFalse;
+	sq_getstring(v,2,&filename);
+	if(sq_gettop(v) >= 3) {
+		sq_getbool(v,3,&printerror);
+	}
+	if(SQ_SUCCEEDED(sqstd_loadfile(v,filename,printerror)))
+		return 1;
+	return SQ_ERROR; //propagates the error
+}
+
+SQInteger _g_io_writeclosuretofile(HSQUIRRELVM v)
+{
+	const SQChar *filename;
+	sq_getstring(v,2,&filename);
+	if(SQ_SUCCEEDED(sqstd_writeclosuretofile(v,filename)))
+		return 1;
+	return SQ_ERROR; //propagates the error
+}
+
+SQInteger _g_io_dofile(HSQUIRRELVM v)
+{
+	const SQChar *filename;
+	SQBool printerror = SQFalse;
+	sq_getstring(v,2,&filename);
+	if(sq_gettop(v) >= 3) {
+		sq_getbool(v,3,&printerror);
+	}
+	sq_push(v,1); //repush the this
+	if(SQ_SUCCEEDED(sqstd_dofile(v,filename,SQTrue,printerror)))
+		return 1;
+	return SQ_ERROR; //propagates the error
+}
+
+#define _DECL_GLOBALIO_FUNC(name,nparams,typecheck) {_SC(#name),_g_io_##name,nparams,typecheck}
+static SQRegFunction iolib_funcs[]={
+	_DECL_GLOBALIO_FUNC(loadfile,-2,_SC(".sb")),
+	_DECL_GLOBALIO_FUNC(dofile,-2,_SC(".sb")),
+	_DECL_GLOBALIO_FUNC(writeclosuretofile,3,_SC(".sc")),
+	{0,0}
+};
+
+SQRESULT sqstd_register_iolib(HSQUIRRELVM v)
+{
+	SQInteger top = sq_gettop(v);
+	//create delegate
+	declare_stream(v,_SC("file"),(SQUserPointer)SQSTD_FILE_TYPE_TAG,_SC("std_file"),_file_methods,iolib_funcs);
+	sq_pushstring(v,_SC("stdout"),-1);
+	sqstd_createfile(v,stdout,SQFalse);
+	sq_createslot(v,-3);
+	sq_pushstring(v,_SC("stdin"),-1);
+	sqstd_createfile(v,stdin,SQFalse);
+	sq_createslot(v,-3);
+	sq_pushstring(v,_SC("stderr"),-1);
+	sqstd_createfile(v,stderr,SQFalse);
+	sq_createslot(v,-3);
+	sq_settop(v,top);
+	return SQ_OK;
+}
diff -rupwN ../dnl3/SqPlus/_sqstdlib/sqstdlib71.vcproj SqPlus/_sqstdlib/sqstdlib71.vcproj
--- ../dnl3/SqPlus/_sqstdlib/sqstdlib71.vcproj	1969-12-31 19:00:00.000000000 -0500
+++ SqPlus/_sqstdlib/sqstdlib71.vcproj	2006-05-29 15:10:46.000000000 -0400
@@ -0,0 +1,503 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="7.10"
+	Name="sqstdlib"
+	ProjectGUID="{21FFCF49-0D09-41D3-8A04-F47A0890F27A}"
+	SccProjectName=""
+	SccLocalPath="..">
+	<Platforms>
+		<Platform
+			Name="Win32"/>
+	</Platforms>
+	<Configurations>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="4"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="FALSE"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="1"
+				AdditionalIncludeDirectories="..\include"
+				PreprocessorDefinitions="WIN32;NDEBUG;_LIB"
+				StringPooling="TRUE"
+				RuntimeLibrary="0"
+				EnableFunctionLevelLinking="TRUE"
+				UsePrecompiledHeader="0"
+				PrecompiledHeaderFile=".\Release/sqstdlib.pch"
+				AssemblerListingLocation="$(IntDir)/"
+				ObjectFile="$(IntDir)/"
+				ProgramDataBaseFileName="$(IntDir)/"
+				WarningLevel="3"
+				SuppressStartupBanner="TRUE"
+				CompileAs="0"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLibrarianTool"
+				OutputFile="..\lib\sqstdlib.lib"
+				SuppressStartupBanner="TRUE"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG"
+				Culture="1040"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="4"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="FALSE"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\include"
+				PreprocessorDefinitions="WIN32;_DEBUG;_LIB"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				UsePrecompiledHeader="0"
+				PrecompiledHeaderFile=".\Debug/sqstdlib.pch"
+				AssemblerListingLocation="$(IntDir)/"
+				ObjectFile="$(IntDir)/"
+				ProgramDataBaseFileName="$(IntDir)/"
+				WarningLevel="3"
+				SuppressStartupBanner="TRUE"
+				DebugInformationFormat="4"
+				CompileAs="0"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLibrarianTool"
+				OutputFile="..\lib\sqstdlibD.lib"
+				SuppressStartupBanner="TRUE"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="1040"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+		<Configuration
+			Name="Debug - Unicode|Win32"
+			OutputDirectory="$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="4"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="FALSE"
+			CharacterSet="1">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\include"
+				PreprocessorDefinitions="WIN32;_DEBUG;_LIB"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				UsePrecompiledHeader="0"
+				PrecompiledHeaderFile=".\Debug/sqstdlib.pch"
+				AssemblerListingLocation="$(IntDir)/"
+				ObjectFile="$(IntDir)/"
+				ProgramDataBaseFileName="$(IntDir)/"
+				WarningLevel="3"
+				SuppressStartupBanner="TRUE"
+				DebugInformationFormat="4"
+				CompileAs="0"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLibrarianTool"
+				OutputFile="..\lib\sqstdlibDU.lib"
+				SuppressStartupBanner="TRUE"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="1040"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+		<Configuration
+			Name="Release - Unicode|Win32"
+			OutputDirectory="$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="4"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="FALSE"
+			CharacterSet="1">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="1"
+				AdditionalIncludeDirectories="..\include"
+				PreprocessorDefinitions="WIN32;NDEBUG;_LIB"
+				StringPooling="TRUE"
+				RuntimeLibrary="0"
+				EnableFunctionLevelLinking="TRUE"
+				UsePrecompiledHeader="0"
+				PrecompiledHeaderFile=".\Release/sqstdlib.pch"
+				AssemblerListingLocation="$(IntDir)/"
+				ObjectFile="$(IntDir)/"
+				ProgramDataBaseFileName="$(IntDir)/"
+				WarningLevel="3"
+				SuppressStartupBanner="TRUE"
+				CompileAs="0"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLibrarianTool"
+				OutputFile="..\lib\sqstdlibU.lib"
+				SuppressStartupBanner="TRUE"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG"
+				Culture="1040"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;rc;def;r;odl;idl;hpj;bat">
+			<File
+				RelativePath="sqstdaux.cpp">
+				<FileConfiguration
+					Name="Release|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug - Unicode|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release - Unicode|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="sqstdblob.cpp">
+				<FileConfiguration
+					Name="Release|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug - Unicode|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release - Unicode|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="sqstdio.cpp">
+				<FileConfiguration
+					Name="Release|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug - Unicode|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release - Unicode|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="sqstdmath.cpp">
+				<FileConfiguration
+					Name="Release|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug - Unicode|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release - Unicode|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath=".\sqstdrex.cpp">
+			</File>
+			<File
+				RelativePath="sqstdstream.cpp">
+				<FileConfiguration
+					Name="Release|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug - Unicode|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release - Unicode|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="sqstdstring.cpp">
+				<FileConfiguration
+					Name="Release|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug - Unicode|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release - Unicode|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="sqstdsystem.cpp">
+				<FileConfiguration
+					Name="Release|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug - Unicode|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release - Unicode|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""/>
+				</FileConfiguration>
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl">
+			<File
+				RelativePath="sqstdblobimpl.h">
+			</File>
+			<File
+				RelativePath="sqstdstream.h">
+			</File>
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -rupwN ../dnl3/SqPlus/_sqstdlib/sqstdlib.cbp SqPlus/_sqstdlib/sqstdlib.cbp
--- ../dnl3/SqPlus/_sqstdlib/sqstdlib.cbp	1969-12-31 19:00:00.000000000 -0500
+++ SqPlus/_sqstdlib/sqstdlib.cbp	2006-04-25 17:05:30.000000000 -0400
@@ -0,0 +1,166 @@
+<?xml version="1.0"?>
+<!DOCTYPE CodeBlocks_project_file>
+<CodeBlocks_project_file>
+	<FileVersion major="1" minor="1"/>
+	<Project>
+		<Option title="sqstdlib"/>
+		<Option makefile="Makefile"/>
+		<Option makefile_is_custom="0"/>
+		<Option default_target="-1"/>
+		<Option compiler="0"/>
+		<Build>
+			<Target title="Release">
+				<Option output="..\lib\libsqstdlib.a"/>
+				<Option working_dir=""/>
+				<Option object_output="Release"/>
+				<Option deps_output=".deps"/>
+				<Option type="2"/>
+				<Option compiler="0"/>
+				<Option createDefFile="1"/>
+				<Option projectResourceIncludeDirsRelation="2"/>
+				<Compiler>
+					<Add option="-O2"/>
+					<Add option="-W"/>
+					<Add option="-DWIN32"/>
+					<Add option="-DNDEBUG"/>
+					<Add option="-D_LIB"/>
+					<Add option="-D_CRT_SECURE_NO_DEPRECATE"/>
+					<Add directory="..\include"/>
+				</Compiler>
+			</Target>
+			<Target title="Debug">
+				<Option output="..\lib\libsqstdlibD.a"/>
+				<Option working_dir=""/>
+				<Option object_output="Debug"/>
+				<Option deps_output=".deps"/>
+				<Option type="2"/>
+				<Option compiler="0"/>
+				<Option createDefFile="1"/>
+				<Option projectResourceIncludeDirsRelation="2"/>
+				<Compiler>
+					<Add option="-W"/>
+					<Add option="-O0"/>
+					<Add option="-DWIN32"/>
+					<Add option="-D_DEBUG"/>
+					<Add option="-D_LIB"/>
+					<Add option="-D_CRT_SECURE_NO_DEPRECATE"/>
+					<Add directory="..\include"/>
+				</Compiler>
+			</Target>
+			<Target title="Debug - Unicode">
+				<Option output="..\lib\libsqstdlibDU.a"/>
+				<Option working_dir=""/>
+				<Option object_output="Debug - Unicode"/>
+				<Option deps_output=".deps"/>
+				<Option type="2"/>
+				<Option compiler="0"/>
+				<Option createDefFile="1"/>
+				<Option projectResourceIncludeDirsRelation="2"/>
+				<Compiler>
+					<Add option="-W"/>
+					<Add option="-O0"/>
+					<Add option="-DWIN32"/>
+					<Add option="-D_DEBUG"/>
+					<Add option="-D_LIB"/>
+					<Add option="-D_CRT_SECURE_NO_DEPRECATE"/>
+					<Add option="-D_CRT_NON_CONFORMING_SWPRINTFS"/>
+					<Add directory="..\include"/>
+				</Compiler>
+			</Target>
+			<Target title="Release - Unicode">
+				<Option output="..\lib\libsqstdlibU.a"/>
+				<Option working_dir=""/>
+				<Option object_output="Release - Unicode"/>
+				<Option deps_output=".deps"/>
+				<Option type="2"/>
+				<Option compiler="0"/>
+				<Option createDefFile="1"/>
+				<Option projectResourceIncludeDirsRelation="2"/>
+				<Compiler>
+					<Add option="-O2"/>
+					<Add option="-W"/>
+					<Add option="-DWIN32"/>
+					<Add option="-DNDEBUG"/>
+					<Add option="-D_LIB"/>
+					<Add option="-D_CRT_SECURE_NO_DEPRECATE"/>
+					<Add option="-D_CRT_NON_CONFORMING_SWPRINTFS"/>
+					<Add directory="..\include"/>
+				</Compiler>
+			</Target>
+		</Build>
+		<Unit filename="sqstdaux.cpp">
+			<Option compilerVar="CPP"/>
+			<Option target="Release"/>
+			<Option target="Debug"/>
+			<Option target="Debug - Unicode"/>
+			<Option target="Release - Unicode"/>
+		</Unit>
+		<Unit filename="sqstdblob.cpp">
+			<Option compilerVar="CPP"/>
+			<Option target="Release"/>
+			<Option target="Debug"/>
+			<Option target="Debug - Unicode"/>
+			<Option target="Release - Unicode"/>
+		</Unit>
+		<Unit filename="sqstdblobimpl.h">
+			<Option compilerVar=""/>
+			<Option compile="0"/>
+			<Option link="0"/>
+			<Option target="Release"/>
+			<Option target="Debug"/>
+			<Option target="Debug - Unicode"/>
+			<Option target="Release - Unicode"/>
+		</Unit>
+		<Unit filename="sqstdio.cpp">
+			<Option compilerVar="CPP"/>
+			<Option target="Release"/>
+			<Option target="Debug"/>
+			<Option target="Debug - Unicode"/>
+			<Option target="Release - Unicode"/>
+		</Unit>
+		<Unit filename="sqstdmath.cpp">
+			<Option compilerVar="CPP"/>
+			<Option target="Release"/>
+			<Option target="Debug"/>
+			<Option target="Debug - Unicode"/>
+			<Option target="Release - Unicode"/>
+		</Unit>
+		<Unit filename="sqstdrex.cpp">
+			<Option compilerVar="CPP"/>
+			<Option target="Release"/>
+			<Option target="Debug"/>
+			<Option target="Debug - Unicode"/>
+			<Option target="Release - Unicode"/>
+		</Unit>
+		<Unit filename="sqstdstream.cpp">
+			<Option compilerVar="CPP"/>
+			<Option target="Release"/>
+			<Option target="Debug"/>
+			<Option target="Debug - Unicode"/>
+			<Option target="Release - Unicode"/>
+		</Unit>
+		<Unit filename="sqstdstream.h">
+			<Option compilerVar=""/>
+			<Option compile="0"/>
+			<Option link="0"/>
+			<Option target="Release"/>
+			<Option target="Debug"/>
+			<Option target="Debug - Unicode"/>
+			<Option target="Release - Unicode"/>
+		</Unit>
+		<Unit filename="sqstdstring.cpp">
+			<Option compilerVar="CPP"/>
+			<Option target="Release"/>
+			<Option target="Debug"/>
+			<Option target="Debug - Unicode"/>
+			<Option target="Release - Unicode"/>
+		</Unit>
+		<Unit filename="sqstdsystem.cpp">
+			<Option compilerVar="CPP"/>
+			<Option target="Release"/>
+			<Option target="Debug"/>
+			<Option target="Debug - Unicode"/>
+			<Option target="Release - Unicode"/>
+		</Unit>
+	</Project>
+</CodeBlocks_project_file>
diff -rupwN ../dnl3/SqPlus/_sqstdlib/sqstdlib.vcproj SqPlus/_sqstdlib/sqstdlib.vcproj
--- ../dnl3/SqPlus/_sqstdlib/sqstdlib.vcproj	1969-12-31 19:00:00.000000000 -0500
+++ SqPlus/_sqstdlib/sqstdlib.vcproj	2006-03-26 18:21:16.000000000 -0500
@@ -0,0 +1,666 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="8.00"
+	Name="sqstdlib"
+	ProjectGUID="{B6DA293C-F1BB-4800-8134-70CBE80F70A0}"
+	SccLocalPath=".."
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="4"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC71.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="1"
+				AdditionalIncludeDirectories="..\include"
+				PreprocessorDefinitions="WIN32;NDEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE"
+				StringPooling="true"
+				RuntimeLibrary="0"
+				EnableFunctionLevelLinking="true"
+				UsePrecompiledHeader="0"
+				PrecompiledHeaderFile=".\Release/sqstdlib.pch"
+				AssemblerListingLocation="$(IntDir)/"
+				ObjectFile="$(IntDir)/"
+				ProgramDataBaseFileName="$(IntDir)/"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+				CompileAs="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG"
+				Culture="1040"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+				OutputFile="..\lib\sqstdlib.lib"
+				SuppressStartupBanner="true"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="4"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC71.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\include"
+				PreprocessorDefinitions="WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				UsePrecompiledHeader="0"
+				PrecompiledHeaderFile=".\Debug/sqstdlib.pch"
+				AssemblerListingLocation="$(IntDir)/"
+				ObjectFile="$(IntDir)/"
+				ProgramDataBaseFileName="$(IntDir)/"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+				DebugInformationFormat="4"
+				CompileAs="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="1040"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+				OutputFile="..\lib\sqstdlibD.lib"
+				SuppressStartupBanner="true"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug - Unicode|Win32"
+			OutputDirectory="$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="4"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC71.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\include"
+				PreprocessorDefinitions="WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE;_CRT_NON_CONFORMING_SWPRINTFS"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				UsePrecompiledHeader="0"
+				PrecompiledHeaderFile=".\Debug/sqstdlib.pch"
+				AssemblerListingLocation="$(IntDir)/"
+				ObjectFile="$(IntDir)/"
+				ProgramDataBaseFileName="$(IntDir)/"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+				DebugInformationFormat="4"
+				CompileAs="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="1040"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+				OutputFile="..\lib\sqstdlibDU.lib"
+				SuppressStartupBanner="true"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release - Unicode|Win32"
+			OutputDirectory="$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="4"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC71.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="1"
+				AdditionalIncludeDirectories="..\include"
+				PreprocessorDefinitions="WIN32;NDEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE;_CRT_NON_CONFORMING_SWPRINTFS"
+				StringPooling="true"
+				RuntimeLibrary="0"
+				EnableFunctionLevelLinking="true"
+				UsePrecompiledHeader="0"
+				PrecompiledHeaderFile=".\Release/sqstdlib.pch"
+				AssemblerListingLocation="$(IntDir)/"
+				ObjectFile="$(IntDir)/"
+				ProgramDataBaseFileName="$(IntDir)/"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+				CompileAs="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG"
+				Culture="1040"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+				OutputFile="..\lib\sqstdlibU.lib"
+				SuppressStartupBanner="true"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
+			>
+			<File
+				RelativePath="sqstdaux.cpp"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug - Unicode|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release - Unicode|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="sqstdblob.cpp"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug - Unicode|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release - Unicode|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="sqstdio.cpp"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug - Unicode|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release - Unicode|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="sqstdmath.cpp"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug - Unicode|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release - Unicode|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath=".\sqstdrex.cpp"
+				>
+			</File>
+			<File
+				RelativePath="sqstdstream.cpp"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug - Unicode|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release - Unicode|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="sqstdstring.cpp"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug - Unicode|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release - Unicode|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="sqstdsystem.cpp"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug - Unicode|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release - Unicode|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl"
+			>
+			<File
+				RelativePath="sqstdblobimpl.h"
+				>
+			</File>
+			<File
+				RelativePath="sqstdstream.h"
+				>
+			</File>
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -rupwN ../dnl3/SqPlus/_sqstdlib/sqstdmath.cpp SqPlus/_sqstdlib/sqstdmath.cpp
--- ../dnl3/SqPlus/_sqstdlib/sqstdmath.cpp	1969-12-31 19:00:00.000000000 -0500
+++ SqPlus/_sqstdlib/sqstdmath.cpp	2006-03-19 14:32:58.000000000 -0500
@@ -0,0 +1,105 @@
+/* see copyright notice in squirrel.h */
+#include <squirrel.h>
+#include <math.h>
+#include <stdlib.h>
+#include <sqstdmath.h>
+
+#define SINGLE_ARG_FUNC(_funcname) static SQInteger math_##_funcname(HSQUIRRELVM v){ \
+	SQFloat f; \
+	sq_getfloat(v,2,&f); \
+	sq_pushfloat(v,(SQFloat)_funcname(f)); \
+	return 1; \
+}
+
+#define TWO_ARGS_FUNC(_funcname) static SQInteger math_##_funcname(HSQUIRRELVM v){ \
+	SQFloat p1,p2; \
+	sq_getfloat(v,2,&p1); \
+	sq_getfloat(v,3,&p2); \
+	sq_pushfloat(v,(SQFloat)_funcname(p1,p2)); \
+	return 1; \
+}
+
+static SQInteger math_srand(HSQUIRRELVM v)
+{
+	SQInteger i;
+	if(!sq_getinteger(v,2,&i))return sq_throwerror(v,_SC("invalid param"));
+	srand((unsigned int)i);
+	return 0;
+}
+
+static SQInteger math_rand(HSQUIRRELVM v)
+{
+	sq_pushinteger(v,rand());
+	return 1;
+}
+
+static SQInteger math_abs(HSQUIRRELVM v)
+{
+	SQInteger n;
+	sq_getinteger(v,2,&n);
+	sq_pushinteger(v,(SQInteger)abs((int)n)); 
+	return 1; 
+}
+
+SINGLE_ARG_FUNC(sqrt)
+SINGLE_ARG_FUNC(fabs)
+SINGLE_ARG_FUNC(sin)
+SINGLE_ARG_FUNC(cos)
+SINGLE_ARG_FUNC(asin)
+SINGLE_ARG_FUNC(acos)
+SINGLE_ARG_FUNC(log)
+SINGLE_ARG_FUNC(log10)
+SINGLE_ARG_FUNC(tan)
+SINGLE_ARG_FUNC(atan)
+TWO_ARGS_FUNC(atan2)
+TWO_ARGS_FUNC(pow)
+SINGLE_ARG_FUNC(floor)
+SINGLE_ARG_FUNC(ceil)
+SINGLE_ARG_FUNC(exp)
+
+#define _DECL_FUNC(name,nparams,tycheck) {_SC(#name),math_##name,nparams,tycheck}
+static SQRegFunction mathlib_funcs[] = {
+	_DECL_FUNC(sqrt,2,_SC(".n")),
+	_DECL_FUNC(sin,2,_SC(".n")),
+	_DECL_FUNC(cos,2,_SC(".n")),
+	_DECL_FUNC(asin,2,_SC(".n")),
+	_DECL_FUNC(acos,2,_SC(".n")),
+	_DECL_FUNC(log,2,_SC(".n")),
+	_DECL_FUNC(log10,2,_SC(".n")),
+	_DECL_FUNC(tan,2,_SC(".n")),
+	_DECL_FUNC(atan,2,_SC(".n")),
+	_DECL_FUNC(atan2,3,_SC(".nn")),
+	_DECL_FUNC(pow,3,_SC(".nn")),
+	_DECL_FUNC(floor,2,_SC(".n")),
+	_DECL_FUNC(ceil,2,_SC(".n")),
+	_DECL_FUNC(exp,2,_SC(".n")),
+	_DECL_FUNC(srand,2,_SC(".n")),
+	_DECL_FUNC(rand,1,NULL),
+	_DECL_FUNC(fabs,2,_SC(".n")),
+	_DECL_FUNC(abs,2,_SC(".n")),
+	{0,0},
+};
+
+#ifndef M_PI
+#define M_PI (3.14159265358979323846)
+#endif
+
+SQRESULT sqstd_register_mathlib(HSQUIRRELVM v)
+{
+	SQInteger i=0;
+	while(mathlib_funcs[i].name!=0)	{
+		sq_pushstring(v,mathlib_funcs[i].name,-1);
+		sq_newclosure(v,mathlib_funcs[i].f,0);
+		sq_setparamscheck(v,mathlib_funcs[i].nparamscheck,mathlib_funcs[i].typemask);
+		sq_setnativeclosurename(v,-1,mathlib_funcs[i].name);
+		sq_createslot(v,-3);
+		i++;
+	}
+	sq_pushstring(v,_SC("RAND_MAX"),-1);
+	sq_pushinteger(v,RAND_MAX);
+	sq_createslot(v,-3);
+	sq_pushstring(v,_SC("PI"),-1);
+	sq_pushfloat(v,(SQFloat)M_PI);
+	sq_createslot(v,-3);
+	return SQ_OK;
+}
diff -rupwN ../dnl3/SqPlus/_sqstdlib/sqstdrex.cpp SqPlus/_sqstdlib/sqstdrex.cpp
--- ../dnl3/SqPlus/_sqstdlib/sqstdrex.cpp	1969-12-31 19:00:00.000000000 -0500
+++ SqPlus/_sqstdlib/sqstdrex.cpp	2009-03-30 14:08:18.000000000 -0400
@@ -0,0 +1,634 @@
+/* see copyright notice in squirrel.h */
+#include <squirrel.h>
+#include <string.h>
+#include <wchar.h>
+#include <ctype.h>
+#include <setjmp.h>
+#include "sqstdstring.h"
+
+#ifdef _UINCODE
+#define scisprint iswprint
+#else
+#define scisprint isprint
+#endif
+
+#ifdef _DEBUG
+#include <stdio.h>
+
+static const SQChar *g_nnames[] =
+{
+	_SC("NONE"),_SC("OP_GREEDY"),	_SC("OP_OR"),
+	_SC("OP_EXPR"),_SC("OP_NOCAPEXPR"),_SC("OP_DOT"),	_SC("OP_CLASS"),
+	_SC("OP_CCLASS"),_SC("OP_NCLASS"),_SC("OP_RANGE"),_SC("OP_CHAR"),
+	_SC("OP_EOL"),_SC("OP_BOL"),_SC("OP_WB")
+};
+
+#endif
+
+#define OP_GREEDY		MAX_CHAR+1 // * + ? {n}
+#define OP_OR			MAX_CHAR+2
+#define OP_EXPR			MAX_CHAR+3 //parentesis ()
+#define OP_NOCAPEXPR	MAX_CHAR+4 //parentesis (?:)
+#define OP_DOT			MAX_CHAR+5
+#define OP_CLASS		MAX_CHAR+6
+#define OP_CCLASS		MAX_CHAR+7
+#define OP_NCLASS		MAX_CHAR+8 //negates class the [^
+#define OP_RANGE		MAX_CHAR+9
+#define OP_CHAR			MAX_CHAR+10
+#define OP_EOL			MAX_CHAR+11
+#define OP_BOL			MAX_CHAR+12
+#define OP_WB			MAX_CHAR+13
+
+#define SQREX_SYMBOL_ANY_CHAR '.'
+#define SQREX_SYMBOL_GREEDY_ONE_OR_MORE '+'
+#define SQREX_SYMBOL_GREEDY_ZERO_OR_MORE '*'
+#define SQREX_SYMBOL_GREEDY_ZERO_OR_ONE '?'
+#define SQREX_SYMBOL_BRANCH '|'
+#define SQREX_SYMBOL_END_OF_STRING '$'
+#define SQREX_SYMBOL_BEGINNING_OF_STRING '^'
+#define SQREX_SYMBOL_ESCAPE_CHAR '\\'
+
+
+typedef int SQRexNodeType;
+
+typedef struct tagSQRexNode{
+	SQRexNodeType type;
+	SQInteger left;
+	SQInteger right;
+	SQInteger next;
+}SQRexNode;
+
+struct SQRex{
+	const SQChar *_eol;
+	const SQChar *_bol;
+	const SQChar *_p;
+	SQInteger _first;
+	SQInteger _op;
+	SQRexNode *_nodes;
+	SQInteger _nallocated;
+	SQInteger _nsize;
+	SQInteger _nsubexpr;
+	SQRexMatch *_matches;
+	SQInteger _currsubexp;
+	void *_jmpbuf;
+	const SQChar **_error;
+};
+
+static SQInteger sqstd_rex_list(SQRex *exp);
+
+static SQInteger sqstd_rex_newnode(SQRex *exp, SQRexNodeType type)
+{
+	SQRexNode n;
+	n.type = type;
+	n.next = n.right = n.left = -1;
+	if(type == OP_EXPR)
+		n.right = exp->_nsubexpr++;
+	if(exp->_nallocated < (exp->_nsize + 1)) {
+		SQInteger oldsize = exp->_nallocated;
+		exp->_nallocated *= 2;
+		exp->_nodes = (SQRexNode *)sq_realloc(exp->_nodes, oldsize * sizeof(SQRexNode) ,exp->_nallocated * sizeof(SQRexNode));
+	}
+	exp->_nodes[exp->_nsize++] = n;
+	return (SQInteger)exp->_nsize - 1;
+}
+
+static void sqstd_rex_error(SQRex *exp,const SQChar *error)
+{
+	if(exp->_error) *exp->_error = error;
+	longjmp(*((jmp_buf*)exp->_jmpbuf),-1);
+}
+
+static void sqstd_rex_expect(SQRex *exp, SQInteger n){
+	if((*exp->_p) != n) 
+		sqstd_rex_error(exp, _SC("expected paren"));
+	exp->_p++;
+}
+
+/*static SQBool sqstd_rex_ischar(SQChar c)
+{
+	switch(c) {
+	case SQREX_SYMBOL_BRANCH:case SQREX_SYMBOL_GREEDY_ZERO_OR_MORE:
+	case SQREX_SYMBOL_GREEDY_ZERO_OR_ONE:case SQREX_SYMBOL_GREEDY_ONE_OR_MORE:
+	case SQREX_SYMBOL_BEGINNING_OF_STRING:case SQREX_SYMBOL_END_OF_STRING:
+	case SQREX_SYMBOL_ANY_CHAR:case SQREX_SYMBOL_ESCAPE_CHAR:case '(':case ')':case '[':case '{': case '}':
+		return SQFalse;
+    }
+	return SQTrue;
+}*/
+
+static SQChar sqstd_rex_escapechar(SQRex *exp)
+{
+	if(*exp->_p == SQREX_SYMBOL_ESCAPE_CHAR){
+		exp->_p++;
+		switch(*exp->_p) {
+		case 'v': exp->_p++; return '\v';
+		case 'n': exp->_p++; return '\n';
+		case 't': exp->_p++; return '\t';
+		case 'r': exp->_p++; return '\r';
+		case 'f': exp->_p++; return '\f';
+		default: return (*exp->_p++);
+		}
+	} else if(!scisprint(*exp->_p)) sqstd_rex_error(exp,_SC("letter expected"));
+	return (*exp->_p++);
+}
+
+static SQInteger sqstd_rex_charclass(SQRex *exp,SQInteger classid)
+{
+	SQInteger n = sqstd_rex_newnode(exp,OP_CCLASS);
+	exp->_nodes[n].left = classid;
+	return n;
+}
+
+static SQInteger sqstd_rex_charnode(SQRex *exp,SQBool isclass)
+{
+	if(*exp->_p == SQREX_SYMBOL_ESCAPE_CHAR) {
+		exp->_p++;
+		switch(*exp->_p) {
+			case 'n': exp->_p++; return sqstd_rex_newnode(exp,'\n');
+			case 't': exp->_p++; return sqstd_rex_newnode(exp,'\t');
+			case 'r': exp->_p++; return sqstd_rex_newnode(exp,'\r');
+			case 'f': exp->_p++; return sqstd_rex_newnode(exp,'\f');
+			case 'v': exp->_p++; return sqstd_rex_newnode(exp,'\v');
+			case 'a': case 'A': case 'w': case 'W': case 's': case 'S': 
+			case 'd': case 'D': case 'x': case 'X': case 'c': case 'C': 
+			case 'p': case 'P': case 'l': case 'u': 
+				{
+				SQChar t = *exp->_p;
+				exp->_p++; 
+				return sqstd_rex_charclass(exp,t);
+				}
+			case 'b': 
+			case 'B':
+				if(!isclass) {
+					SQInteger node = sqstd_rex_newnode(exp,OP_WB);
+					exp->_nodes[node].left = *exp->_p;
+					exp->_p++; 
+					return node;
+				} //else default
+			default: return sqstd_rex_newnode(exp,(*exp->_p++));
+		}
+	}
+	else if(!scisprint(*exp->_p)) {
+		
+		sqstd_rex_error(exp,_SC("letter expected"));
+	}
+	return sqstd_rex_newnode(exp,*exp->_p++);
+}
+static SQInteger sqstd_rex_class(SQRex *exp)
+{
+	SQInteger ret = -1;
+	SQInteger first = -1,chain;
+	if(*exp->_p == SQREX_SYMBOL_BEGINNING_OF_STRING){
+		ret = sqstd_rex_newnode(exp,OP_NCLASS);
+		exp->_p++;
+	}else ret = sqstd_rex_newnode(exp,OP_CLASS);
+	
+	if(*exp->_p == ']') sqstd_rex_error(exp,_SC("empty class"));
+	chain = ret;
+	while(*exp->_p != ']' && exp->_p != exp->_eol) {
+		if(*exp->_p == '-' && first != -1){ 
+			SQInteger r;
+			if(*exp->_p++ == ']') sqstd_rex_error(exp,_SC("unfinished range"));
+			r = sqstd_rex_newnode(exp,OP_RANGE);
+			if(first>*exp->_p) sqstd_rex_error(exp,_SC("invalid range"));
+			if(exp->_nodes[first].type == OP_CCLASS) sqstd_rex_error(exp,_SC("cannot use character classes in ranges"));
+			exp->_nodes[r].left = exp->_nodes[first].type;
+			exp->_nodes[r].right = sqstd_rex_escapechar(exp);
+            exp->_nodes[chain].next = r;
+			chain = r;
+			first = -1;
+		}
+		else{
+			if(first!=-1){
+				SQInteger c = first;
+				exp->_nodes[chain].next = c;
+				chain = c;
+				first = sqstd_rex_charnode(exp,SQTrue);
+			}
+			else{
+				first = sqstd_rex_charnode(exp,SQTrue);
+			}
+		}
+	}
+	if(first!=-1){
+		SQInteger c = first;
+		exp->_nodes[chain].next = c;
+		chain = c;
+		first = -1;
+	}
+	/* hack? */
+	exp->_nodes[ret].left = exp->_nodes[ret].next;
+	exp->_nodes[ret].next = -1;
+	return ret;
+}
+
+static SQInteger sqstd_rex_parsenumber(SQRex *exp)
+{
+	SQInteger ret = *exp->_p-'0';
+	SQInteger positions = 10;
+	exp->_p++;
+	while(isdigit(*exp->_p)) {
+		ret = ret*10+(*exp->_p++-'0');
+		if(positions==1000000000) sqstd_rex_error(exp,_SC("overflow in numeric constant"));
+		positions *= 10;
+	};
+	return ret;
+}
+
+static SQInteger sqstd_rex_element(SQRex *exp)
+{
+	SQInteger ret;
+	switch(*exp->_p)
+	{
+	case '(': {
+		SQInteger expr;
+		exp->_p++;
+		
+		
+		if(*exp->_p =='?') {
+			exp->_p++;
+			sqstd_rex_expect(exp,':');
+			expr = sqstd_rex_newnode(exp,OP_NOCAPEXPR);
+		}
+		else
+			expr = sqstd_rex_newnode(exp,OP_EXPR);
+		exp->_nodes[expr].left = sqstd_rex_list(exp);
+		ret = expr;
+		sqstd_rex_expect(exp,')');
+	}
+		break;
+	case '[':
+		exp->_p++;
+		ret = sqstd_rex_class(exp);
+		sqstd_rex_expect(exp,']');
+		break;
+	case SQREX_SYMBOL_END_OF_STRING: exp->_p++; ret = sqstd_rex_newnode(exp,OP_EOL);break;
+	case SQREX_SYMBOL_ANY_CHAR: exp->_p++; ret = sqstd_rex_newnode(exp,OP_DOT);break;
+	default:
+		ret = sqstd_rex_charnode(exp,SQFalse);
+		break;
+	}
+	/* scope block */
+	{
+		SQInteger op;
+		unsigned short p0 = 0, p1 = 0;
+		switch(*exp->_p){
+		case SQREX_SYMBOL_GREEDY_ZERO_OR_MORE: p0 = 0; p1 = 0xFFFF; exp->_p++; goto __end;
+		case SQREX_SYMBOL_GREEDY_ONE_OR_MORE: p0 = 1; p1 = 0xFFFF; exp->_p++; goto __end;
+		case SQREX_SYMBOL_GREEDY_ZERO_OR_ONE: p0 = 0; p1 = 1; exp->_p++; goto __end;
+		case '{':{
+			exp->_p++;
+			if(!isdigit(*exp->_p)) sqstd_rex_error(exp,_SC("number expected"));
+			p0 = (unsigned short)sqstd_rex_parsenumber(exp);
+			switch(*exp->_p) {
+			case '}':
+				p1 = p0; exp->_p++;
+				goto __end;
+			case ',':
+				exp->_p++;
+				p1 = 0xFFFF;
+				if(isdigit(*exp->_p)){
+					p1 = (unsigned short)sqstd_rex_parsenumber(exp);
+				}
+				sqstd_rex_expect(exp,'}');
+				goto __end;
+			default:
+				sqstd_rex_error(exp,_SC(", or } expected"));
+			}
+		}
+		__end: {
+				SQInteger nnode = sqstd_rex_newnode(exp,OP_GREEDY);
+				op = OP_GREEDY;
+				exp->_nodes[nnode].left = ret;
+				exp->_nodes[nnode].right = ((p0)<<16)|p1;
+				ret = nnode;
+			}
+		}
+	}
+	if(*exp->_p != SQREX_SYMBOL_BRANCH && *exp->_p != ')' && *exp->_p != SQREX_SYMBOL_GREEDY_ZERO_OR_MORE && *exp->_p != SQREX_SYMBOL_GREEDY_ONE_OR_MORE && *exp->_p != '\0')
+		exp->_nodes[ret].next = sqstd_rex_element(exp);
+	return ret;
+}
+
+static SQInteger sqstd_rex_list(SQRex *exp)
+{
+	SQInteger ret=-1,e;
+	if(*exp->_p == SQREX_SYMBOL_BEGINNING_OF_STRING) {
+		exp->_p++;
+		ret = sqstd_rex_newnode(exp,OP_BOL);
+	}
+	e = sqstd_rex_element(exp);
+	if(ret != -1) {
+		exp->_nodes[ret].next = e;
+	}
+	else ret = e;
+
+	if(*exp->_p == SQREX_SYMBOL_BRANCH) {
+		SQInteger temp;
+		exp->_p++;
+		temp = sqstd_rex_newnode(exp,OP_OR);
+		exp->_nodes[temp].left = ret;
+		exp->_nodes[temp].right = sqstd_rex_list(exp);
+		ret = temp;
+	}
+	return ret;
+}
+
+static SQBool sqstd_rex_matchcclass(SQInteger cclass,SQChar c)
+{
+	switch(cclass) {
+	case 'a': return isalpha(c)?SQTrue:SQFalse;
+	case 'A': return !isalpha(c)?SQTrue:SQFalse;
+	case 'w': return (isalnum(c) || c == '_')?SQTrue:SQFalse;
+	case 'W': return (!isalnum(c) && c != '_')?SQTrue:SQFalse;
+	case 's': return isspace(c)?SQTrue:SQFalse;
+	case 'S': return !isspace(c)?SQTrue:SQFalse;
+	case 'd': return isdigit(c)?SQTrue:SQFalse;
+	case 'D': return !isdigit(c)?SQTrue:SQFalse;
+	case 'x': return isxdigit(c)?SQTrue:SQFalse;
+	case 'X': return !isxdigit(c)?SQTrue:SQFalse;
+	case 'c': return iscntrl(c)?SQTrue:SQFalse;
+	case 'C': return !iscntrl(c)?SQTrue:SQFalse;
+	case 'p': return ispunct(c)?SQTrue:SQFalse;
+	case 'P': return !ispunct(c)?SQTrue:SQFalse;
+	case 'l': return islower(c)?SQTrue:SQFalse;
+	case 'u': return isupper(c)?SQTrue:SQFalse;
+	}
+	return SQFalse; /*cannot happen*/
+}
+
+static SQBool sqstd_rex_matchclass(SQRex* exp,SQRexNode *node,SQChar c)
+{
+	do {
+		switch(node->type) {
+			case OP_RANGE:
+				if(c >= node->left && c <= node->right) return SQTrue;
+				break;
+			case OP_CCLASS:
+				if(sqstd_rex_matchcclass(node->left,c)) return SQTrue;
+				break;
+			default:
+				if(c == node->type)return SQTrue;
+		}
+	} while((node->next != -1) && (node = &exp->_nodes[node->next]));
+	return SQFalse;
+}
+
+static const SQChar *sqstd_rex_matchnode(SQRex* exp,SQRexNode *node,const SQChar *str,SQRexNode *next)
+{
+	
+	SQRexNodeType type = node->type;
+	switch(type) {
+	case OP_GREEDY: {
+		//SQRexNode *greedystop = (node->next != -1) ? &exp->_nodes[node->next] : NULL;
+		SQRexNode *greedystop = NULL;
+		SQInteger p0 = (node->right >> 16)&0x0000FFFF, p1 = node->right&0x0000FFFF, nmaches = 0;
+		const SQChar *s=str, *good = str;
+
+		if(node->next != -1) {
+			greedystop = &exp->_nodes[node->next];
+		}
+		else {
+			greedystop = next;
+		}
+
+		while((nmaches == 0xFFFF || nmaches < p1)) {
+
+			const SQChar *stop;
+			if(!(s = sqstd_rex_matchnode(exp,&exp->_nodes[node->left],s,greedystop)))
+				break;
+			nmaches++;
+			good=s;
+			if(greedystop) {
+				//checks that 0 matches satisfy the expression(if so skips)
+				//if not would always stop(for instance if is a '?')
+				if(greedystop->type != OP_GREEDY ||
+				(greedystop->type == OP_GREEDY && ((greedystop->right >> 16)&0x0000FFFF) != 0))
+				{
+					SQRexNode *gnext = NULL;
+					if(greedystop->next != -1) {
+						gnext = &exp->_nodes[greedystop->next];
+					}else if(next && next->next != -1){
+						gnext = &exp->_nodes[next->next];
+					}
+					stop = sqstd_rex_matchnode(exp,greedystop,s,gnext);
+					if(stop) {
+						//if satisfied stop it
+						if(p0 == p1 && p0 == nmaches) break;
+						else if(nmaches >= p0 && p1 == 0xFFFF) break;
+						else if(nmaches >= p0 && nmaches <= p1) break;
+					}
+				}
+			}
+			
+			if(s >= exp->_eol)
+				break;
+		}
+		if(p0 == p1 && p0 == nmaches) return good;
+		else if(nmaches >= p0 && p1 == 0xFFFF) return good;
+		else if(nmaches >= p0 && nmaches <= p1) return good;
+		return NULL;
+	}
+	case OP_OR: {
+			const SQChar *asd = str;
+			SQRexNode *temp=&exp->_nodes[node->left];
+			while( (asd = sqstd_rex_matchnode(exp,temp,asd,NULL)) ) {
+				if(temp->next != -1)
+					temp = &exp->_nodes[temp->next];
+				else
+					return asd;
+			}
+			asd = str;
+			temp = &exp->_nodes[node->right];
+			while( (asd = sqstd_rex_matchnode(exp,temp,asd,NULL)) ) {
+				if(temp->next != -1)
+					temp = &exp->_nodes[temp->next];
+				else
+					return asd;
+			}
+			return NULL;
+			break;
+	}
+	case OP_EXPR:
+	case OP_NOCAPEXPR:{
+			SQRexNode *n = &exp->_nodes[node->left];
+			const SQChar *cur = str;
+			SQInteger capture = -1;
+			if(node->type != OP_NOCAPEXPR && node->right == exp->_currsubexp) {
+				capture = exp->_currsubexp;
+				exp->_matches[capture].begin = cur;
+				exp->_currsubexp++;
+			}
+			
+			do {
+				SQRexNode *subnext = NULL;
+				if(n->next != -1) {
+					subnext = &exp->_nodes[n->next];
+				}else {
+					subnext = next;
+				}
+				if(!(cur = sqstd_rex_matchnode(exp,n,cur,subnext))) {
+					if(capture != -1){
+						exp->_matches[capture].begin = 0;
+						exp->_matches[capture].len = 0;
+					}
+					return NULL;
+				}
+			} while((n->next != -1) && (n = &exp->_nodes[n->next]));
+
+			if(capture != -1) 
+				exp->_matches[capture].len = cur - exp->_matches[capture].begin;
+			return cur;
+	}				 
+	case OP_WB:
+		if(str == exp->_bol && !isspace(*str)
+		 || (str == exp->_eol && !isspace(*(str-1)))
+		 || (!isspace(*str) && isspace(*(str+1)))
+		 || (isspace(*str) && !isspace(*(str+1))) ) {
+			return (node->left == 'b')?str:NULL;
+		}
+		return (node->left == 'b')?NULL:str;
+	case OP_BOL:
+		if(str == exp->_bol) return str;
+		return NULL;
+	case OP_EOL:
+		if(str == exp->_eol) return str;
+		return NULL;
+	case OP_DOT:{
+		*str++;
+				}
+		return str;
+	case OP_NCLASS:
+	case OP_CLASS:
+		if(sqstd_rex_matchclass(exp,&exp->_nodes[node->left],*str)?(type == OP_CLASS?SQTrue:SQFalse):(type == OP_NCLASS?SQTrue:SQFalse)) {
+			*str++;
+			return str;
+		}
+		return NULL;
+	case OP_CCLASS:
+		if(sqstd_rex_matchcclass(node->left,*str)) {
+			*str++;
+			return str;
+		}
+		return NULL;
+	default: /* char */
+		if(*str != node->type) return NULL;
+		*str++;
+		return str;
+	}
+	return NULL;
+}
+
+/* public api */
+SQRex *sqstd_rex_compile(const SQChar *pattern,const SQChar **error)
+{
+	SQRex *exp = (SQRex *)sq_malloc(sizeof(SQRex));
+	exp->_eol = exp->_bol = NULL;
+	exp->_p = pattern;
+	exp->_nallocated = (SQInteger)scstrlen(pattern) * sizeof(SQChar);
+	exp->_nodes = (SQRexNode *)sq_malloc(exp->_nallocated * sizeof(SQRexNode));
+	exp->_nsize = 0;
+	exp->_matches = 0;
+	exp->_nsubexpr = 0;
+	exp->_first = sqstd_rex_newnode(exp,OP_EXPR);
+	exp->_error = error;
+	exp->_jmpbuf = sq_malloc(sizeof(jmp_buf));
+	if(setjmp(*((jmp_buf*)exp->_jmpbuf)) == 0) {
+		exp->_nodes[exp->_first].left=sqstd_rex_list(exp);
+		if(*exp->_p!='\0')
+			sqstd_rex_error(exp,_SC("unexpected character"));
+#ifdef _DEBUG
+		{
+			SQInteger nsize,i;
+			SQRexNode *t;
+			nsize = exp->_nsize;
+			t = &exp->_nodes[0];
+			scprintf(_SC("\n"));
+			for(i = 0;i < nsize; i++) {
+				if(exp->_nodes[i].type>MAX_CHAR)
+					scprintf(_SC("[%02d] %10s "),i,g_nnames[exp->_nodes[i].type-MAX_CHAR]);
+				else
+					scprintf(_SC("[%02d] %10c "),i,exp->_nodes[i].type);
+				scprintf(_SC("left %02d right %02d next %02d\n"),exp->_nodes[i].left,exp->_nodes[i].right,exp->_nodes[i].next);
+			}
+			scprintf(_SC("\n"));
+		}
+#endif
+		exp->_matches = (SQRexMatch *) sq_malloc(exp->_nsubexpr * sizeof(SQRexMatch));
+		memset(exp->_matches,0,exp->_nsubexpr * sizeof(SQRexMatch));
+	}
+	else{
+		sqstd_rex_free(exp);
+		return NULL;
+	}
+	return exp;
+}
+
+void sqstd_rex_free(SQRex *exp)
+{
+	if(exp)	{
+		if(exp->_nodes) sq_free(exp->_nodes,exp->_nallocated * sizeof(SQRexNode));
+		if(exp->_jmpbuf) sq_free(exp->_jmpbuf,sizeof(jmp_buf));
+		if(exp->_matches) sq_free(exp->_matches,exp->_nsubexpr * sizeof(SQRexMatch));
+		sq_free(exp,sizeof(SQRex));
+	}
+}
+
+SQBool sqstd_rex_match(SQRex* exp,const SQChar* text)
+{
+	const SQChar* res = NULL;
+	exp->_bol = text;
+	exp->_eol = text + scstrlen(text);
+	exp->_currsubexp = 0;
+	res = sqstd_rex_matchnode(exp,exp->_nodes,text,NULL);
+	if(res == NULL || res != exp->_eol)
+		return SQFalse;
+	return SQTrue;
+}
+
+SQBool sqstd_rex_searchrange(SQRex* exp,const SQChar* text_begin,const SQChar* text_end,const SQChar** out_begin, const SQChar** out_end)
+{
+	const SQChar *cur = NULL;
+	SQInteger node = exp->_first;
+	if(text_begin >= text_end) return SQFalse;
+	exp->_bol = text_begin;
+	exp->_eol = text_end;
+	do {
+		cur = text_begin;
+		while(node != -1) {
+			exp->_currsubexp = 0;
+			cur = sqstd_rex_matchnode(exp,&exp->_nodes[node],cur,NULL);
+			if(!cur)
+				break;
+			node = exp->_nodes[node].next;
+		}
+		*text_begin++;
+	} while(cur == NULL && text_begin != text_end);
+
+	if(cur == NULL)
+		return SQFalse;
+
+	--text_begin;
+
+	if(out_begin) *out_begin = text_begin;
+	if(out_end) *out_end = cur;
+	return SQTrue;
+}
+
+SQBool sqstd_rex_search(SQRex* exp,const SQChar* text, const SQChar** out_begin, const SQChar** out_end)
+{
+	return sqstd_rex_searchrange(exp,text,text + scstrlen(text),out_begin,out_end);
+}
+
+SQInteger sqstd_rex_getsubexpcount(SQRex* exp)
+{
+	return exp->_nsubexpr;
+}
+
+SQBool sqstd_rex_getsubexp(SQRex* exp, SQInteger n, SQRexMatch *subexp)
+{
+	if( n<0 || n >= exp->_nsubexpr) return SQFalse;
+	*subexp = exp->_matches[n];
+	return SQTrue;
+}
+
diff -rupwN ../dnl3/SqPlus/_sqstdlib/sqstdstream.cpp SqPlus/_sqstdlib/sqstdstream.cpp
--- ../dnl3/SqPlus/_sqstdlib/sqstdstream.cpp	1969-12-31 19:00:00.000000000 -0500
+++ SqPlus/_sqstdlib/sqstdstream.cpp	2006-03-19 14:32:58.000000000 -0500
@@ -0,0 +1,330 @@
+/* see copyright notice in squirrel.h */
+#include <new>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <squirrel.h>
+#include <sqstdio.h>
+#include <sqstdblob.h>
+#include "sqstdstream.h"
+#include "sqstdblobimpl.h"
+
+#define SETUP_STREAM(v) \
+	SQStream *self = NULL; \
+	if(SQ_FAILED(sq_getinstanceup(v,1,(SQUserPointer*)&self,(SQUserPointer)SQSTD_STREAM_TYPE_TAG))) \
+		return sq_throwerror(v,_SC("invalid type tag")); \
+	if(!self->IsValid())  \
+		return sq_throwerror(v,_SC("the stream is invalid"));
+
+SQInteger _stream_readblob(HSQUIRRELVM v)
+{
+	SETUP_STREAM(v);
+	SQUserPointer data,blobp;
+	SQInteger size,res;
+	sq_getinteger(v,2,&size);
+	if(size > self->Len()) {
+		size = self->Len();
+	}
+	data = sq_getscratchpad(v,size);
+	res = self->Read(data,size);
+	if(res <= 0)
+		return sq_throwerror(v,_SC("no data left to read"));
+	blobp = sqstd_createblob(v,res);
+	memcpy(blobp,data,res);
+	return 1;
+}
+
+#define SAFE_READN(ptr,len) { \
+	if(self->Read(ptr,len) != len) return sq_throwerror(v,_SC("io error")); \
+	}
+SQInteger _stream_readn(HSQUIRRELVM v)
+{
+	SETUP_STREAM(v);
+	SQInteger format;
+	sq_getinteger(v, 2, &format);
+	switch(format) {
+	case 'l': {
+		SQInteger i;
+		SAFE_READN(&i, sizeof(i));
+		sq_pushinteger(v, i);
+			  }
+		break;
+	case 'i': {
+		SQInt32 i;
+		SAFE_READN(&i, sizeof(i));
+		sq_pushinteger(v, i);
+			  }
+		break;
+	case 's': {
+		short s;
+		SAFE_READN(&s, sizeof(short));
+		sq_pushinteger(v, s);
+			  }
+		break;
+	case 'w': {
+		unsigned short w;
+		SAFE_READN(&w, sizeof(unsigned short));
+		sq_pushinteger(v, w);
+			  }
+		break;
+	case 'c': {
+		char c;
+		SAFE_READN(&c, sizeof(char));
+		sq_pushinteger(v, c);
+			  }
+		break;
+	case 'b': {
+		unsigned char c;
+		SAFE_READN(&c, sizeof(unsigned char));
+		sq_pushinteger(v, c);
+			  }
+		break;
+	case 'f': {
+		float f;
+		SAFE_READN(&f, sizeof(float));
+		sq_pushfloat(v, f);
+			  }
+		break;
+	case 'd': {
+		double d;
+		SAFE_READN(&d, sizeof(double));
+		sq_pushfloat(v, (SQFloat)d);
+			  }
+		break;
+	default:
+		return sq_throwerror(v, _SC("invalid format"));
+	}
+	return 1;
+}
+
+SQInteger _stream_writeblob(HSQUIRRELVM v)
+{
+	SQUserPointer data;
+	SQInteger size;
+	SETUP_STREAM(v);
+	if(SQ_FAILED(sqstd_getblob(v,2,&data)))
+		return sq_throwerror(v,_SC("invalid parameter"));
+	size = sqstd_getblobsize(v,2);
+	if(self->Write(data,size) != size)
+		return sq_throwerror(v,_SC("io error"));
+	sq_pushinteger(v,size);
+	return 1;
+}
+
+SQInteger _stream_writen(HSQUIRRELVM v)
+{
+	SETUP_STREAM(v);
+	SQInteger format, ti;
+	SQFloat tf;
+	sq_getinteger(v, 3, &format);
+	switch(format) {
+	case 'l': {
+		SQInteger i;
+		sq_getinteger(v, 2, &ti);
+		i = ti;
+		self->Write(&i, sizeof(SQInteger));
+			  }
+		break;
+	case 'i': {
+		SQInt32 i;
+		sq_getinteger(v, 2, &ti);
+		i = (SQInt32)ti;
+		self->Write(&i, sizeof(SQInt32));
+			  }
+		break;
+	case 's': {
+		short s;
+		sq_getinteger(v, 2, &ti);
+		s = (short)ti;
+		self->Write(&s, sizeof(short));
+			  }
+		break;
+	case 'w': {
+		unsigned short w;
+		sq_getinteger(v, 2, &ti);
+		w = (unsigned short)ti;
+		self->Write(&w, sizeof(unsigned short));
+			  }
+		break;
+	case 'c': {
+		char c;
+		sq_getinteger(v, 2, &ti);
+		c = (char)ti;
+		self->Write(&c, sizeof(char));
+				  }
+		break;
+	case 'b': {
+		unsigned char b;
+		sq_getinteger(v, 2, &ti);
+		b = (unsigned char)ti;
+		self->Write(&b, sizeof(unsigned char));
+			  }
+		break;
+	case 'f': {
+		float f;
+		sq_getfloat(v, 2, &tf);
+		f = tf;
+		self->Write(&f, sizeof(float));
+			  }
+		break;
+	case 'd': {
+		double d;
+		sq_getfloat(v, 2, &tf);
+		d = tf;
+		self->Write(&d, sizeof(double));
+			  }
+		break;
+	default:
+		return sq_throwerror(v, _SC("invalid format"));
+	}
+	return 0;
+}
+
+SQInteger _stream_seek(HSQUIRRELVM v)
+{
+	SETUP_STREAM(v);
+	SQInteger offset, origin = SQ_SEEK_SET;
+	sq_getinteger(v, 2, &offset);
+	if(sq_gettop(v) > 2) {
+		SQInteger t;
+		sq_getinteger(v, 3, &t);
+		switch(t) {
+			case 'b': origin = SQ_SEEK_SET; break;
+			case 'c': origin = SQ_SEEK_CUR; break;
+			case 'e': origin = SQ_SEEK_END; break;
+			default: return sq_throwerror(v,_SC("invalid origin"));
+		}
+	}
+	sq_pushinteger(v, self->Seek(offset, origin));
+	return 1;
+}
+
+SQInteger _stream_tell(HSQUIRRELVM v)
+{
+	SETUP_STREAM(v);
+	sq_pushinteger(v, self->Tell());
+	return 1;
+}
+
+SQInteger _stream_len(HSQUIRRELVM v)
+{
+	SETUP_STREAM(v);
+	sq_pushinteger(v, self->Len());
+	return 1;
+}
+
+SQInteger _stream_flush(HSQUIRRELVM v)
+{
+	SETUP_STREAM(v);
+	if(!self->Flush())
+		sq_pushinteger(v, 1);
+	else
+		sq_pushnull(v);
+	return 1;
+}
+
+SQInteger _stream_eos(HSQUIRRELVM v)
+{
+	SETUP_STREAM(v);
+	if(self->EOS())
+		sq_pushinteger(v, 1);
+	else
+		sq_pushnull(v);
+	return 1;
+}
+
+static SQRegFunction _stream_methods[] = {
+	_DECL_STREAM_FUNC(readblob,2,_SC("xn")),
+	_DECL_STREAM_FUNC(readn,2,_SC("xn")),
+	_DECL_STREAM_FUNC(writeblob,-2,_SC("xx")),
+	_DECL_STREAM_FUNC(writen,3,_SC("xnn")),
+	_DECL_STREAM_FUNC(seek,-2,_SC("xnn")),
+	_DECL_STREAM_FUNC(tell,1,_SC("x")),
+	_DECL_STREAM_FUNC(len,1,_SC("x")),
+	_DECL_STREAM_FUNC(eos,1,_SC("x")),
+	_DECL_STREAM_FUNC(flush,1,_SC("x")),
+	{0,0}
+};
+
+void init_streamclass(HSQUIRRELVM v)
+{
+	sq_pushregistrytable(v);
+	sq_pushstring(v,_SC("std_stream"),-1);
+	if(SQ_FAILED(sq_get(v,-2))) {
+		sq_pushstring(v,_SC("std_stream"),-1);
+		sq_newclass(v,SQFalse);
+		sq_settypetag(v,-1,(SQUserPointer)SQSTD_STREAM_TYPE_TAG);
+		SQInteger i = 0;
+		while(_stream_methods[i].name != 0) {
+			SQRegFunction &f = _stream_methods[i];
+			sq_pushstring(v,f.name,-1);
+			sq_newclosure(v,f.f,0);
+			sq_setparamscheck(v,f.nparamscheck,f.typemask);
+			sq_createslot(v,-3);
+			i++;
+		}
+		sq_createslot(v,-3);
+		sq_pushroottable(v);
+		sq_pushstring(v,_SC("stream"),-1);
+		sq_pushstring(v,_SC("std_stream"),-1);
+		sq_get(v,-4);
+		sq_createslot(v,-3);
+		sq_pop(v,1);
+	}
+	else {
+		sq_pop(v,1); //result
+	}
+	sq_pop(v,1);
+}
+
+SQRESULT declare_stream(HSQUIRRELVM v,SQChar* name,SQUserPointer typetag,SQChar* reg_name,SQRegFunction *methods,SQRegFunction *globals)
+{
+	if(sq_gettype(v,-1) != OT_TABLE)
+		return sq_throwerror(v,_SC("table expected"));
+	SQInteger top = sq_gettop(v);
+	//create delegate
+    init_streamclass(v);
+	sq_pushregistrytable(v);
+	sq_pushstring(v,reg_name,-1);
+	sq_pushstring(v,_SC("std_stream"),-1);
+	if(SQ_SUCCEEDED(sq_get(v,-3))) {
+		sq_newclass(v,SQTrue);
+		sq_settypetag(v,-1,typetag);
+		SQInteger i = 0;
+		while(methods[i].name != 0) {
+			SQRegFunction &f = methods[i];
+			sq_pushstring(v,f.name,-1);
+			sq_newclosure(v,f.f,0);
+			sq_setparamscheck(v,f.nparamscheck,f.typemask);
+			sq_setnativeclosurename(v,-1,f.name);
+			sq_createslot(v,-3);
+			i++;
+		}
+		sq_createslot(v,-3);
+		sq_pop(v,1);
+		
+		i = 0;
+		while(globals[i].name!=0)
+		{
+			SQRegFunction &f = globals[i];
+			sq_pushstring(v,f.name,-1);
+			sq_newclosure(v,f.f,0);
+			sq_setparamscheck(v,f.nparamscheck,f.typemask);
+			sq_setnativeclosurename(v,-1,f.name);
+			sq_createslot(v,-3);
+			i++;
+		}
+		//register the class in the target table
+		sq_pushstring(v,name,-1);
+		sq_pushregistrytable(v);
+		sq_pushstring(v,reg_name,-1);
+		sq_get(v,-2);
+		sq_remove(v,-2);
+		sq_createslot(v,-3);
+
+		sq_settop(v,top);
+		return SQ_OK;
+	}
+	sq_settop(v,top);
+	return SQ_ERROR;
+}
diff -rupwN ../dnl3/SqPlus/_sqstdlib/sqstdstream.h SqPlus/_sqstdlib/sqstdstream.h
--- ../dnl3/SqPlus/_sqstdlib/sqstdstream.h	1969-12-31 19:00:00.000000000 -0500
+++ SqPlus/_sqstdlib/sqstdstream.h	2006-03-19 14:32:58.000000000 -0500
@@ -0,0 +1,18 @@
+/*	see copyright notice in squirrel.h */
+#ifndef _SQSTD_STREAM_H_
+#define _SQSTD_STREAM_H_
+
+SQInteger _stream_readblob(HSQUIRRELVM v);
+SQInteger _stream_readline(HSQUIRRELVM v);
+SQInteger _stream_readn(HSQUIRRELVM v);
+SQInteger _stream_writeblob(HSQUIRRELVM v);
+SQInteger _stream_writen(HSQUIRRELVM v);
+SQInteger _stream_seek(HSQUIRRELVM v);
+SQInteger _stream_tell(HSQUIRRELVM v);
+SQInteger _stream_len(HSQUIRRELVM v);
+SQInteger _stream_eos(HSQUIRRELVM v);
+SQInteger _stream_flush(HSQUIRRELVM v);
+
+#define _DECL_STREAM_FUNC(name,nparams,typecheck) {_SC(#name),_stream_##name,nparams,typecheck}
+SQRESULT declare_stream(HSQUIRRELVM v,SQChar* name,SQUserPointer typetag,SQChar* reg_name,SQRegFunction *methods,SQRegFunction *globals);
+#endif /*_SQSTD_STREAM_H_*/
diff -rupwN ../dnl3/SqPlus/_sqstdlib/sqstdstring.cpp SqPlus/_sqstdlib/sqstdstring.cpp
--- ../dnl3/SqPlus/_sqstdlib/sqstdstring.cpp	1969-12-31 19:00:00.000000000 -0500
+++ SqPlus/_sqstdlib/sqstdstring.cpp	2006-03-19 14:32:58.000000000 -0500
@@ -0,0 +1,350 @@
+/* see copyright notice in squirrel.h */
+#include <squirrel.h>
+#include <sqstdstring.h>
+#include <string.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <ctype.h>
+#include <assert.h>
+
+#ifdef _UNICODE
+#define scstrchr wcschr
+#define scsnprintf wsnprintf
+#define scatoi _wtoi
+#define scstrtok wcstok
+#else
+#define scstrchr strchr
+#define scsnprintf snprintf
+#define scatoi atoi
+#define scstrtok strtok
+#endif
+#define MAX_FORMAT_LEN	20
+#define MAX_WFORMAT_LEN	3
+#define ADDITIONAL_FORMAT_SPACE (100*sizeof(SQChar))
+
+static SQInteger validate_format(HSQUIRRELVM v, SQChar *fmt, const SQChar *src, SQInteger n,SQInteger &width)
+{
+	SQChar swidth[MAX_WFORMAT_LEN];
+	SQInteger wc = 0;
+	SQInteger start = n;
+	fmt[0] = '%';
+	while (scstrchr(_SC("-+ #0"), src[n])) n++;
+	while (scisdigit(src[n])) {
+		swidth[wc] = src[n];
+		n++;
+		wc++;
+		if(wc>=MAX_WFORMAT_LEN)
+			return sq_throwerror(v,_SC("width format too long"));
+	}
+	swidth[wc] = '\0';
+	if(wc > 0) {
+		width = scatoi(swidth);
+	}
+	else
+		width = 0;
+	if (src[n] == '.') {
+	    n++;
+    	
+		wc = 0;
+		while (scisdigit(src[n])) {
+			swidth[wc] = src[n];
+			n++;
+			wc++;
+			if(wc>=MAX_WFORMAT_LEN)
+				return sq_throwerror(v,_SC("precision format too long"));
+		}
+		swidth[wc] = '\0';
+		if(wc > 0) {
+			width += scatoi(swidth);
+		}
+	}
+	if (n-start > MAX_FORMAT_LEN )
+		return sq_throwerror(v,_SC("format too long"));
+	memcpy(&fmt[1],&src[start],((n-start)+1)*sizeof(SQChar));
+	fmt[(n-start)+2] = '\0';
+	return n;
+}
+
+static SQInteger _string_format(HSQUIRRELVM v)
+{
+	const SQChar *format;
+	SQChar *dest;
+	SQChar fmt[MAX_FORMAT_LEN];
+	sq_getstring(v,2,&format);
+	SQInteger allocated = (sq_getsize(v,2)+1)*sizeof(SQChar);
+	dest = sq_getscratchpad(v,allocated);
+	SQInteger n = 0,i = 0, nparam = 3, w = 0;
+	while(format[n] != '\0') {
+		if(format[n] != '%') {
+			assert(i < allocated);
+			dest[i++] = format[n];
+			n++;
+		}
+		else if(format[n+1] == '%') { //handles %%
+				dest[i++] = '%';
+				n += 2; 
+		}
+		else {
+			n++;
+			if( nparam > sq_gettop(v) )
+				return sq_throwerror(v,_SC("not enough paramters for the given format string"));
+			n = validate_format(v,fmt,format,n,w);
+			if(n < 0) return -1;
+			SQInteger addlen = 0;
+			SQInteger valtype = 0;
+			const SQChar *ts;
+			SQInteger ti;
+			SQFloat tf;
+			switch(format[n]) {
+			case 's':
+				if(SQ_FAILED(sq_getstring(v,nparam,&ts))) 
+					return sq_throwerror(v,_SC("string expected for the specified format"));
+				addlen = (sq_getsize(v,nparam)*sizeof(SQChar))+((w+1)*sizeof(SQChar));
+				valtype = 's';
+				break;
+			case 'i': case 'd': case 'c':case 'o':  case 'u':  case 'x':  case 'X':
+				if(SQ_FAILED(sq_getinteger(v,nparam,&ti))) 
+					return sq_throwerror(v,_SC("integer expected for the specified format"));
+				addlen = (ADDITIONAL_FORMAT_SPACE)+((w+1)*sizeof(SQChar));
+				valtype = 'i';
+				break;
+			case 'f': case 'g': case 'G': case 'e':  case 'E':
+				if(SQ_FAILED(sq_getfloat(v,nparam,&tf))) 
+					return sq_throwerror(v,_SC("float expected for the specified format"));
+				addlen = (ADDITIONAL_FORMAT_SPACE)+((w+1)*sizeof(SQChar));
+				valtype = 'f';
+				break;
+			default:
+				return sq_throwerror(v,_SC("invalid format"));
+			}
+			n++;
+			allocated += addlen;
+			dest = sq_getscratchpad(v,allocated);
+			switch(valtype) {
+			case 's': i += scsprintf(&dest[i],fmt,ts); break;
+			case 'i': i += scsprintf(&dest[i],fmt,ti); break;
+			case 'f': i += scsprintf(&dest[i],fmt,tf); break;
+			};
+			nparam ++;
+		}
+	}
+	sq_pushstring(v,dest,i);
+	return 1;
+}
+
+static void __strip_l(const SQChar *str,const SQChar **start)
+{
+	const SQChar *t = str;
+	while(((*t) != '\0') && scisspace(*t)){ t++; }
+	*start = t;
+}
+
+static void __strip_r(const SQChar *str,SQInteger len,const SQChar **end)
+{
+	if(len == 0) {
+		*end = str;
+		return;
+	}
+	const SQChar *t = &str[len-1];
+	while(t != str && scisspace(*t)) { t--; }
+	*end = t+1;
+}
+
+static SQInteger _string_strip(HSQUIRRELVM v)
+{
+	const SQChar *str,*start,*end;
+	sq_getstring(v,2,&str);
+	SQInteger len = sq_getsize(v,2);
+	__strip_l(str,&start);
+	__strip_r(str,len,&end);
+	sq_pushstring(v,start,end - start);
+	return 1;
+}
+
+static SQInteger _string_lstrip(HSQUIRRELVM v)
+{
+	const SQChar *str,*start;
+	sq_getstring(v,2,&str);
+	__strip_l(str,&start);
+	sq_pushstring(v,start,-1);
+	return 1;
+}
+
+static SQInteger _string_rstrip(HSQUIRRELVM v)
+{
+	const SQChar *str,*end;
+	sq_getstring(v,2,&str);
+	SQInteger len = sq_getsize(v,2);
+	__strip_r(str,len,&end);
+	sq_pushstring(v,str,end - str);
+	return 1;
+}
+
+static SQInteger _string_split(HSQUIRRELVM v)
+{
+	const SQChar *str,*seps;
+	SQChar *stemp,*tok;
+	sq_getstring(v,2,&str);
+	sq_getstring(v,3,&seps);
+	if(sq_getsize(v,3) == 0) return sq_throwerror(v,_SC("empty separators string"));
+	SQInteger memsize = (sq_getsize(v,2)+1)*sizeof(SQChar);
+	stemp = sq_getscratchpad(v,memsize);
+	memcpy(stemp,str,memsize);
+	tok = scstrtok(stemp,seps);
+	sq_newarray(v,0);
+	while( tok != NULL ) {
+		sq_pushstring(v,tok,-1);
+		sq_arrayappend(v,-2);
+		tok = scstrtok( NULL, seps );
+	}
+	return 1;
+}
+
+#define SETUP_REX(v) \
+	SQRex *self = NULL; \
+	sq_getinstanceup(v,1,(SQUserPointer *)&self,0); 
+
+static SQInteger _rexobj_releasehook(SQUserPointer p, SQInteger size)
+{
+	SQRex *self = ((SQRex *)p);
+	sqstd_rex_free(self);
+	return 1;
+}
+
+static SQInteger _regexp_match(HSQUIRRELVM v)
+{
+	SETUP_REX(v);
+	const SQChar *str;
+	sq_getstring(v,2,&str);
+	if(sqstd_rex_match(self,str) == SQTrue)
+	{
+		sq_pushbool(v,SQTrue);
+		return 1;
+	}
+	sq_pushbool(v,SQFalse);
+	return 1;
+}
+
+static void _addrexmatch(HSQUIRRELVM v,const SQChar *str,const SQChar *begin,const SQChar *end)
+{
+	sq_newtable(v);
+	sq_pushstring(v,_SC("begin"),-1);
+	sq_pushinteger(v,begin - str);
+	sq_rawset(v,-3);
+	sq_pushstring(v,_SC("end"),-1);
+	sq_pushinteger(v,end - str);
+	sq_rawset(v,-3);
+}
+
+static SQInteger _regexp_search(HSQUIRRELVM v)
+{
+	SETUP_REX(v);
+	const SQChar *str,*begin,*end;
+	SQInteger start = 0;
+	sq_getstring(v,2,&str);
+	if(sq_gettop(v) > 2) sq_getinteger(v,3,&start);
+	if(sqstd_rex_search(self,str+start,&begin,&end) == SQTrue) {
+		_addrexmatch(v,str,begin,end);
+		return 1;
+	}
+	return 0;
+}
+
+static SQInteger _regexp_capture(HSQUIRRELVM v)
+{
+	SETUP_REX(v);
+	const SQChar *str,*begin,*end;
+	SQInteger start = 0;
+	sq_getstring(v,2,&str);
+	if(sq_gettop(v) > 2) sq_getinteger(v,3,&start);
+	if(sqstd_rex_search(self,str+start,&begin,&end) == SQTrue) {
+		SQInteger n = sqstd_rex_getsubexpcount(self);
+		SQRexMatch match;
+		sq_newarray(v,0);
+		for(SQInteger i = 0;i < n; i++) {
+			sqstd_rex_getsubexp(self,i,&match);
+			if(match.len > 0)
+				_addrexmatch(v,str,match.begin,match.begin+match.len);
+			else
+				_addrexmatch(v,str,str,str); //empty match
+			sq_arrayappend(v,-2);
+		}
+		return 1;
+	}
+	return 0;
+}
+
+static SQInteger _regexp_subexpcount(HSQUIRRELVM v)
+{
+	SETUP_REX(v);
+	sq_pushinteger(v,sqstd_rex_getsubexpcount(self));
+	return 1;
+}
+
+static SQInteger _regexp_constructor(HSQUIRRELVM v)
+{
+	const SQChar *error,*pattern;
+	sq_getstring(v,2,&pattern);
+	SQRex *rex = sqstd_rex_compile(pattern,&error);
+	if(!rex) return sq_throwerror(v,error);
+	sq_setinstanceup(v,1,rex);
+	sq_setreleasehook(v,1,_rexobj_releasehook);
+	return 0;
+}
+
+static SQInteger _regexp__typeof(HSQUIRRELVM v)
+{
+	sq_pushstring(v,_SC("regexp"),-1);
+	return 1;
+}
+
+#define _DECL_REX_FUNC(name,nparams,pmask) {_SC(#name),_regexp_##name,nparams,pmask}
+static SQRegFunction rexobj_funcs[]={
+	_DECL_REX_FUNC(constructor,2,_SC(".s")),
+	_DECL_REX_FUNC(search,-2,_SC("xsn")),
+	_DECL_REX_FUNC(match,2,_SC("xs")),
+	_DECL_REX_FUNC(capture,-2,_SC("xsn")),
+	_DECL_REX_FUNC(subexpcount,1,_SC("x")),
+	_DECL_REX_FUNC(_typeof,1,_SC("x")),
+	{0,0}
+};
+
+#define _DECL_FUNC(name,nparams,pmask) {_SC(#name),_string_##name,nparams,pmask}
+static SQRegFunction stringlib_funcs[]={
+	_DECL_FUNC(format,-2,_SC(".s")),
+	_DECL_FUNC(strip,2,_SC(".s")),
+	_DECL_FUNC(lstrip,2,_SC(".s")),
+	_DECL_FUNC(rstrip,2,_SC(".s")),
+	_DECL_FUNC(split,3,_SC(".ss")),
+	{0,0}
+};
+
+
+SQInteger sqstd_register_stringlib(HSQUIRRELVM v)
+{
+	sq_pushstring(v,_SC("regexp"),-1);
+	sq_newclass(v,SQFalse);
+	SQInteger i = 0;
+	while(rexobj_funcs[i].name != 0) {
+		SQRegFunction &f = rexobj_funcs[i];
+		sq_pushstring(v,f.name,-1);
+		sq_newclosure(v,f.f,0);
+		sq_setparamscheck(v,f.nparamscheck,f.typemask);
+		sq_setnativeclosurename(v,-1,f.name);
+		sq_createslot(v,-3);
+		i++;
+	}
+	sq_createslot(v,-3);
+
+	i = 0;
+	while(stringlib_funcs[i].name!=0)
+	{
+		sq_pushstring(v,stringlib_funcs[i].name,-1);
+		sq_newclosure(v,stringlib_funcs[i].f,0);
+		sq_setparamscheck(v,stringlib_funcs[i].nparamscheck,stringlib_funcs[i].typemask);
+		sq_setnativeclosurename(v,-1,stringlib_funcs[i].name);
+		sq_createslot(v,-3);
+		i++;
+	}
+	return 1;
+}
diff -rupwN ../dnl3/SqPlus/_sqstdlib/sqstdsystem.cpp SqPlus/_sqstdlib/sqstdsystem.cpp
--- ../dnl3/SqPlus/_sqstdlib/sqstdsystem.cpp	1969-12-31 19:00:00.000000000 -0500
+++ SqPlus/_sqstdlib/sqstdsystem.cpp	2006-03-19 14:32:58.000000000 -0500
@@ -0,0 +1,147 @@
+/* see copyright notice in squirrel.h */
+#include <squirrel.h>
+#include <time.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <sqstdsystem.h>
+
+#ifdef SQUNICODE
+#include <wchar.h>
+#define scgetenv _wgetenv
+#define scsystem _wsystem
+#define scasctime _wasctime
+#define scremove _wremove
+#define screname _wrename
+#else
+#define scgetenv getenv
+#define scsystem system
+#define scasctime asctime
+#define scremove remove
+#define screname rename
+#endif
+
+static SQInteger _system_getenv(HSQUIRRELVM v)
+{
+	const SQChar *s;
+	if(SQ_SUCCEEDED(sq_getstring(v,2,&s))){
+        sq_pushstring(v,scgetenv(s),-1);
+		return 1;
+	}
+	return 0;
+}
+
+
+static SQInteger _system_system(HSQUIRRELVM v)
+{
+	const SQChar *s;
+	if(SQ_SUCCEEDED(sq_getstring(v,2,&s))){
+		sq_pushinteger(v,scsystem(s));
+		return 1;
+	}
+	return sq_throwerror(v,_SC("wrong param"));
+}
+
+
+static SQInteger _system_clock(HSQUIRRELVM v)
+{
+	sq_pushfloat(v,((SQFloat)clock())/(SQFloat)CLOCKS_PER_SEC);
+	return 1;
+}
+
+static SQInteger _system_time(HSQUIRRELVM v)
+{
+	time_t t;
+	time(&t);
+	sq_pushinteger(v,*((SQInteger *)&t));
+	return 1;
+}
+
+static SQInteger _system_remove(HSQUIRRELVM v)
+{
+	const SQChar *s;
+	sq_getstring(v,2,&s);
+	if(scremove(s)==-1)
+		return sq_throwerror(v,_SC("remove() failed"));
+	return 0;
+}
+
+static SQInteger _system_rename(HSQUIRRELVM v)
+{
+	const SQChar *oldn,*newn;
+	sq_getstring(v,2,&oldn);
+	sq_getstring(v,3,&newn);
+	if(screname(oldn,newn)==-1)
+		return sq_throwerror(v,_SC("rename() failed"));
+	return 0;
+}
+
+static void _set_integer_slot(HSQUIRRELVM v,const SQChar *name,SQInteger val)
+{
+	sq_pushstring(v,name,-1);
+	sq_pushinteger(v,val);
+	sq_rawset(v,-3);
+}
+
+static SQInteger _system_date(HSQUIRRELVM v)
+{
+	time_t t;
+	SQInteger it;
+	SQInteger format = 'l';
+	if(sq_gettop(v) > 1) {
+		sq_getinteger(v,2,&it);
+		t = it;
+		if(sq_gettop(v) > 2) {
+			sq_getinteger(v,3,(SQInteger*)&format);
+		}
+	}
+	else {
+		time(&t);
+	}
+	tm *date;
+    if(format == 'u')
+		date = gmtime(&t);
+	else
+		date = localtime(&t);
+	if(!date)
+		return sq_throwerror(v,_SC("crt api failure"));
+	sq_newtable(v);
+	_set_integer_slot(v, _SC("sec"), date->tm_sec);
+    _set_integer_slot(v, _SC("min"), date->tm_min);
+    _set_integer_slot(v, _SC("hour"), date->tm_hour);
+    _set_integer_slot(v, _SC("day"), date->tm_mday);
+    _set_integer_slot(v, _SC("month"), date->tm_mon);
+    _set_integer_slot(v, _SC("year"), date->tm_year+1900);
+    _set_integer_slot(v, _SC("wday"), date->tm_wday);
+    _set_integer_slot(v, _SC("yday"), date->tm_yday);
+	return 1;
+}
+
+
+
+#define _DECL_FUNC(name,nparams,pmask) {_SC(#name),_system_##name,nparams,pmask}
+static SQRegFunction systemlib_funcs[]={
+	_DECL_FUNC(getenv,2,_SC(".s")),
+	_DECL_FUNC(system,2,_SC(".s")),
+	_DECL_FUNC(clock,1,NULL),
+	_DECL_FUNC(time,1,NULL),
+	_DECL_FUNC(date,-1,_SC(".nn")),
+	_DECL_FUNC(remove,2,_SC(".s")),
+	_DECL_FUNC(rename,3,_SC(".ss")),
+	{0,0}
+};
+
+
+SQInteger sqstd_register_systemlib(HSQUIRRELVM v)
+{
+	SQInteger i=0;
+	while(systemlib_funcs[i].name!=0)
+	{
+		sq_pushstring(v,systemlib_funcs[i].name,-1);
+		sq_newclosure(v,systemlib_funcs[i].f,0);
+		sq_setparamscheck(v,systemlib_funcs[i].nparamscheck,systemlib_funcs[i].typemask);
+		sq_setnativeclosurename(v,-1,systemlib_funcs[i].name);
+		sq_createslot(v,-3);
+		i++;
+	}
+	return 1;
+}
diff -rupwN ../dnl3/SqPlus/squirrel/sqapi.cpp SqPlus/squirrel/sqapi.cpp
--- ../dnl3/SqPlus/squirrel/sqapi.cpp	2006-03-19 14:32:58.000000000 -0500
+++ SqPlus/squirrel/sqapi.cpp	2009-04-02 12:53:06.000000000 -0400
@@ -39,7 +39,11 @@ SQInteger sq_aux_throwobject(HSQUIRRELVM
 
 SQInteger sq_aux_invalidtype(HSQUIRRELVM v,SQObjectType type)
 {
+#if !defined( SQUNICODE ) || defined( _MSC_VER ) || defined( _WIN32_WCE )
 	scsprintf(_ss(v)->GetScratchPad(100), _SC("unexpected type %s"), IdType2Name(type));
+#else
+	scsprintf(_ss(v)->GetScratchPad(100), 99, _SC("unexpected type %s"), IdType2Name(type));
+#endif
 	return sq_throwerror(v, _ss(v)->GetScratchPad(-1));
 }
 
@@ -84,7 +88,7 @@ SQInteger sq_getvmstate(HSQUIRRELVM v)
 	if(v->_suspended)
 		return SQ_VMSTATE_SUSPENDED;
 	else { 
-		if(v->_callsstack.size() != 0) return SQ_VMSTATE_RUNNING;
+		if(v->_callsstacksize != 0) return SQ_VMSTATE_RUNNING;
 		else return SQ_VMSTATE_IDLE;
 	}
 }
@@ -137,13 +141,22 @@ void sq_notifyallexceptions(HSQUIRRELVM 
 void sq_addref(HSQUIRRELVM v,HSQOBJECT *po)
 {
 	if(!ISREFCOUNTED(type(*po))) return;
+#ifdef NO_GARBAGE_COLLECTOR
+	__AddRef(po->_type,po->_unVal);
+#else
 	_ss(v)->_refs_table.AddRef(*po);
+#endif
 }
 
 SQBool sq_release(HSQUIRRELVM v,HSQOBJECT *po)
 {
 	if(!ISREFCOUNTED(type(*po))) return SQTrue;
+#ifdef NO_GARBAGE_COLLECTOR
+	__Release(po->_type,po->_unVal);
+	return SQFalse; //the ret val doesn't work(and cannot be fixed)
+#else
 	return _ss(v)->_refs_table.Release(*po);
+#endif
 }
 
 const SQChar *sq_objtostring(HSQOBJECT *o) 
@@ -279,13 +292,14 @@ SQRESULT sq_arrayresize(HSQUIRRELVM v,SQ
 	sq_aux_paramscheck(v,1);
 	SQObjectPtr *arr;
 	_GETSAFE_OBJ(v, idx, OT_ARRAY,arr);
-	if(_array(*arr)->Size() > 0) {
+	if(newsize >= 0) {
 		_array(*arr)->Resize(newsize);
 		return SQ_OK;
 	}
-	return SQ_OK;
+	return sq_throwerror(v,_SC("negative size"));
 }
 
+
 SQRESULT sq_arrayreverse(HSQUIRRELVM v,SQInteger idx)
 {
 	sq_aux_paramscheck(v, 1);
@@ -306,6 +320,25 @@ SQRESULT sq_arrayreverse(HSQUIRRELVM v,S
 	return SQ_OK;
 }
 
+SQRESULT sq_arrayremove(HSQUIRRELVM v,SQInteger idx,SQInteger itemidx)
+{
+	sq_aux_paramscheck(v, 1); 
+	SQObjectPtr *arr;
+	_GETSAFE_OBJ(v, idx, OT_ARRAY,arr); 
+	return _array(*arr)->Remove(itemidx) ? SQ_OK : sq_throwerror(v,_SC("index out of range")); 
+}
+
+SQRESULT sq_arrayinsert(HSQUIRRELVM v,SQInteger idx,SQInteger destpos)
+{
+	sq_aux_paramscheck(v, 1); 
+	SQObjectPtr *arr;
+	_GETSAFE_OBJ(v, idx, OT_ARRAY,arr);
+	SQRESULT ret = _array(*arr)->Insert(destpos, v->GetUp(-1)) ? SQ_OK : sq_throwerror(v,_SC("index out of range"));
+	v->Pop();
+	return ret;
+}
+
+
 void sq_newclosure(HSQUIRRELVM v,SQFUNCTION func,SQUnsignedInteger nfreevars)
 {
 	SQNativeClosure *nc = SQNativeClosure::Create(_ss(v), func);
@@ -323,7 +356,7 @@ SQRESULT sq_getclosureinfo(HSQUIRRELVM v
 	if(sq_isclosure(o)) {
 		SQClosure *c = _closure(o);
 		SQFunctionProto *proto = _funcproto(c->_function);
-		*nparams = (SQUnsignedInteger)proto->_parameters.size();
+		*nparams = (SQUnsignedInteger)proto->_nparameters;
         *nfreevars = (SQUnsignedInteger)c->_outervalues.size();
 		return SQ_OK;
 	}
@@ -391,6 +424,20 @@ SQRESULT sq_bindenv(HSQUIRRELVM v,SQInte
 	return SQ_OK;
 }
 
+SQRESULT sq_clear(HSQUIRRELVM v,SQInteger idx)
+{
+	SQObject &o=stack_get(v,idx);
+	switch(type(o)) {
+		case OT_TABLE: _table(o)->Clear();	break;
+		case OT_ARRAY: _array(o)->Resize(0); break;
+		default:
+			return sq_throwerror(v, _SC("clear only works on table and array"));
+		break;
+
+	}
+	return SQ_OK;
+}
+
 void sq_pushroottable(HSQUIRRELVM v)
 {
 	v->Push(v->_roottable);
@@ -401,6 +448,11 @@ void sq_pushregistrytable(HSQUIRRELVM v)
 	v->Push(_ss(v)->_registry);
 }
 
+void sq_pushconsttable(HSQUIRRELVM v)
+{
+	v->Push(_ss(v)->_consts);
+}
+
 SQRESULT sq_setroottable(HSQUIRRELVM v)
 {
 	SQObject o = stack_get(v, -1);
@@ -412,6 +464,17 @@ SQRESULT sq_setroottable(HSQUIRRELVM v)
 	return sq_throwerror(v, _SC("ivalid type"));
 }
 
+SQRESULT sq_setconsttable(HSQUIRRELVM v)
+{
+	SQObject o = stack_get(v, -1);
+	if(sq_istable(o)) {
+		_ss(v)->_consts = o;
+		v->Pop();
+		return SQ_OK;
+	}
+	return sq_throwerror(v, _SC("ivalid type, expected table"));
+}
+
 void sq_setforeignptr(HSQUIRRELVM v,SQUserPointer p)
 {
 	v->_foreignptr = p;
@@ -432,6 +495,7 @@ SQObjectType sq_gettype(HSQUIRRELVM v,SQ
 	return type(stack_get(v, idx));
 }
 
+
 void sq_tostring(HSQUIRRELVM v,SQInteger idx)
 {
 	SQObjectPtr &o = stack_get(v, idx);
@@ -572,6 +636,16 @@ SQRESULT sq_setinstanceup(HSQUIRRELVM v,
 	return SQ_OK;
 }
 
+SQRESULT sq_setclassudsize(HSQUIRRELVM v, SQInteger idx, SQInteger udsize)
+{
+	SQObjectPtr &o = stack_get(v,idx);
+	if(type(o) != OT_CLASS) return sq_throwerror(v,_SC("the object is not a class"));
+	if(_class(o)->_locked) return sq_throwerror(v,_SC("the class is locked"));
+	_class(o)->_udsize = udsize;
+	return SQ_OK;
+}
+
+
 SQRESULT sq_getinstanceup(HSQUIRRELVM v, SQInteger idx, SQUserPointer *p,SQUserPointer typetag)
 {
 	SQObjectPtr &o = stack_get(v,idx);
@@ -600,7 +674,7 @@ void sq_settop(HSQUIRRELVM v, SQInteger 
 	if(top > newtop)
 		sq_pop(v, top - newtop);
 	else
-		while(top < newtop) sq_pushnull(v);
+		while(top++ < newtop) sq_pushnull(v);
 }
 
 void sq_pop(HSQUIRRELVM v, SQInteger nelemstopop)
@@ -641,19 +715,6 @@ SQRESULT sq_newslot(HSQUIRRELVM v, SQInt
 	return SQ_OK;
 }
 
-/*SQRESULT sq_createslot(HSQUIRRELVM v, SQInteger idx)
-{
-	sq_aux_paramscheck(v, 3);
-	SQObjectPtr &self = stack_get(v, idx);
-	if(type(self) == OT_TABLE || type(self) == OT_CLASS) {
-		SQObjectPtr &key = v->GetUp(-2);
-		if(type(key) == OT_NULL) return sq_throwerror(v, _SC("null is not a valid key"));
-		v->NewSlot(self, key, v->GetUp(-1));
-		v->Pop(2);
-	}
-	return SQ_OK;
-}*/
-
 SQRESULT sq_deleteslot(HSQUIRRELVM v,SQInteger idx,SQBool pushval)
 {
 	sq_aux_paramscheck(v, 2);
@@ -709,7 +770,7 @@ SQRESULT sq_rawset(HSQUIRRELVM v,SQInteg
 	break;
 	default:
 		v->Pop(2);
-		return sq_throwerror(v, _SC("rawset works only on array/table/calsse and instance"));
+		return sq_throwerror(v, _SC("rawset works only on array/table/class and instance"));
 	}
 	v->Raise_IdxError(v->GetUp(-2));return SQ_ERROR;
 }
@@ -763,12 +824,12 @@ SQRESULT sq_getdelegate(HSQUIRRELVM v,SQ
 	SQObjectPtr &self=stack_get(v,idx);
 	switch(type(self)){
 	case OT_TABLE:
-		if(!_table(self)->_delegate)break;
-		v->Push(SQObjectPtr(_table(self)->_delegate));
-		break;
 	case OT_USERDATA:
-		if(!_userdata(self)->_delegate)break;
-		v->Push(SQObjectPtr(_userdata(self)->_delegate));
+		if(!_delegable(self)->_delegate){
+			v->Push(_null_);
+			break;
+		}
+		v->Push(SQObjectPtr(_delegable(self)->_delegate));
 		break;
 	default: return sq_throwerror(v,_SC("wrong type")); break;
 	}
@@ -821,7 +882,7 @@ SQRESULT sq_getstackobj(HSQUIRRELVM v,SQ
 
 const SQChar *sq_getlocal(HSQUIRRELVM v,SQUnsignedInteger level,SQUnsignedInteger idx)
 {
-	SQUnsignedInteger cstksize=v->_callsstack.size();
+	SQUnsignedInteger cstksize=v->_callsstacksize;
 	SQUnsignedInteger lvl=(cstksize-level)-1;
 	SQInteger stackbase=v->_stackbase;
 	if(lvl<cstksize){
@@ -834,7 +895,12 @@ const SQChar *sq_getlocal(HSQUIRRELVM v,
 			return NULL;
 		SQClosure *c=_closure(ci._closure);
 		SQFunctionProto *func=_funcproto(c->_function);
-		return func->GetLocal(v,stackbase,idx,(SQInteger)(ci._ip-func->_instructions._vals)-1);
+		if(func->_noutervalues > (SQInteger)idx) {
+			v->Push(c->_outervalues[idx]);
+			return _stringval(func->_outervalues[idx]._name);
+		}
+		idx -= func->_noutervalues;
+		return func->GetLocal(v,stackbase,idx,(SQInteger)(ci._ip-func->_instructions)-1);
 	}
 	return NULL;
 }
@@ -889,7 +955,9 @@ SQRESULT sq_call(HSQUIRRELVM v,SQInteger
 {
 	SQObjectPtr res;
 	if(v->Call(v->GetUp(-(params+1)),params,v->_top-params,res,raiseerror?true:false)){
+		if(!v->_suspended) {
 		v->Pop(params);//pop closure and args
+		}
 		if(retval){
 			v->Push(res); return SQ_OK;
 		}
@@ -918,10 +986,8 @@ SQRESULT sq_wakeupvm(HSQUIRRELVM v,SQBoo
 		v->GetAt(v->_stackbase+v->_suspended_target)=v->GetUp(-1); //retval
 		v->Pop();
 	} else v->GetAt(v->_stackbase+v->_suspended_target)=_null_;
-	if(!v->Execute(_null_,v->_top,-1,-1,ret,raiseerror,SQVM::ET_RESUME_VM))
+	if(!v->Execute(_null_,v->_top,-1,-1,ret,raiseerror,SQVM::ET_RESUME_VM)) {
 		return SQ_ERROR;
-	if(sq_getvmstate(v) == SQ_VMSTATE_IDLE) {
-		while (v->_top > 1) v->_stack[--v->_top] = _null_;
 	}
 	if(retval)
 		v->Push(ret);
@@ -960,14 +1026,14 @@ SQRESULT sq_writeclosure(HSQUIRRELVM v,S
 
 SQRESULT sq_readclosure(HSQUIRRELVM v,SQREADFUNC r,SQUserPointer up)
 {
-	SQObjectPtr func=SQFunctionProto::Create();
-	SQObjectPtr closure=SQClosure::Create(_ss(v),_funcproto(func));
+	SQObjectPtr closure;
+	
 	unsigned short tag;
 	if(r(up,&tag,2) != 2)
 		return sq_throwerror(v,_SC("io error"));
 	if(tag != SQ_BYTECODE_STREAM_TAG)
 		return sq_throwerror(v,_SC("invalid stream"));
-	if(!_closure(closure)->Load(v,up,r))
+	if(!SQClosure::Load(v,up,r,closure))
 		return SQ_ERROR;
 	v->Push(closure);
 	return SQ_OK;
@@ -1140,10 +1206,10 @@ SQRESULT sq_next(HSQUIRRELVM v,SQInteger
 	if(type(o) == OT_GENERATOR) {
 		return sq_throwerror(v,_SC("cannot iterate a generator"));
 	}
-	bool finished;
-	if(!v->FOREACH_OP(o,realkey,val,refpos,0,finished))
+	int faketojump;
+	if(!v->FOREACH_OP(o,realkey,val,refpos,0,666,faketojump))
 		return SQ_ERROR;
-	if(!finished) {
+	if(faketojump != 666) {
 		v->Push(realkey);
 		v->Push(val);
 		return SQ_OK;
@@ -1197,6 +1263,7 @@ void *sq_realloc(void* p,SQUnsignedInteg
 {
 	return SQ_REALLOC(p,oldsize,newsize);
 }
+
 void sq_free(void *p,SQUnsignedInteger size)
 {
 	SQ_FREE(p,size);
diff -rupwN ../dnl3/SqPlus/squirrel/sqarray.h SqPlus/squirrel/sqarray.h
--- ../dnl3/SqPlus/squirrel/sqarray.h	2005-09-25 17:56:20.000000000 -0400
+++ SqPlus/squirrel/sqarray.h	2008-09-15 16:42:51.000000000 -0400
@@ -61,14 +61,22 @@ public:
 	void Extend(const SQArray *a);
 	SQObjectPtr &Top(){return _values.top();}
 	void Pop(){_values.pop_back(); ShrinkIfNeeded(); }
-	void Insert(const SQObject& idx,const SQObject &val){_values.insert((SQUnsignedInteger)tointeger(idx),val);}
+	bool Insert(SQInteger idx,const SQObject &val){
+		if(idx < 0 || idx > (SQInteger)_values.size())
+			return false;
+		_values.insert(idx,val);
+		return true;
+	}
 	void ShrinkIfNeeded() {
 		if(_values.size() <= _values.capacity()>>2) //shrink the array
 			_values.shrinktofit();
 	}
-	void Remove(SQUnsignedInteger idx){
+	bool Remove(SQInteger idx){
+		if(idx < 0 || idx >= (SQInteger)_values.size())
+			return false;
 		_values.remove(idx);
 		ShrinkIfNeeded();
+		return true;
 	}
 	void Release()
 	{
diff -rupwN ../dnl3/SqPlus/squirrel/sqbaselib.cpp SqPlus/squirrel/sqbaselib.cpp
--- ../dnl3/SqPlus/squirrel/sqbaselib.cpp	2006-03-19 14:32:58.000000000 -0500
+++ SqPlus/squirrel/sqbaselib.cpp	2008-09-20 07:41:39.000000000 -0400
@@ -30,6 +30,11 @@ bool str2num(const SQChar *s,SQObjectPtr
 	}
 }
 
+static SQInteger base_dummy(HSQUIRRELVM v)
+{
+	return 0;
+}
+
 #ifndef NO_GARBAGE_COLLECTOR
 static SQInteger base_collectgarbage(HSQUIRRELVM v)
 {
@@ -44,6 +49,13 @@ static SQInteger base_getroottable(HSQUI
 	return 1;
 }
 
+static SQInteger base_getconsttable(HSQUIRRELVM v)
+{
+	v->Push(_ss(v)->_consts);
+	return 1;
+}
+
+
 static SQInteger base_setroottable(HSQUIRRELVM v)
 {
 	SQObjectPtr &o=stack_get(v,2);
@@ -52,6 +64,14 @@ static SQInteger base_setroottable(HSQUI
 	return 1;
 }
 
+static SQInteger base_setconsttable(HSQUIRRELVM v)
+{
+	SQObjectPtr &o=stack_get(v,2);
+	if(SQ_FAILED(sq_setconsttable(v))) return SQ_ERROR;
+	v->Push(o);
+	return 1;
+}
+
 static SQInteger base_seterrorhandler(HSQUIRRELVM v)
 {
 	sq_seterrorhandler(v);
@@ -210,6 +230,8 @@ static SQRegFunction base_funcs[]={
 	{_SC("getstackinfos"),base_getstackinfos,2, _SC(".n")},
 	{_SC("getroottable"),base_getroottable,1, NULL},
 	{_SC("setroottable"),base_setroottable,2, NULL},
+	{_SC("getconsttable"),base_getconsttable,1, NULL},
+	{_SC("setconsttable"),base_setconsttable,2, NULL},
 	{_SC("assert"),base_assert,2, NULL},
 	{_SC("print"),base_print,2, NULL},
 	{_SC("compilestring"),base_compilestring,-2, _SC(".ss")},
@@ -217,6 +239,7 @@ static SQRegFunction base_funcs[]={
 	{_SC("suspend"),base_suspend,-1, NULL},
 	{_SC("array"),base_array,-2, _SC(".n")},
 	{_SC("type"),base_type,2, NULL},
+	{_SC("dummy"),base_dummy,0,NULL},
 #ifndef NO_GARBAGE_COLLECTOR
 	{_SC("collectgarbage"),base_collectgarbage,1, _SC("t")},
 #endif
@@ -235,6 +258,9 @@ void sq_base_register(HSQUIRRELVM v)
 		sq_createslot(v,-3);
 		i++;
 	}
+	sq_pushstring(v,_SC("_version_"),-1);
+	sq_pushstring(v,SQUIRREL_VERSION,-1);
+	sq_createslot(v,-3);
 	sq_pushstring(v,_SC("_charsize_"),-1);
 	sq_pushinteger(v,sizeof(SQChar));
 	sq_createslot(v,-3);
@@ -312,6 +338,12 @@ static SQInteger obj_delegate_weakref(HS
 	return 1;
 }
 
+static SQInteger obj_clear(HSQUIRRELVM v)
+{
+	return sq_clear(v,-1);
+}
+
+
 static SQInteger number_delegate_tochar(HSQUIRRELVM v)
 {
 	SQObject &o=stack_get(v,1);
@@ -353,6 +385,7 @@ static SQInteger table_rawget(HSQUIRRELV
 	return SQ_SUCCEEDED(sq_rawget(v,-2))?1:SQ_ERROR;
 }
 
+
 SQRegFunction SQSharedState::_table_default_delegate_funcz[]={
 	{_SC("len"),default_delegate_len,1, _SC("t")},
 	{_SC("rawget"),table_rawget,2, _SC("t")},
@@ -361,6 +394,7 @@ SQRegFunction SQSharedState::_table_defa
 	{_SC("rawin"),container_rawexists,2, _SC("t")},
 	{_SC("weakref"),obj_delegate_weakref,1, NULL },
 	{_SC("tostring"),default_delegate_tostring,1, _SC(".")},
+	{_SC("clear"),obj_clear,1, _SC(".")},
 	{0,0}
 };
 
@@ -402,7 +436,8 @@ static SQInteger array_insert(HSQUIRRELV
 	SQObject &o=stack_get(v,1);
 	SQObject &idx=stack_get(v,2);
 	SQObject &val=stack_get(v,3);
-	_array(o)->Insert(idx,val);
+	if(!_array(o)->Insert(tointeger(idx),val))
+		return sq_throwerror(v,_SC("index out of range"));
 	return 0;
 }
 
@@ -448,6 +483,7 @@ bool _qsort_compare(HSQUIRRELVM v,SQObje
 		v->Push(a);
 		v->Push(b);
 		if(SQ_FAILED(sq_call(v, 3, SQTrue, SQFalse))) {
+			if(!sq_isstring( v->_lasterror)) 
 			v->Raise_Error(_SC("compare func failed"));
 			return false;
 		}
@@ -476,6 +512,10 @@ bool _qsort(HSQUIRRELVM v,SQObjectPtr &a
 			} while( ret <= 0);
 			do {
 				--j; 
+				if ( j < 0 ) {
+					v->Raise_Error( _SC("Invalid qsort, probably compare function defect") ); 
+					return false; 
+				}
 				if(!_qsort_compare(v,arr,a->_values[j],pivot,func,ret))
 					return false;
 			}
@@ -508,9 +548,11 @@ static SQInteger array_slice(HSQUIRRELVM
 	SQInteger sidx,eidx;
 	SQObjectPtr o;
 	if(get_slice_params(v,sidx,eidx,o)==-1)return -1;
-	if(sidx<0)sidx=_array(o)->Size()+sidx;
-	if(eidx<0)eidx=_array(o)->Size()+eidx;
-	if(eidx <= sidx)return sq_throwerror(v,_SC("wrong indexes"));
+	SQInteger alen = _array(o)->Size();
+	if(sidx < 0)sidx = alen + sidx;
+	if(eidx < 0)eidx = alen + eidx;
+	if(eidx < sidx)return sq_throwerror(v,_SC("wrong indexes"));
+	if(eidx > alen)return sq_throwerror(v,_SC("slice out of range"));
 	SQArray *arr=SQArray::Create(_ss(v),eidx-sidx);
 	SQObjectPtr t;
 	SQInteger count=0;
@@ -538,6 +580,7 @@ SQRegFunction SQSharedState::_array_defa
 	{_SC("slice"),array_slice,-1, _SC("ann")},
 	{_SC("weakref"),obj_delegate_weakref,1, NULL },
 	{_SC("tostring"),default_delegate_tostring,1, _SC(".")},
+	{_SC("clear"),obj_clear,1, _SC(".")},
 	{0,0}
 };
 
@@ -547,10 +590,11 @@ static SQInteger string_slice(HSQUIRRELV
 	SQInteger sidx,eidx;
 	SQObjectPtr o;
 	if(SQ_FAILED(get_slice_params(v,sidx,eidx,o)))return -1;
-	if(sidx<0)sidx=_string(o)->_len+sidx;
-	if(eidx<0)eidx=_string(o)->_len+eidx;
-	if(eidx<sidx)
-		return sq_throwerror(v,_SC("wrong indexes"));
+	SQInteger slen = _string(o)->_len;
+	if(sidx < 0)sidx = slen + sidx;
+	if(eidx < 0)eidx = slen + eidx;
+	if(eidx < sidx)	return sq_throwerror(v,_SC("wrong indexes"));
+	if(eidx > slen)	return sq_throwerror(v,_SC("slice out of range"));
 	v->Push(SQString::Create(_ss(v),&_stringval(o)[sidx],eidx-sidx));
 	return 1;
 }
@@ -653,9 +697,9 @@ static SQInteger closure_getinfos(HSQUIR
 	SQTable *res = SQTable::Create(_ss(v),4);
 	if(type(o) == OT_CLOSURE) {
 		SQFunctionProto *f = _funcproto(_closure(o)->_function);
-		SQInteger nparams = f->_parameters.size() + (f->_varparams?1:0);
+		SQInteger nparams = f->_nparameters + (f->_varparams?1:0);
 		SQObjectPtr params = SQArray::Create(_ss(v),nparams);
-		for(SQUnsignedInteger n = 0; n<f->_parameters.size(); n++) {
+		for(SQInteger n = 0; n<f->_nparameters; n++) {
 			_array(params)->Set((SQInteger)n,f->_parameters[n]);
 		}
 		if(f->_varparams) {
@@ -722,6 +766,7 @@ SQRegFunction SQSharedState::_generator_
 
 static SQInteger thread_call(HSQUIRRELVM v)
 {
+	
 	SQObjectPtr o = stack_get(v,1);
 	if(type(o) == OT_THREAD) {
 		SQInteger nparams = sq_gettop(v);
@@ -730,8 +775,10 @@ static SQInteger thread_call(HSQUIRRELVM
 			sq_move(_thread(o),v,i);
 		if(SQ_SUCCEEDED(sq_call(_thread(o),nparams,SQTrue,SQFalse))) {
 			sq_move(v,_thread(o),-1);
+			sq_pop(_thread(o),1);
 			return 1;
 		}
+		v->_lasterror = _thread(o)->_lasterror;
 		return SQ_ERROR;
 	}
 	return sq_throwerror(v,_SC("wrong parameter"));
@@ -758,14 +805,16 @@ static SQInteger thread_wakeup(HSQUIRREL
 		if(wakeupret) {
 			sq_move(thread,v,2);
 		}
-		if(SQ_SUCCEEDED(sq_wakeupvm(thread,wakeupret,1,SQFalse))) {
+		if(SQ_SUCCEEDED(sq_wakeupvm(thread,wakeupret,SQTrue,SQFalse))) {
 			sq_move(v,thread,-1);
-			sq_pop(thread,1);
+			sq_pop(thread,1); //pop retval
 			if(sq_getvmstate(thread) == SQ_VMSTATE_IDLE) {
-				sq_pop(thread,1);
+				sq_settop(thread,1); //pop roottable
 			}
 			return 1;
 		}
+		sq_settop(thread,1);
+		v->_lasterror = thread->_lasterror;
 		return SQ_ERROR;
 	}
 	return sq_throwerror(v,_SC("wrong parameter"));
diff -rupwN ../dnl3/SqPlus/squirrel/sqclass.cpp SqPlus/squirrel/sqclass.cpp
--- ../dnl3/SqPlus/squirrel/sqclass.cpp	2006-03-19 14:32:58.000000000 -0500
+++ SqPlus/squirrel/sqclass.cpp	2007-07-18 09:37:37.000000000 -0400
@@ -12,6 +12,7 @@ SQClass::SQClass(SQSharedState *ss,SQCla
 	_base = base;
 	_typetag = 0;
 	_hook = NULL;
+	_udsize = 0;
 	_metamethods.resize(MT_LAST); //size it to max size
 	if(_base) {
 		_defaultvalues.copy(base->_defaultvalues);
@@ -61,7 +62,7 @@ bool SQClass::NewSlot(SQSharedState *ss,
 		} 
 		else {
 			if(type(temp) == OT_NULL) {
-				SQClassMemeber m;
+				SQClassMember m;
 				m.val = val;
 				_members->NewSlot(key,SQObjectPtr(_make_method_idx(_methods.size())));
 				_methods.push_back(m);
@@ -72,7 +73,7 @@ bool SQClass::NewSlot(SQSharedState *ss,
 		}
 		return true;
 	}
-	SQClassMemeber m;
+	SQClassMember m;
 	m.val = val;
 	_members->NewSlot(key,SQObjectPtr(_make_field_idx(_defaultvalues.size())));
 	_defaultvalues.push_back(m);
@@ -139,8 +140,8 @@ SQInstance::SQInstance(SQSharedState *ss
 {
 	_memsize = memsize;
 	_class = c;
-	_nvalues = _class->_defaultvalues.size();
-	for(SQUnsignedInteger n = 0; n < _nvalues; n++) {
+	SQUnsignedInteger nvalues = _class->_defaultvalues.size();
+	for(SQUnsignedInteger n = 0; n < nvalues; n++) {
 		new (&_values[n]) SQObjectPtr(_class->_defaultvalues[n].val);
 	}
 	Init(ss);
@@ -150,8 +151,8 @@ SQInstance::SQInstance(SQSharedState *ss
 {
 	_memsize = memsize;
 	_class = i->_class;
-	_nvalues = _class->_defaultvalues.size();
-	for(SQUnsignedInteger n = 0; n < _nvalues; n++) {
+	SQUnsignedInteger nvalues = _class->_defaultvalues.size();
+	for(SQUnsignedInteger n = 0; n < nvalues; n++) {
 		new (&_values[n]) SQObjectPtr(i->_values[n]);
 	}
 	Init(ss);
@@ -159,8 +160,9 @@ SQInstance::SQInstance(SQSharedState *ss
 
 void SQInstance::Finalize() 
 {
+	SQUnsignedInteger nvalues = _class->_defaultvalues.size();
 	__ObjRelease(_class);
-	for(SQUnsignedInteger i = 0; i < _nvalues; i++) {
+	for(SQUnsignedInteger i = 0; i < nvalues; i++) {
 		_values[i] = _null_;
 	}
 }
@@ -168,7 +170,7 @@ void SQInstance::Finalize() 
 SQInstance::~SQInstance()
 {
 	REMOVE_FROM_CHAIN(&_sharedstate->_gc_chain, this);
-	Finalize();
+	if(_class){ Finalize(); } //if _class is null it was already finalized by the GC
 }
 
 bool SQInstance::GetMetaMethod(SQVM *v,SQMetaMethod mm,SQObjectPtr &res)
diff -rupwN ../dnl3/SqPlus/squirrel/sqclass.h SqPlus/squirrel/sqclass.h
--- ../dnl3/SqPlus/squirrel/sqclass.h	2006-03-19 14:32:58.000000000 -0500
+++ SqPlus/squirrel/sqclass.h	2006-11-14 08:05:39.000000000 -0500
@@ -4,9 +4,9 @@
 
 struct SQInstance;
 
-struct SQClassMemeber {
-	SQClassMemeber(){}
-	SQClassMemeber(const SQClassMemeber &o) {
+struct SQClassMember {
+	SQClassMember(){}
+	SQClassMember(const SQClassMember &o) {
 		val = o.val;
 		attrs = o.attrs;
 	}
@@ -14,7 +14,7 @@ struct SQClassMemeber {
 	SQObjectPtr attrs;
 };
 
-typedef sqvector<SQClassMemeber> SQClassMemeberVec;
+typedef sqvector<SQClassMember> SQClassMemberVec;
 
 #define MEMBER_TYPE_METHOD 0x01000000
 #define MEMBER_TYPE_FIELD 0x02000000
@@ -65,17 +65,19 @@ public:
 	SQInstance *CreateInstance();
 	SQTable *_members;
 	SQClass *_base;
-	SQClassMemeberVec _defaultvalues;
-	SQClassMemeberVec _methods;
+	SQClassMemberVec _defaultvalues;
+	SQClassMemberVec _methods;
 	SQObjectPtrVec _metamethods;
 	SQObjectPtr _attributes;
 	SQUserPointer _typetag;
 	SQRELEASEHOOK _hook;
 	bool _locked;
+	SQInteger _udsize;
 };
 
 #define calcinstancesize(_theclass_) \
-	(sizeof(SQInstance)+(sizeof(SQObjectPtr)*(_theclass_->_defaultvalues.size()>0?_theclass_->_defaultvalues.size()-1:0)))
+	(_theclass_->_udsize + sizeof(SQInstance) + (sizeof(SQObjectPtr)*(_theclass_->_defaultvalues.size()>0?_theclass_->_defaultvalues.size()-1:0)))
+
 struct SQInstance : public SQDelegable 
 {
 	void Init(SQSharedState *ss);
@@ -87,6 +89,9 @@ public:
 		SQInteger size = calcinstancesize(theclass);
 		SQInstance *newinst = (SQInstance *)SQ_MALLOC(size);
 		new (newinst) SQInstance(ss, theclass,size);
+		if(theclass->_udsize) {
+			newinst->_userpointer = ((unsigned char *)newinst) + (size - theclass->_udsize);
+		}
 		return newinst;
 	}
 	SQInstance *Clone(SQSharedState *ss)
@@ -94,6 +99,9 @@ public:
 		SQInteger size = calcinstancesize(_class);
 		SQInstance *newinst = (SQInstance *)SQ_MALLOC(size);
 		new (newinst) SQInstance(ss, this,size);
+		if(_class->_udsize) {
+			newinst->_userpointer = ((unsigned char *)newinst) + (size - _class->_udsize);
+		}
 		return newinst;
 	}
 	~SQInstance();
@@ -119,7 +127,10 @@ public:
 		return false;
 	}
 	void Release() { 
+		_uiRef++;
 		if (_hook) { _hook(_userpointer,0);}
+		_uiRef--;
+		if(_uiRef > 0) return;
 		SQInteger size = _memsize;
 		this->~SQInstance();
 		SQ_FREE(this, size);
@@ -134,7 +145,6 @@ public:
 	SQClass *_class;
 	SQUserPointer _userpointer;
 	SQRELEASEHOOK _hook;
-	SQUnsignedInteger _nvalues;
 	SQInteger _memsize;
 	SQObjectPtr _values[1];
 };
diff -rupwN ../dnl3/SqPlus/squirrel/sqclosure.h SqPlus/squirrel/sqclosure.h
--- ../dnl3/SqPlus/squirrel/sqclosure.h	2006-03-19 14:32:58.000000000 -0500
+++ SqPlus/squirrel/sqclosure.h	2008-05-16 09:23:59.000000000 -0400
@@ -22,6 +22,7 @@ public:
 		SQClosure * ret = SQClosure::Create(_opt_ss(this),_funcproto(_function));
 		ret->_env = _env;
 		ret->_outervalues.copy(_outervalues);
+		ret->_defaultparams.copy(_defaultparams);
 		return ret;
 	}
 	~SQClosure()
@@ -29,7 +30,7 @@ public:
 		REMOVE_FROM_CHAIN(&_ss(this)->_gc_chain,this);
 	}
 	bool Save(SQVM *v,SQUserPointer up,SQWRITEFUNC write);
-	bool Load(SQVM *v,SQUserPointer up,SQREADFUNC read);
+	static bool Load(SQVM *v,SQUserPointer up,SQREADFUNC read,SQObjectPtr &ret);
 #ifndef NO_GARBAGE_COLLECTOR
 	void Mark(SQCollectable **chain);
 	void Finalize(){_outervalues.resize(0); }
@@ -37,13 +38,14 @@ public:
 	SQObjectPtr _env;
 	SQObjectPtr _function;
 	SQObjectPtrVec _outervalues;
+	SQObjectPtrVec _defaultparams;
 };
 //////////////////////////////////////////////
 struct SQGenerator : public CHAINABLE_OBJ 
 {
 	enum SQGeneratorState{eRunning,eSuspended,eDead};
 private:
-	SQGenerator(SQSharedState *ss,SQClosure *closure){_closure=closure;_state=eRunning;_ci._generator=_null_;INIT_CHAIN();ADD_TO_CHAIN(&_ss(this)->_gc_chain,this);}
+	SQGenerator(SQSharedState *ss,SQClosure *closure){_closure=closure;_state=eRunning;_ci._generator=NULL;INIT_CHAIN();ADD_TO_CHAIN(&_ss(this)->_gc_chain,this);}
 public:
 	static SQGenerator *Create(SQSharedState *ss,SQClosure *closure){
 		SQGenerator *nc=(SQGenerator*)SQ_MALLOC(sizeof(SQGenerator));
@@ -92,7 +94,7 @@ public:
 		ret->_env = _env;
 		ret->_name = _name;
 		ret->_outervalues.copy(_outervalues);
-		ret->_typecheck = _typecheck;
+		ret->_typecheck.copy(_typecheck);
 		ret->_nparamscheck = _nparamscheck;
 		return ret;
 	}
@@ -107,12 +109,12 @@ public:
 	void Mark(SQCollectable **chain);
 	void Finalize(){_outervalues.resize(0);}
 #endif
+	SQInteger _nparamscheck;
+	SQIntVec _typecheck;
+	SQObjectPtrVec _outervalues;
 	SQObjectPtr _env;
 	SQFUNCTION _function;
 	SQObjectPtr _name;
-	SQObjectPtrVec _outervalues;
-	SQIntVec _typecheck;
-	SQInteger _nparamscheck;
 };
 
 
diff -rupwN ../dnl3/SqPlus/squirrel/sqcompiler.cpp SqPlus/squirrel/sqcompiler.cpp
--- ../dnl3/SqPlus/squirrel/sqcompiler.cpp	2006-03-19 14:32:58.000000000 -0500
+++ SqPlus/squirrel/sqcompiler.cpp	2009-06-24 17:39:11.000000000 -0400
@@ -3,7 +3,9 @@
 */
 #include "sqpcheader.h"
 #include <stdarg.h>
+#if !defined ( SQNOSETJMP )
 #include <setjmp.h>
+#endif
 #include "sqopcodes.h"
 #include "sqstring.h"
 #include "sqfuncproto.h"
@@ -11,6 +13,7 @@
 #include "sqfuncstate.h"
 #include "sqlexer.h"
 #include "sqvm.h"
+#include "sqtable.h"
 
 #define DEREF_NO_DEREF	-1
 #define DEREF_FIELD		-2
@@ -64,10 +67,19 @@ public:
 		static SQChar temp[256];
 		va_list vl;
 		va_start(vl, s);
+#if !defined( SQUNICODE ) || defined( _MSC_VER ) || defined( _WIN32_WCE )
 		scvsprintf(temp, s, vl);
+#else
+		scvsprintf(temp, sizeof( temp ), s, vl);
+#endif
+
 		va_end(vl);
 		compilererror = temp;
+#if defined ( SQNOSETJMP )
+		throw 1;
+#else
 		longjmp(_errorjmp,1);
+#endif
 	}
 	void Lex(){	_token = _lex.Lex();}
 	void PushExpState(){ _expstates.push_back(ExpState()); }
@@ -163,7 +175,11 @@ public:
 		_fs->AddParameter(_fs->CreateString(_SC("this")));
 		_fs->_sourcename = _sourcename;
 		SQInteger stacksize = _fs->GetStackSize();
+#if defined ( SQNOSETJMP )
+		try {
+#else
 		if(setjmp(_errorjmp) == 0) {
+#endif
 			Lex();
 			while(_token > 0){
 				Statement();
@@ -178,7 +194,11 @@ public:
 			_fs->Dump(_funcproto(o));
 #endif
 		}
+#if defined ( SQNOSETJMP )
+		catch( ... ) {
+#else
 		else {
+#endif
 			if(_raiseerror && _ss(_vm)->_compilererrorhandler) {
 				_ss(_vm)->_compilererrorhandler(_vm, compilererror, type(_sourcename) == OT_STRING?_stringval(_sourcename):_SC("unknown"),
 					_lex._currentline, _lex._currentcolumn);
@@ -258,6 +278,9 @@ public:
 		case TK_CLASS:
 			ClassStatement();
 			break;
+		case TK_ENUM:
+			EnumStatement();
+			break;
 		case _SC('{'):{
 				SQInteger stacksize = _fs->GetStackSize();
 				Lex();
@@ -274,6 +297,19 @@ public:
 			CommaExpr();
 			_fs->AddInstruction(_OP_THROW, _fs->PopTarget());
 			break;
+		case TK_CONST:
+			{
+			Lex();
+			SQObject id = Expect(TK_IDENTIFIER);
+			Expect('=');
+			SQObject val = ExpectScalar();
+			OptionalSemicolon();
+			SQTable *enums = _table(_ss(_vm)->_consts);
+			SQObjectPtr strongid = id;
+			enums->NewSlot(strongid,SQObjectPtr(val));
+			strongid.Null();
+			}
+			break;
 		default:
 			CommaExpr();
 			_fs->PopTarget();
@@ -599,6 +635,7 @@ public:
 		case TK_THIS:{
 			_exst._freevar = false;
 			SQObject id;
+			SQObject constant;
 				switch(_token) {
 					case TK_IDENTIFIER: id = _fs->CreateString(_lex._svalue); break;
 					case TK_THIS: id = _fs->CreateString(_SC("this")); break;
@@ -612,13 +649,43 @@ public:
 						_exst._deref = _fs->PushTarget();
 						_fs->AddInstruction(_OP_LOADFREEVAR, _exst._deref ,pos);	
 						_exst._freevar = true;
-					} else {
+					}
+					else if(_fs->IsConstant(id,constant)) { //line 634
+						SQObjectPtr constval;
+						SQObject constid;
+						if(type(constant) == OT_TABLE) {
+							Expect('.'); constid = Expect(TK_IDENTIFIER);
+							if(!_table(constant)->Get(constid,constval)) {
+								constval.Null();
+								Error(_SC("invalid constant [%s.%s]"), _stringval(id),_stringval(constid));
+							}
+						}
+						else {
+							constval = constant;
+						}
+						_exst._deref = _fs->PushTarget();
+						SQObjectType ctype = type(constval);
+						if(ctype == OT_INTEGER && (_integer(constval) & (~0x7FFFFFFF)) == 0) {
+							_fs->AddInstruction(_OP_LOADINT, _exst._deref,_integer(constval));
+						}
+						else if(ctype == OT_FLOAT && sizeof(SQFloat) == sizeof(SQInt32)) {
+							SQFloat f = _float(constval);
+							_fs->AddInstruction(_OP_LOADFLOAT, _exst._deref,*((SQInt32 *)&f));
+						}
+						else {
+							_fs->AddInstruction(_OP_LOAD, _exst._deref, _fs->GetConstant(constval));
+						}
+
+						_exst._freevar = true;
+					}
+					else {
 						_fs->PushTarget(0);
 						_fs->AddInstruction(_OP_LOAD, _fs->PushTarget(), _fs->GetConstant(id));
 						if(NeedGet()) Emit2ArgsOP(_OP_GET);
 						_exst._deref = DEREF_FIELD;
 					}
 				}
+
 				else{
 					_fs->PushTarget(pos);
 					_exst._deref = pos;
@@ -648,7 +715,12 @@ public:
 						 }
 			break;
 		case TK_FLOAT: 
+			if(sizeof(SQFloat) == sizeof(SQInt32)) {
+				_fs->AddInstruction(_OP_LOADFLOAT, _fs->PushTarget(),*((SQInt32 *)&_lex._fvalue));
+			}
+			else {
 			_fs->AddInstruction(_OP_LOAD, _fs->PushTarget(), _fs->GetNumericConstant(_lex._fvalue));
+			}
 			Lex();
 			break;
 		case TK_TRUE: case TK_FALSE:
@@ -938,11 +1010,13 @@ public:
 		SQInteger jmppos = _fs->GetCurrentPos();
 		_fs->AddInstruction(_OP_FOREACH, container, 0, indexpos);
 		SQInteger foreachpos = _fs->GetCurrentPos();
+		_fs->AddInstruction(_OP_POSTFOREACH, container, 0, indexpos);
 		//generate the statement code
 		BEGIN_BREAKBLE_BLOCK()
 		Statement();
 		_fs->AddInstruction(_OP_JMP, 0, jmppos - _fs->GetCurrentPos() - 1);
 		_fs->SetIntructionParam(foreachpos, 1, _fs->GetCurrentPos() - foreachpos);
+		_fs->SetIntructionParam(foreachpos + 1, 1, _fs->GetCurrentPos() - foreachpos);
 		//restore the local variable stack(remove index,val and ref idx)
 		CleanStack(stacksize);
 		END_BREAKBLE_BLOCK(foreachpos - 1);
@@ -1031,6 +1105,62 @@ public:
 		}
 		else Error(_SC("cannot create a class in a local with the syntax(class <local>)"));
 	}
+	SQObject ExpectScalar()
+	{
+		SQObject val;
+		switch(_token) {
+			case TK_INTEGER:
+				val._type = OT_INTEGER;
+				val._unVal.nInteger = _lex._nvalue;
+				break;
+			case TK_FLOAT:
+				val._type = OT_FLOAT;
+				val._unVal.fFloat = _lex._fvalue;
+				break;
+			case TK_STRING_LITERAL:
+				val = _fs->CreateString(_lex._svalue,_lex._longstr.size()-1);
+				break;
+			default:
+			Error(_SC("scalar expected : integer,float or string"));
+		}
+		Lex();
+		return val;
+	}
+	void EnumStatement()
+	{
+
+		Lex();
+		SQObject id = Expect(TK_IDENTIFIER);
+		Expect(_SC('{'));
+
+		SQObject table = _fs->CreateTable();
+		SQInteger nval = 0;
+		while(_token != _SC('}')) {
+			SQObject key = Expect(TK_IDENTIFIER);
+			SQObject val;
+			if(_token == _SC('=')) {
+				Lex();
+				val = ExpectScalar();
+			}
+			else {
+				val._type = OT_INTEGER;
+				val._unVal.nInteger = nval++;
+			}
+			_table(table)->NewSlot(SQObjectPtr(key),SQObjectPtr(val));
+			if(_token == ',') Lex();
+		}
+		SQTable *enums = _table(_ss(_vm)->_consts);
+		SQObjectPtr strongid = id;
+		/*SQObjectPtr dummy;
+		if(enums->Get(strongid,dummy)) {
+			dummy.Null(); strongid.Null();
+			Error(_SC("enumeration already exists"));
+		}*/
+		enums->NewSlot(SQObjectPtr(strongid),SQObjectPtr(table));
+		strongid.Null();
+		Lex();
+
+	}
 	void TryCatchStatement()
 	{
 		SQObject exid;
@@ -1124,8 +1254,10 @@ public:
 		SQObject paramname;
 		funcstate->AddParameter(_fs->CreateString(_SC("this")));
 		funcstate->_sourcename = _sourcename;
+		SQInteger defparams = 0;
 		while(_token!=_SC(')')) {
 			if(_token == TK_VARPARAMS) {
+				if(defparams > 0) Error(_SC("function with default parameters cannot have variable number of parameters"));
 				funcstate->_varparams = true;
 				Lex();
 				if(_token != _SC(')')) Error(_SC("expected ')'"));
@@ -1134,11 +1266,23 @@ public:
 			else {
 				paramname = Expect(TK_IDENTIFIER);
 				funcstate->AddParameter(paramname);
+				if(_token == _SC('=')) {
+					Lex();
+					Expression();
+					funcstate->AddDefaultParam(_fs->TopTarget());
+					defparams++;
+				}
+				else {
+					if(defparams > 0) Error(_SC("expected '='"));
+				}
 				if(_token == _SC(',')) Lex();
 				else if(_token != _SC(')')) Error(_SC("expected ')' or ','"));
 			}
 		}
 		Expect(_SC(')'));
+		for(SQInteger n = 0; n < defparams; n++) {
+			_fs->PopTarget();
+		}
 		//outer values
 		if(_token == _SC(':')) {
 			Lex(); Expect(_SC('('));
@@ -1203,7 +1347,9 @@ private:
 	SQInteger _debugop;
 	ExpStateVec _expstates;
 	SQChar *compilererror;
+#if !defined ( SQNOSETJMP )
 	jmp_buf _errorjmp;
+#endif
 	SQVM *_vm;
 };
 
diff -rupwN ../dnl3/SqPlus/squirrel/sqcompiler.h SqPlus/squirrel/sqcompiler.h
--- ../dnl3/SqPlus/squirrel/sqcompiler.h	2006-03-19 14:32:58.000000000 -0500
+++ SqPlus/squirrel/sqcompiler.h	2007-10-14 16:13:17.000000000 -0400
@@ -68,6 +68,8 @@ struct SQVM;
 #define TK_ATTR_OPEN 320
 #define TK_ATTR_CLOSE 321
 #define TK_STATIC 322
+#define TK_ENUM 323
+#define TK_CONST 324
 
 
 typedef void(*CompilerErrorFunc)(void *ud, const SQChar *s);
diff -rupwN ../dnl3/SqPlus/squirrel/sqdebug.cpp SqPlus/squirrel/sqdebug.cpp
--- ../dnl3/SqPlus/squirrel/sqdebug.cpp	2006-03-19 14:32:58.000000000 -0500
+++ SqPlus/squirrel/sqdebug.cpp	2009-04-02 12:54:18.000000000 -0400
@@ -10,7 +10,7 @@
 
 SQRESULT sq_stackinfos(HSQUIRRELVM v, SQInteger level, SQStackInfos *si)
 {
-	SQInteger cssize = v->_callsstack.size();
+	SQInteger cssize = v->_callsstacksize;
 	if (cssize > level) {
 		memset(si, 0, sizeof(SQStackInfos));
 		SQVM::CallInfo &ci = v->_callsstack[cssize-level-1];
@@ -42,7 +42,11 @@ void SQVM::Raise_Error(const SQChar *s, 
 {
 	va_list vl;
 	va_start(vl, s);
+#if !defined( SQUNICODE ) || defined( _MSC_VER ) || defined( _WIN32_WCE )
 	scvsprintf(_sp(rsl((SQInteger)scstrlen(s)+(NUMBER_MAX_CHAR*2))), s, vl);
+#else
+	scvsprintf(_sp(rsl((SQInteger)scstrlen(s)+(NUMBER_MAX_CHAR*2))), NUMBER_MAX_CHAR, s, vl);
+#endif
 	va_end(vl);
 	_lasterror = SQString::Create(_ss(this),_spval,-1);
 }
@@ -57,11 +61,19 @@ SQString *SQVM::PrintObjVal(const SQObje
 	switch(type(o)) {
 	case OT_STRING: return _string(o);
 	case OT_INTEGER:
+#if !defined( SQUNICODE ) || defined( _MSC_VER ) || defined( _WIN32_WCE )
 		scsprintf(_sp(rsl(NUMBER_MAX_CHAR+1)), _SC("%d"), _integer(o));
+#else
+		scsprintf(_sp(rsl(NUMBER_MAX_CHAR+1)), NUMBER_MAX_CHAR, _SC("%d"), _integer(o));
+#endif
 		return SQString::Create(_ss(this), _spval);
 		break;
 	case OT_FLOAT:
+#if !defined( SQUNICODE ) || defined( _MSC_VER ) || defined( _WIN32_WCE )
 		scsprintf(_sp(rsl(NUMBER_MAX_CHAR+1)), _SC("%.14g"), _float(o));
+#else
+		scsprintf(_sp(rsl(NUMBER_MAX_CHAR+1)), NUMBER_MAX_CHAR, _SC("%.14g"), _float(o));
+#endif
 		return SQString::Create(_ss(this), _spval);
 		break;
 	default:
diff -rupwN ../dnl3/SqPlus/squirrel/sqfuncproto.h SqPlus/squirrel/sqfuncproto.h
--- ../dnl3/SqPlus/squirrel/sqfuncproto.h	2005-09-25 17:56:20.000000000 -0400
+++ SqPlus/squirrel/sqfuncproto.h	2007-09-30 13:16:58.000000000 -0400
@@ -53,6 +53,23 @@ typedef sqvector<SQOuterVar> SQOuterVarV
 typedef sqvector<SQLocalVarInfo> SQLocalVarInfoVec;
 typedef sqvector<SQLineInfo> SQLineInfoVec;
 
+#define _FUNC_SIZE(ni,nl,nparams,nfuncs,nouters,nlineinf,localinf,defparams) (sizeof(SQFunctionProto) \
+		+((ni-1)*sizeof(SQInstruction))+(nl*sizeof(SQObjectPtr)) \
+		+(nparams*sizeof(SQObjectPtr))+(nfuncs*sizeof(SQObjectPtr)) \
+		+(nouters*sizeof(SQOuterVar))+(nlineinf*sizeof(SQLineInfo)) \
+		+(localinf*sizeof(SQLocalVarInfo))+(defparams*sizeof(SQInteger)))
+
+#define _CONSTRUCT_VECTOR(type,size,ptr) { \
+	for(SQInteger n = 0; n < size; n++) { \
+			new (&ptr[n]) type(); \
+		} \
+}
+
+#define _DESTRUCT_VECTOR(type,size,ptr) { \
+	for(SQInteger nl = 0; nl < size; nl++) { \
+			ptr[nl].~type(); \
+	} \
+}
 struct SQFunctionProto : public SQRefCounted
 {
 private:
@@ -60,29 +77,84 @@ private:
 	_stacksize=0;
 	_bgenerator=false;}
 public:
-	static SQFunctionProto *Create()
+	static SQFunctionProto *Create(SQInteger ninstructions,
+		SQInteger nliterals,SQInteger nparameters,
+		SQInteger nfunctions,SQInteger noutervalues,
+		SQInteger nlineinfos,SQInteger nlocalvarinfos,SQInteger ndefaultparams)
 	{
 		SQFunctionProto *f;
-		sq_new(f,SQFunctionProto);
+		//I compact the whole class and members in a single memory allocation
+		f = (SQFunctionProto *)sq_vm_malloc(_FUNC_SIZE(ninstructions,nliterals,nparameters,nfunctions,noutervalues,nlineinfos,nlocalvarinfos,ndefaultparams));
+		new (f) SQFunctionProto;
+		f->_ninstructions = ninstructions;
+		f->_literals = (SQObjectPtr*)&f->_instructions[ninstructions];
+		f->_nliterals = nliterals;
+		f->_parameters = (SQObjectPtr*)&f->_literals[nliterals];
+		f->_nparameters = nparameters;
+		f->_functions = (SQObjectPtr*)&f->_parameters[nparameters];
+		f->_nfunctions = nfunctions;
+		f->_outervalues = (SQOuterVar*)&f->_functions[nfunctions];
+		f->_noutervalues = noutervalues;
+		f->_lineinfos = (SQLineInfo *)&f->_outervalues[noutervalues];
+		f->_nlineinfos = nlineinfos;
+		f->_localvarinfos = (SQLocalVarInfo *)&f->_lineinfos[nlineinfos];
+		f->_nlocalvarinfos = nlocalvarinfos;
+		f->_defaultparams = (SQInteger *)&f->_localvarinfos[nlocalvarinfos];
+		f->_ndefaultparams = ndefaultparams;
+
+		_CONSTRUCT_VECTOR(SQObjectPtr,f->_nliterals,f->_literals);
+		_CONSTRUCT_VECTOR(SQObjectPtr,f->_nparameters,f->_parameters);
+		_CONSTRUCT_VECTOR(SQObjectPtr,f->_nfunctions,f->_functions);
+		_CONSTRUCT_VECTOR(SQOuterVar,f->_noutervalues,f->_outervalues);
+		//_CONSTRUCT_VECTOR(SQLineInfo,f->_nlineinfos,f->_lineinfos); //not required are 2 integers
+		_CONSTRUCT_VECTOR(SQLocalVarInfo,f->_nlocalvarinfos,f->_localvarinfos);
 		return f;
 	}
-	void Release(){ sq_delete(this,SQFunctionProto);}
+	void Release(){ 
+		_DESTRUCT_VECTOR(SQObjectPtr,_nliterals,_literals);
+		_DESTRUCT_VECTOR(SQObjectPtr,_nparameters,_parameters);
+		_DESTRUCT_VECTOR(SQObjectPtr,_nfunctions,_functions);
+		_DESTRUCT_VECTOR(SQOuterVar,_noutervalues,_outervalues);
+		//_DESTRUCT_VECTOR(SQLineInfo,_nlineinfos,_lineinfos); //not required are 2 integers
+		_DESTRUCT_VECTOR(SQLocalVarInfo,_nlocalvarinfos,_localvarinfos);
+		SQInteger size = _FUNC_SIZE(_ninstructions,_nliterals,_nparameters,_nfunctions,_noutervalues,_nlineinfos,_nlocalvarinfos,_ndefaultparams);
+		this->~SQFunctionProto();
+		sq_vm_free(this,size);
+	}
 	const SQChar* GetLocal(SQVM *v,SQUnsignedInteger stackbase,SQUnsignedInteger nseq,SQUnsignedInteger nop);
 	SQInteger GetLine(SQInstruction *curr);
 	bool Save(SQVM *v,SQUserPointer up,SQWRITEFUNC write);
-	bool Load(SQVM *v,SQUserPointer up,SQREADFUNC read);
-	SQObjectPtrVec _literals;
-	SQObjectPtrVec _functions;
-	SQObjectPtrVec _parameters;
-	SQOuterVarVec _outervalues;
-	SQInstructionVec _instructions;
+	static bool Load(SQVM *v,SQUserPointer up,SQREADFUNC read,SQObjectPtr &ret);
+
 	SQObjectPtr _sourcename;
 	SQObjectPtr _name;
-	SQLocalVarInfoVec _localvarinfos;
-	SQLineInfoVec _lineinfos;
     SQInteger _stacksize;
 	bool _bgenerator;
 	bool _varparams;
+
+	SQInteger _nlocalvarinfos;
+	SQLocalVarInfo *_localvarinfos;
+
+	SQInteger _nlineinfos;
+	SQLineInfo *_lineinfos;
+
+	SQInteger _nliterals;
+	SQObjectPtr *_literals;
+
+	SQInteger _nparameters;
+	SQObjectPtr *_parameters;
+	
+	SQInteger _nfunctions;
+	SQObjectPtr *_functions;
+
+	SQInteger _noutervalues;
+	SQOuterVar *_outervalues;
+
+	SQInteger _ndefaultparams;
+	SQInteger *_defaultparams;
+	
+	SQInteger _ninstructions;
+	SQInstruction _instructions[1];
 };
 
 #endif //_SQFUNCTION_H_
diff -rupwN ../dnl3/SqPlus/squirrel/sqfuncstate.cpp SqPlus/squirrel/sqfuncstate.cpp
--- ../dnl3/SqPlus/squirrel/sqfuncstate.cpp	2006-03-19 14:32:58.000000000 -0500
+++ SqPlus/squirrel/sqfuncstate.cpp	2008-01-25 14:36:45.000000000 -0500
@@ -14,6 +14,7 @@ SQInstructionDesc g_InstrDesc[]={
 	{_SC("_OP_LINE")},
 	{_SC("_OP_LOAD")},
 	{_SC("_OP_LOADINT")},
+	{_SC("_OP_LOADFLOAT")},
 	{_SC("_OP_DLOAD")},
 	{_SC("_OP_TAILCALL")},
 	{_SC("_OP_CALL")},
@@ -62,6 +63,7 @@ SQInstructionDesc g_InstrDesc[]={
 	{_SC("_OP_YIELD")},
 	{_SC("_OP_RESUME")},
 	{_SC("_OP_FOREACH")},
+	{_SC("_OP_POSTFOREACH")},
 	{_SC("_OP_DELEGATE")},
 	{_SC("_OP_CLONE")},
 	{_SC("_OP_TYPEOF")},
@@ -78,7 +80,8 @@ void DumpLiteral(SQObjectPtr &o)
 		case OT_STRING:	scprintf(_SC("\"%s\""),_stringval(o));break;
 		case OT_FLOAT: scprintf(_SC("{%f}"),_float(o));break;
 		case OT_INTEGER: scprintf(_SC("{%d}"),_integer(o));break;
-		default: assert(0); break; //shut up compiler
+		case OT_BOOL: scprintf(_SC("%s"),_integer(o)?_SC("true"):_SC("false"));break;
+		default: scprintf(_SC("(%s %p)"),GetTypeName(o),_rawval(o));break; break; //shut up compiler
 	}
 }
 
@@ -110,6 +113,7 @@ void SQFuncState::Error(const SQChar *er
 void SQFuncState::Dump(SQFunctionProto *func)
 {
 	SQUnsignedInteger n=0,i;
+	SQInteger si;
 	scprintf(_SC("SQInstruction sizeof %d\n"),sizeof(SQInstruction));
 	scprintf(_SC("SQObject sizeof %d\n"),sizeof(SQObject));
 	scprintf(_SC("--------------------------------------------------------------------\n"));
@@ -140,8 +144,8 @@ void SQFuncState::Dump(SQFunctionProto *
 		n++;
 	}
 	scprintf(_SC("-----LOCALS\n"));
-	for(i=0;i<func->_localvarinfos.size();i++){
-		SQLocalVarInfo lvi=func->_localvarinfos[i];
+	for(si=0;si<func->_nlocalvarinfos;si++){
+		SQLocalVarInfo lvi=func->_localvarinfos[si];
 		scprintf(_SC("[%d] %s \t%d %d\n"),lvi._pos,_stringval(lvi._name),lvi._start_op,lvi._end_op);
 		n++;
 	}
@@ -188,6 +192,9 @@ void SQFuncState::Dump(SQFunctionProto *
 			}
 			}
 		}
+		else if(inst.op==_OP_LOADFLOAT) {
+			scprintf(_SC("[%03d] %15s %d %f %d %d\n"),n,g_InstrDesc[inst.op].name,inst._arg0,*((SQFloat*)&inst._arg1),inst._arg2,inst._arg3);
+		}
 		else if(inst.op==_OP_ARITH){
 			scprintf(_SC("[%03d] %15s %d %d %d %c\n"),n,g_InstrDesc[inst.op].name,inst._arg0,inst._arg1,inst._arg2,inst._arg3);
 		}
@@ -304,6 +311,16 @@ void SQFuncState::SetStackSize(SQInteger
 	}
 }
 
+bool SQFuncState::IsConstant(const SQObject &name,SQObject &e)
+{
+	SQObjectPtr val;
+	if(_table(_sharedstate->_consts)->Get(name,val)) {
+		e = val;
+		return true;
+	}
+	return false;
+}
+
 bool SQFuncState::IsLocal(SQUnsignedInteger stkpos)
 {
 	if(stkpos>=_vlocals.size())return false;
@@ -486,10 +503,19 @@ SQObject SQFuncState::CreateString(const
 	return ns;
 }
 
+SQObject SQFuncState::CreateTable()
+{
+	SQObjectPtr nt(SQTable::Create(_sharedstate,0));
+	_table(_strings)->NewSlot(nt,(SQInteger)1);
+	return nt;
+}
+
 SQFunctionProto *SQFuncState::BuildProto()
 {
-	SQFunctionProto *f=SQFunctionProto::Create();
-	f->_literals.resize(_nliterals);
+	SQFunctionProto *f=SQFunctionProto::Create(_instructions.size(),
+		_nliterals,_parameters.size(),_functions.size(),_outervalues.size(),
+		_lineinfos.size(),_localvarinfos.size(),_defaultparams.size());
+
 	SQObjectPtr refidx,key,val;
 	SQInteger idx;
 
@@ -503,18 +529,15 @@ SQFunctionProto *SQFuncState::BuildProto
 		refidx=idx;
 	}
 
-	f->_functions.resize(_functions.size());
-	f->_functions.copy(_functions);
-	f->_parameters.resize(_parameters.size());
-	f->_parameters.copy(_parameters);
-	f->_outervalues.resize(_outervalues.size());
-	f->_outervalues.copy(_outervalues);
-	f->_instructions.resize(_instructions.size());
-	f->_instructions.copy(_instructions);
-	f->_localvarinfos.resize(_localvarinfos.size());
-	f->_localvarinfos.copy(_localvarinfos);
-	f->_lineinfos.resize(_lineinfos.size());
-	f->_lineinfos.copy(_lineinfos);
+	for(SQUnsignedInteger nf = 0; nf < _functions.size(); nf++) f->_functions[nf] = _functions[nf];
+	for(SQUnsignedInteger np = 0; np < _parameters.size(); np++) f->_parameters[np] = _parameters[np];
+	for(SQUnsignedInteger no = 0; no < _outervalues.size(); no++) f->_outervalues[no] = _outervalues[no];
+	for(SQUnsignedInteger no = 0; no < _localvarinfos.size(); no++) f->_localvarinfos[no] = _localvarinfos[no];
+	for(SQUnsignedInteger no = 0; no < _lineinfos.size(); no++) f->_lineinfos[no] = _lineinfos[no];
+	for(SQUnsignedInteger no = 0; no < _defaultparams.size(); no++) f->_defaultparams[no] = _defaultparams[no];
+
+	memcpy(f->_instructions,&_instructions[0],_instructions.size()*sizeof(SQInstruction));
+
 	f->_varparams = _varparams;
 
 	return f;
diff -rupwN ../dnl3/SqPlus/squirrel/sqfuncstate.h SqPlus/squirrel/sqfuncstate.h
--- ../dnl3/SqPlus/squirrel/sqfuncstate.h	2006-03-19 14:32:58.000000000 -0500
+++ SqPlus/squirrel/sqfuncstate.h	2007-10-14 16:13:16.000000000 -0400
@@ -22,6 +22,8 @@ struct SQFuncState
 	void PopInstructions(SQInteger size){for(SQInteger i=0;i<size;i++)_instructions.pop_back();}
 	void SetStackSize(SQInteger n);
 	void SnoozeOpt(){_optimization=false;}
+	void AddDefaultParam(SQInteger trg) { _defaultparams.push_back(trg); }
+	SQInteger GetDefaultParamCount() { return _defaultparams.size(); }
 	SQInteger GetCurrentPos(){return _instructions.size()-1;}
 	SQInteger GetNumericConstant(const SQInteger cons);
 	SQInteger GetNumericConstant(const SQFloat cons);
@@ -42,6 +44,8 @@ struct SQFuncState
 	SQInteger GetUpTarget(SQInteger n);
 	bool IsLocal(SQUnsignedInteger stkpos);
 	SQObject CreateString(const SQChar *s,SQInteger len = -1);
+	SQObject CreateTable();
+	bool IsConstant(const SQObject &name,SQObject &e);
 	SQInteger _returnexp;
 	SQLocalVarInfoVec _vlocals;
 	SQIntVec _targetstack;
@@ -64,6 +68,7 @@ struct SQFuncState
 	SQFuncState *_parent;
 	SQIntVec _breaktargets;
 	SQIntVec _continuetargets;
+	SQIntVec _defaultparams;
 	SQInteger _lastline;
 	SQInteger _traps; //contains number of nested exception traps
 	bool _optimization;
diff -rupwN ../dnl3/SqPlus/squirrel/sqlexer.cpp SqPlus/squirrel/sqlexer.cpp
--- ../dnl3/SqPlus/squirrel/sqlexer.cpp	2006-03-19 14:32:58.000000000 -0500
+++ SqPlus/squirrel/sqlexer.cpp	2008-02-17 04:16:15.000000000 -0500
@@ -66,6 +66,8 @@ void SQLexer::Init(SQSharedState *ss, SQ
 	ADD_KEYWORD(true,TK_TRUE);
 	ADD_KEYWORD(false,TK_FALSE);
 	ADD_KEYWORD(static,TK_STATIC);
+	ADD_KEYWORD(enum,TK_ENUM);
+	ADD_KEYWORD(const,TK_CONST);
 
 	_readf = rg;
 	_up = up;
@@ -372,7 +374,21 @@ void LexInteger(const SQChar *s,SQUnsign
 	}
 }
 
+SQInteger scisodigit(SQInteger c) { return c >= _SC('0') && c <= _SC('7'); }
+
+void LexOctal(const SQChar *s,SQUnsignedInteger *res)
+{
+	*res = 0;
+	while(*s != 0)
+	{
+		if(scisodigit(*s)) *res = (*res)*8+((*s++)-'0');
+		else { assert(0); }
+	}
+}
+
 SQInteger isexponent(SQInteger c) { return c == 'e' || c=='E'; }
+
+
 #define MAX_HEX_DIGITS (sizeof(SQInteger)*2)
 SQInteger SQLexer::ReadNumber()
 {
@@ -380,11 +396,21 @@ SQInteger SQLexer::ReadNumber()
 #define TFLOAT 2
 #define THEX 3
 #define TSCIENTIFIC 4
+#define TOCTAL 5
 	SQInteger type = TINT, firstchar = CUR_CHAR;
 	SQChar *sTemp;
 	INIT_TEMP_STRING();
 	NEXT();
-	if(firstchar == _SC('0') && toupper(CUR_CHAR) == _SC('X')) {
+	if(firstchar == _SC('0') && (toupper(CUR_CHAR) == _SC('X') || scisodigit(CUR_CHAR)) ) {
+		if(scisodigit(CUR_CHAR)) {
+			type = TOCTAL;
+			while(scisodigit(CUR_CHAR)) {
+				APPEND_CHAR(CUR_CHAR);
+				NEXT();
+			}
+			if(scisdigit(CUR_CHAR)) Error(_SC("invalid octal number"));
+		}
+		else {
 		NEXT();
 		type = THEX;
 		while(isxdigit(CUR_CHAR)) {
@@ -393,6 +419,7 @@ SQInteger SQLexer::ReadNumber()
 		}
 		if(_longstr.size() > MAX_HEX_DIGITS) Error(_SC("too many digits for an Hex number"));
 	}
+	}
 	else {
 		APPEND_CHAR((int)firstchar);
 		while (CUR_CHAR == _SC('.') || scisdigit(CUR_CHAR) || isexponent(CUR_CHAR)) {
@@ -425,6 +452,9 @@ SQInteger SQLexer::ReadNumber()
 	case THEX:
 		LexHexadecimal(&_longstr[0],(SQUnsignedInteger *)&_nvalue);
 		return TK_INTEGER;
+	case TOCTAL:
+		LexOctal(&_longstr[0],(SQUnsignedInteger *)&_nvalue);
+		return TK_INTEGER;
 	}
 	return 0;
 }
diff -rupwN ../dnl3/SqPlus/squirrel/sqlexer.h SqPlus/squirrel/sqlexer.h
--- ../dnl3/SqPlus/squirrel/sqlexer.h	2006-03-19 14:32:58.000000000 -0500
+++ SqPlus/squirrel/sqlexer.h	2007-10-16 13:18:23.000000000 -0400
@@ -2,7 +2,7 @@
 #ifndef _SQLEXER_H_
 #define _SQLEXER_H_
 
-#ifdef _UNICODE
+#ifdef SQUNICODE
 typedef SQChar LexChar;
 #else
 typedef	unsigned char LexChar;
diff -rupwN ../dnl3/SqPlus/squirrel/sqobject.cpp SqPlus/squirrel/sqobject.cpp
--- ../dnl3/SqPlus/squirrel/sqobject.cpp	2006-03-19 14:32:58.000000000 -0500
+++ SqPlus/squirrel/sqobject.cpp	2008-09-19 13:31:27.000000000 -0400
@@ -11,6 +11,40 @@
 #include "sqclass.h"
 #include "sqclosure.h"
 
+
+const SQChar *IdType2Name(SQObjectType type)
+{
+	switch(_RAW_TYPE(type))
+	{
+	case _RT_NULL:return _SC("null");
+	case _RT_INTEGER:return _SC("integer");
+	case _RT_FLOAT:return _SC("float");
+	case _RT_BOOL:return _SC("bool");
+	case _RT_STRING:return _SC("string");
+	case _RT_TABLE:return _SC("table");
+	case _RT_ARRAY:return _SC("array");
+	case _RT_GENERATOR:return _SC("generator");
+	case _RT_CLOSURE:
+	case _RT_NATIVECLOSURE:
+		return _SC("function");
+	case _RT_USERDATA:
+	case _RT_USERPOINTER:
+		return _SC("userdata");
+	case _RT_THREAD: return _SC("thread");
+	case _RT_FUNCPROTO: return _SC("function");
+	case _RT_CLASS: return _SC("class");
+	case _RT_INSTANCE: return _SC("instance");
+	case _RT_WEAKREF: return _SC("weakref");
+	default:
+		return NULL;
+	}
+}
+
+const SQChar *GetTypeName(const SQObjectPtr &obj1)
+{
+	return IdType2Name(type(obj1));	
+}
+
 SQString *SQString::Create(SQSharedState *ss,const SQChar *s,SQInteger len)
 {
 	SQString *str=ADD_STRING(ss,s,len);
@@ -83,6 +117,7 @@ bool SQDelegable::GetMetaMethod(SQVM *v,
 bool SQDelegable::SetDelegate(SQTable *mt)
 {
 	SQTable *temp = mt;
+	if(temp == this) return false;
 	while (temp) {
 		if (temp->_delegate == this) return false; //cycle detected
 		temp = temp->_delegate;
@@ -109,7 +144,7 @@ bool SQGenerator::Yield(SQVM *v)
 	for(SQInteger j = nvargs - 1; j >= 0; j--) {
 		_vargsstack.push_back(v->_vargsstack[vargsbase+j]);
 	}
-	_ci._generator=_null_;
+	_ci._generator=NULL;
 	for(SQInteger i=0;i<_ci._etraps;i++) {
 		_etraps.push_back(v->_etraps.top());
 		v->_etraps.pop_back();
@@ -127,9 +162,9 @@ bool SQGenerator::Resume(SQVM *v,SQInteg
 	PUSH_CALLINFO(v,_ci);
 	SQInteger oldstackbase=v->_stackbase;
 	v->_stackbase=v->_top;
-	v->ci->_target=target;
-	v->ci->_generator=SQObjectPtr(this);
-	v->ci->_vargs.size = _vargsstack.size();
+	v->ci->_target = (SQInt32)target;
+	v->ci->_generator = this;
+	v->ci->_vargs.size = (unsigned short)_vargsstack.size();
 	
 	for(SQInteger i=0;i<_ci._etraps;i++) {
 		v->_etraps.push_back(_etraps.top());
@@ -143,11 +178,14 @@ bool SQGenerator::Resume(SQVM *v,SQInteg
 		v->_vargsstack.push_back(_vargsstack.back());
 		_vargsstack.pop_back();
 	}
-	v->ci->_vargs.base = v->_vargsstack.size() - v->ci->_vargs.size;
+	v->ci->_vargs.base = (unsigned short)(v->_vargsstack.size() - v->ci->_vargs.size);
 	v->_top=v->_stackbase+size;
-	v->ci->_prevtop=prevtop;
-	v->ci->_prevstkbase=v->_stackbase-oldstackbase;
+	v->ci->_prevtop = (SQInt32)prevtop;
+	v->ci->_prevstkbase = (SQInt32)(v->_stackbase - oldstackbase);
 	_state=eRunning;
+	if (type(v->_debughook) != OT_NULL && _rawval(v->_debughook) != _rawval(v->ci->_closure))
+		v->CallDebugHook(_SC('c'));
+
 	return true;
 }
 
@@ -160,7 +198,7 @@ void SQArray::Extend(const SQArray *a){
 
 const SQChar* SQFunctionProto::GetLocal(SQVM *vm,SQUnsignedInteger stackbase,SQUnsignedInteger nseq,SQUnsignedInteger nop)
 {
-	SQUnsignedInteger nvars=_localvarinfos.size();
+	SQUnsignedInteger nvars=_nlocalvarinfos;
 	const SQChar *res=NULL; 
 	if(nvars>=nseq){
  		for(SQUnsignedInteger i=0;i<nvars;i++){
@@ -180,9 +218,9 @@ const SQChar* SQFunctionProto::GetLocal(
 
 SQInteger SQFunctionProto::GetLine(SQInstruction *curr)
 {
-	SQInteger op = (SQInteger)(curr-_instructions._vals);
+	SQInteger op = (SQInteger)(curr-_instructions);
 	SQInteger line=_lineinfos[0]._line;
-	for(SQUnsignedInteger i=1;i<_lineinfos.size();i++){
+	for(SQInteger i=1;i<_nlineinfos;i++){
 		if(_lineinfos[i]._op>=op)
 			return line;
 		line=_lineinfos[i]._line;
@@ -190,7 +228,6 @@ SQInteger SQFunctionProto::GetLine(SQIns
 	return line;
 }
 
-//#define _ERROR_TRAP() error_trap:
 #define _CHECK_IO(exp)  { if(!exp)return false; }
 bool SafeWrite(HSQUIRRELVM v,SQWRITEFUNC write,SQUserPointer up,SQUserPointer dest,SQInteger size)
 {
@@ -286,62 +323,72 @@ bool SQClosure::Save(SQVM *v,SQUserPoint
 	return true;
 }
 
-bool SQClosure::Load(SQVM *v,SQUserPointer up,SQREADFUNC read)
+bool SQClosure::Load(SQVM *v,SQUserPointer up,SQREADFUNC read,SQObjectPtr &ret)
 {
 	_CHECK_IO(CheckTag(v,read,up,SQ_CLOSURESTREAM_HEAD));
 	_CHECK_IO(CheckTag(v,read,up,sizeof(SQChar)));
-	_CHECK_IO(_funcproto(_function)->Load(v,up,read));
+	SQObjectPtr func;
+	_CHECK_IO(SQFunctionProto::Load(v,up,read,func));
 	_CHECK_IO(CheckTag(v,read,up,SQ_CLOSURESTREAM_TAIL));
+	ret = SQClosure::Create(_ss(v),_funcproto(func));
 	return true;
 }
 
 bool SQFunctionProto::Save(SQVM *v,SQUserPointer up,SQWRITEFUNC write)
 {
-	SQInteger i,nsize=_literals.size();
+	SQInteger i,nliterals = _nliterals,nparameters = _nparameters;
+	SQInteger noutervalues = _noutervalues,nlocalvarinfos = _nlocalvarinfos;
+	SQInteger nlineinfos=_nlineinfos,ninstructions = _ninstructions,nfunctions=_nfunctions;
+	SQInteger ndefaultparams = _ndefaultparams;
 	_CHECK_IO(WriteTag(v,write,up,SQ_CLOSURESTREAM_PART));
 	_CHECK_IO(WriteObject(v,up,write,_sourcename));
 	_CHECK_IO(WriteObject(v,up,write,_name));
 	_CHECK_IO(WriteTag(v,write,up,SQ_CLOSURESTREAM_PART));
-	_CHECK_IO(SafeWrite(v,write,up,&nsize,sizeof(nsize)));
-	for(i=0;i<nsize;i++){
+	_CHECK_IO(SafeWrite(v,write,up,&nliterals,sizeof(nliterals)));
+	_CHECK_IO(SafeWrite(v,write,up,&nparameters,sizeof(nparameters)));
+	_CHECK_IO(SafeWrite(v,write,up,&noutervalues,sizeof(noutervalues)));
+	_CHECK_IO(SafeWrite(v,write,up,&nlocalvarinfos,sizeof(nlocalvarinfos)));
+	_CHECK_IO(SafeWrite(v,write,up,&nlineinfos,sizeof(nlineinfos)));
+	_CHECK_IO(SafeWrite(v,write,up,&ndefaultparams,sizeof(ndefaultparams)));
+	_CHECK_IO(SafeWrite(v,write,up,&ninstructions,sizeof(ninstructions)));
+	_CHECK_IO(SafeWrite(v,write,up,&nfunctions,sizeof(nfunctions)));
+	_CHECK_IO(WriteTag(v,write,up,SQ_CLOSURESTREAM_PART));
+	for(i=0;i<nliterals;i++){
 		_CHECK_IO(WriteObject(v,up,write,_literals[i]));
 	}
+
 	_CHECK_IO(WriteTag(v,write,up,SQ_CLOSURESTREAM_PART));
-	nsize=_parameters.size();
-	_CHECK_IO(SafeWrite(v,write,up,&nsize,sizeof(nsize)));
-	for(i=0;i<nsize;i++){
+	for(i=0;i<nparameters;i++){
 		_CHECK_IO(WriteObject(v,up,write,_parameters[i]));
 	}
+
 	_CHECK_IO(WriteTag(v,write,up,SQ_CLOSURESTREAM_PART));
-	nsize=_outervalues.size();
-	_CHECK_IO(SafeWrite(v,write,up,&nsize,sizeof(nsize)));
-	for(i=0;i<nsize;i++){
+	for(i=0;i<noutervalues;i++){
 		_CHECK_IO(SafeWrite(v,write,up,&_outervalues[i]._type,sizeof(SQUnsignedInteger)));
 		_CHECK_IO(WriteObject(v,up,write,_outervalues[i]._src));
 		_CHECK_IO(WriteObject(v,up,write,_outervalues[i]._name));
 	}
+
 	_CHECK_IO(WriteTag(v,write,up,SQ_CLOSURESTREAM_PART));
-	nsize=_localvarinfos.size();
-	_CHECK_IO(SafeWrite(v,write,up,&nsize,sizeof(nsize)));
-	for(i=0;i<nsize;i++){
+	for(i=0;i<nlocalvarinfos;i++){
 		SQLocalVarInfo &lvi=_localvarinfos[i];
 		_CHECK_IO(WriteObject(v,up,write,lvi._name));
 		_CHECK_IO(SafeWrite(v,write,up,&lvi._pos,sizeof(SQUnsignedInteger)));
 		_CHECK_IO(SafeWrite(v,write,up,&lvi._start_op,sizeof(SQUnsignedInteger)));
 		_CHECK_IO(SafeWrite(v,write,up,&lvi._end_op,sizeof(SQUnsignedInteger)));
 	}
+
 	_CHECK_IO(WriteTag(v,write,up,SQ_CLOSURESTREAM_PART));
-	nsize=_lineinfos.size();
-	_CHECK_IO(SafeWrite(v,write,up,&nsize,sizeof(nsize)));
-	_CHECK_IO(SafeWrite(v,write,up,&_lineinfos[0],sizeof(SQLineInfo)*nsize));
+	_CHECK_IO(SafeWrite(v,write,up,_lineinfos,sizeof(SQLineInfo)*nlineinfos));
+
 	_CHECK_IO(WriteTag(v,write,up,SQ_CLOSURESTREAM_PART));
-	nsize=_instructions.size();
-	_CHECK_IO(SafeWrite(v,write,up,&nsize,sizeof(nsize)));
-	_CHECK_IO(SafeWrite(v,write,up,&_instructions[0],sizeof(SQInstruction)*nsize));
+	_CHECK_IO(SafeWrite(v,write,up,_defaultparams,sizeof(SQInteger)*ndefaultparams));
+
 	_CHECK_IO(WriteTag(v,write,up,SQ_CLOSURESTREAM_PART));
-	nsize=_functions.size();
-	_CHECK_IO(SafeWrite(v,write,up,&nsize,sizeof(nsize)));
-	for(i=0;i<nsize;i++){
+	_CHECK_IO(SafeWrite(v,write,up,_instructions,sizeof(SQInstruction)*ninstructions));
+
+	_CHECK_IO(WriteTag(v,write,up,SQ_CLOSURESTREAM_PART));
+	for(i=0;i<nfunctions;i++){
 		_CHECK_IO(_funcproto(_functions[i])->Save(v,up,write));
 	}
 	_CHECK_IO(SafeWrite(v,write,up,&_stacksize,sizeof(_stacksize)));
@@ -350,63 +397,85 @@ bool SQFunctionProto::Save(SQVM *v,SQUse
 	return true;
 }
 
-bool SQFunctionProto::Load(SQVM *v,SQUserPointer up,SQREADFUNC read)
+bool SQFunctionProto::Load(SQVM *v,SQUserPointer up,SQREADFUNC read,SQObjectPtr &ret)
 {
-	SQInteger i, nsize = _literals.size();
+	SQInteger i, nliterals,nparameters;
+	SQInteger noutervalues ,nlocalvarinfos ;
+	SQInteger nlineinfos,ninstructions ,nfunctions,ndefaultparams ;
+	SQObjectPtr sourcename, name;
 	SQObjectPtr o;
 	_CHECK_IO(CheckTag(v,read,up,SQ_CLOSURESTREAM_PART));
-	_CHECK_IO(ReadObject(v, up, read, _sourcename));
-	_CHECK_IO(ReadObject(v, up, read, _name));
+	_CHECK_IO(ReadObject(v, up, read, sourcename));
+	_CHECK_IO(ReadObject(v, up, read, name));
+	
 	_CHECK_IO(CheckTag(v,read,up,SQ_CLOSURESTREAM_PART));
-	_CHECK_IO(SafeRead(v,read,up, &nsize, sizeof(nsize)));
-	for(i = 0;i < nsize; i++){
+	_CHECK_IO(SafeRead(v,read,up, &nliterals, sizeof(nliterals)));
+	_CHECK_IO(SafeRead(v,read,up, &nparameters, sizeof(nparameters)));
+	_CHECK_IO(SafeRead(v,read,up, &noutervalues, sizeof(noutervalues)));
+	_CHECK_IO(SafeRead(v,read,up, &nlocalvarinfos, sizeof(nlocalvarinfos)));
+	_CHECK_IO(SafeRead(v,read,up, &nlineinfos, sizeof(nlineinfos)));
+	_CHECK_IO(SafeRead(v,read,up, &ndefaultparams, sizeof(ndefaultparams)));
+	_CHECK_IO(SafeRead(v,read,up, &ninstructions, sizeof(ninstructions)));
+	_CHECK_IO(SafeRead(v,read,up, &nfunctions, sizeof(nfunctions)));
+	
+
+	SQFunctionProto *f = SQFunctionProto::Create(ninstructions,nliterals,nparameters,
+			nfunctions,noutervalues,nlineinfos,nlocalvarinfos,ndefaultparams);
+	SQObjectPtr proto = f; //gets a ref in case of failure
+	f->_sourcename = sourcename;
+	f->_name = name;
+
+	_CHECK_IO(CheckTag(v,read,up,SQ_CLOSURESTREAM_PART));
+
+	for(i = 0;i < nliterals; i++){
 		_CHECK_IO(ReadObject(v, up, read, o));
-		_literals.push_back(o);
+		f->_literals[i] = o;
 	}
 	_CHECK_IO(CheckTag(v,read,up,SQ_CLOSURESTREAM_PART));
-	_CHECK_IO(SafeRead(v,read,up, &nsize, sizeof(nsize)));
-	for(i = 0; i < nsize; i++){
+
+	for(i = 0; i < nparameters; i++){
 		_CHECK_IO(ReadObject(v, up, read, o));
-		_parameters.push_back(o);
+		f->_parameters[i] = o;
 	}
 	_CHECK_IO(CheckTag(v,read,up,SQ_CLOSURESTREAM_PART));
-	_CHECK_IO(SafeRead(v,read,up,&nsize,sizeof(nsize)));
-	for(i = 0; i < nsize; i++){
+
+	for(i = 0; i < noutervalues; i++){
 		SQUnsignedInteger type;
 		SQObjectPtr name;
 		_CHECK_IO(SafeRead(v,read,up, &type, sizeof(SQUnsignedInteger)));
 		_CHECK_IO(ReadObject(v, up, read, o));
 		_CHECK_IO(ReadObject(v, up, read, name));
-		_outervalues.push_back(SQOuterVar(name,o, (SQOuterType)type));
+		f->_outervalues[i] = SQOuterVar(name,o, (SQOuterType)type);
 	}
 	_CHECK_IO(CheckTag(v,read,up,SQ_CLOSURESTREAM_PART));
-	_CHECK_IO(SafeRead(v,read,up,&nsize, sizeof(nsize)));
-	for(i = 0; i < nsize; i++){
+
+	for(i = 0; i < nlocalvarinfos; i++){
 		SQLocalVarInfo lvi;
 		_CHECK_IO(ReadObject(v, up, read, lvi._name));
 		_CHECK_IO(SafeRead(v,read,up, &lvi._pos, sizeof(SQUnsignedInteger)));
 		_CHECK_IO(SafeRead(v,read,up, &lvi._start_op, sizeof(SQUnsignedInteger)));
 		_CHECK_IO(SafeRead(v,read,up, &lvi._end_op, sizeof(SQUnsignedInteger)));
-		_localvarinfos.push_back(lvi);
+		f->_localvarinfos[i] = lvi;
 	}
 	_CHECK_IO(CheckTag(v,read,up,SQ_CLOSURESTREAM_PART));
-	_CHECK_IO(SafeRead(v,read,up, &nsize,sizeof(nsize)));
-	_lineinfos.resize(nsize);
-	_CHECK_IO(SafeRead(v,read,up, &_lineinfos[0], sizeof(SQLineInfo)*nsize));
+	_CHECK_IO(SafeRead(v,read,up, f->_lineinfos, sizeof(SQLineInfo)*nlineinfos));
+
+	_CHECK_IO(CheckTag(v,read,up,SQ_CLOSURESTREAM_PART));
+	_CHECK_IO(SafeRead(v,read,up, f->_defaultparams, sizeof(SQInteger)*ndefaultparams));
+
 	_CHECK_IO(CheckTag(v,read,up,SQ_CLOSURESTREAM_PART));
-	_CHECK_IO(SafeRead(v,read,up, &nsize, sizeof(nsize)));
-	_instructions.resize(nsize);
-	_CHECK_IO(SafeRead(v,read,up, &_instructions[0], sizeof(SQInstruction)*nsize));
+	_CHECK_IO(SafeRead(v,read,up, f->_instructions, sizeof(SQInstruction)*ninstructions));
+
 	_CHECK_IO(CheckTag(v,read,up,SQ_CLOSURESTREAM_PART));
-	_CHECK_IO(SafeRead(v,read,up, &nsize, sizeof(nsize)));
-	for(i = 0; i < nsize; i++){
-		o = SQFunctionProto::Create();
-		_CHECK_IO(_funcproto(o)->Load(v, up, read));
-		_functions.push_back(o);
-	}
-	_CHECK_IO(SafeRead(v,read,up, &_stacksize, sizeof(_stacksize)));
-	_CHECK_IO(SafeRead(v,read,up, &_bgenerator, sizeof(_bgenerator)));
-	_CHECK_IO(SafeRead(v,read,up, &_varparams, sizeof(_varparams)));
+	for(i = 0; i < nfunctions; i++){
+		_CHECK_IO(_funcproto(o)->Load(v, up, read, o));
+		f->_functions[i] = o;
+	}
+	_CHECK_IO(SafeRead(v,read,up, &f->_stacksize, sizeof(f->_stacksize)));
+	_CHECK_IO(SafeRead(v,read,up, &f->_bgenerator, sizeof(f->_bgenerator)));
+	_CHECK_IO(SafeRead(v,read,up, &f->_varparams, sizeof(f->_varparams)));
+	
+	ret = f;
 	return true;
 }
 
@@ -428,6 +497,7 @@ void SQVM::Mark(SQCollectable **chain)
 		SQSharedState::MarkObject(temp_reg, chain);
 		for(SQUnsignedInteger i = 0; i < _stack.size(); i++) SQSharedState::MarkObject(_stack[i], chain);
 		for(SQUnsignedInteger j = 0; j < _vargsstack.size(); j++) SQSharedState::MarkObject(_vargsstack[j], chain);
+		for(SQInteger k = 0; k < _callsstacksize; k++) SQSharedState::MarkObject(_callsstack[k]._closure, chain);
 	END_MARK()
 }
 
@@ -474,7 +544,8 @@ void SQInstance::Mark(SQCollectable **ch
 {
 	START_MARK()
 		_class->Mark(chain);
-		for(SQUnsignedInteger i =0; i< _nvalues; i++) {
+		SQUnsignedInteger nvalues = _class->_defaultvalues.size();
+		for(SQUnsignedInteger i =0; i< nvalues; i++) {
 			SQSharedState::MarkObject(_values[i], chain);
 		}
 	END_MARK()
@@ -493,6 +564,7 @@ void SQClosure::Mark(SQCollectable **cha
 {
 	START_MARK()
 		for(SQUnsignedInteger i = 0; i < _outervalues.size(); i++) SQSharedState::MarkObject(_outervalues[i], chain);
+		for(SQUnsignedInteger i = 0; i < _defaultparams.size(); i++) SQSharedState::MarkObject(_defaultparams[i], chain);
 	END_MARK()
 }
 
diff -rupwN ../dnl3/SqPlus/squirrel/sqobject.h SqPlus/squirrel/sqobject.h
--- ../dnl3/SqPlus/squirrel/sqobject.h	2006-03-19 14:32:58.000000000 -0500
+++ SqPlus/squirrel/sqobject.h	2007-10-14 16:38:20.000000000 -0400
@@ -258,9 +258,27 @@ struct SQObjectPtr : public SQObject
 	}
 	inline void Null()
 	{
-		__Release(_type,_unVal);
+		SQObjectType tOldType;
+		SQObjectValue unOldVal;
+		tOldType = _type;
+		unOldVal = _unVal;
 		_type=OT_NULL;
 		_unVal.pUserPointer=NULL;
+		__Release(tOldType,unOldVal);
+	}
+	inline SQObjectPtr& operator=(SQInteger i)
+	{ 
+		__Release(_type,_unVal);
+		_unVal.nInteger = i;
+		_type = OT_INTEGER;
+		return *this;
+	}
+	inline SQObjectPtr& operator=(SQFloat f)
+	{ 
+		__Release(_type,_unVal);
+		_unVal.fFloat = f;
+		_type = OT_FLOAT;
+		return *this;
 	}
 	inline SQObjectPtr& operator=(const SQObjectPtr& obj)
 	{ 
@@ -326,6 +344,9 @@ struct SQDelegable : public CHAINABLE_OB
 SQUnsignedInteger TranslateIndex(const SQObjectPtr &idx);
 typedef sqvector<SQObjectPtr> SQObjectPtrVec;
 typedef sqvector<SQInteger> SQIntVec;
+const SQChar *GetTypeName(const SQObjectPtr &obj1);
+const SQChar *IdType2Name(SQObjectType type);
+
 
 
 #endif //_SQOBJECT_H_
diff -rupwN ../dnl3/SqPlus/squirrel/sqopcodes.h SqPlus/squirrel/sqopcodes.h
--- ../dnl3/SqPlus/squirrel/sqopcodes.h	2006-03-19 14:32:58.000000000 -0500
+++ SqPlus/squirrel/sqopcodes.h	2007-03-11 14:30:09.000000000 -0400
@@ -7,7 +7,7 @@
 
 enum BitWiseOP {
 	BW_AND = 0,
-	BW_OR = 2,	//like ADD
+	BW_OR = 2,	
 	BW_XOR = 3,
 	BW_SHIFTL = 4,
 	BW_SHIFTR = 5,
@@ -16,7 +16,7 @@ enum BitWiseOP {
 
 enum CmpOP {
 	CMP_G = 0,
-	CMP_GE = 2,	//like ADD
+	CMP_GE = 2,	
 	CMP_L = 3,
 	CMP_LE = 4
 };
@@ -25,62 +25,64 @@ enum SQOpcode
 	_OP_LINE=				0x00,	
 	_OP_LOAD=				0x01,
 	_OP_LOADINT=			0x02,
-	_OP_DLOAD=				0x03,
-	_OP_TAILCALL=			0x04,	
-	_OP_CALL=				0x05,	
-	_OP_PREPCALL=			0x06,	
-	_OP_PREPCALLK=			0x07,	
-	_OP_GETK=				0x08,	
-	_OP_MOVE=				0x09,	
-	_OP_NEWSLOT=			0x0A,	
-	_OP_DELETE=				0x0B,	
-	_OP_SET=				0x0C,	
-	_OP_GET=				0x0D,
-	_OP_EQ=					0x0E,
-	_OP_NE=					0x0F,
-	_OP_ARITH=				0x10,
-	_OP_BITW=				0x11,
-	_OP_RETURN=				0x12,	
-	_OP_LOADNULLS=			0x13,	
-	_OP_LOADROOTTABLE=		0x14,
-	_OP_LOADBOOL=			0x15,
-	_OP_DMOVE=				0x16,	
-	_OP_JMP=				0x17,	
-	_OP_JNZ=				0x18,	
-	_OP_JZ=					0x19,	
-	_OP_LOADFREEVAR=		0x1A,	
-	_OP_VARGC=				0x1B,	
-	_OP_GETVARGV=			0x1C,	
-	_OP_NEWTABLE=			0x1D,	
-	_OP_NEWARRAY=			0x1E,	
-	_OP_APPENDARRAY=		0x1F,	
-	_OP_GETPARENT=			0x20,	
-	_OP_COMPARITH=			0x21,	
-	_OP_COMPARITHL=			0x22,	
-	_OP_INC=				0x23,	
-	_OP_INCL=				0x24,	
-	_OP_PINC=				0x25,	
-	_OP_PINCL=				0x26,	
-	_OP_CMP=				0x27,
-	_OP_EXISTS=				0x28,	
-	_OP_INSTANCEOF=			0x29,
-	_OP_AND=				0x2A,
-	_OP_OR=					0x2B,
-	_OP_NEG=				0x2C,
-	_OP_NOT=				0x2D,
-	_OP_BWNOT=				0x2E,	
-	_OP_CLOSURE=			0x2F,	
-	_OP_YIELD=				0x30,	
-	_OP_RESUME=				0x31,
-	_OP_FOREACH=			0x32,
-	_OP_DELEGATE=			0x33,
-	_OP_CLONE=				0x34,
-	_OP_TYPEOF=				0x35,
-	_OP_PUSHTRAP=			0x36,
-	_OP_POPTRAP=			0x37,
-	_OP_THROW=				0x38,
-	_OP_CLASS=				0x39,
-	_OP_NEWSLOTA=			0x3A
+	_OP_LOADFLOAT=			0x03,
+	_OP_DLOAD=				0x04,
+	_OP_TAILCALL=			0x05,	
+	_OP_CALL=				0x06,	
+	_OP_PREPCALL=			0x07,	
+	_OP_PREPCALLK=			0x08,	
+	_OP_GETK=				0x09,	
+	_OP_MOVE=				0x0A,	
+	_OP_NEWSLOT=			0x0B,	
+	_OP_DELETE=				0x0C,	
+	_OP_SET=				0x0D,	
+	_OP_GET=				0x0E,
+	_OP_EQ=					0x0F,
+	_OP_NE=					0x10,
+	_OP_ARITH=				0x11,
+	_OP_BITW=				0x12,
+	_OP_RETURN=				0x13,	
+	_OP_LOADNULLS=			0x14,	
+	_OP_LOADROOTTABLE=		0x15,
+	_OP_LOADBOOL=			0x16,
+	_OP_DMOVE=				0x17,	
+	_OP_JMP=				0x18,	
+	_OP_JNZ=				0x19,	
+	_OP_JZ=					0x1A,	
+	_OP_LOADFREEVAR=		0x1B,	
+	_OP_VARGC=				0x1C,	
+	_OP_GETVARGV=			0x1D,	
+	_OP_NEWTABLE=			0x1E,	
+	_OP_NEWARRAY=			0x1F,	
+	_OP_APPENDARRAY=		0x20,	
+	_OP_GETPARENT=			0x21,	
+	_OP_COMPARITH=			0x22,	
+	_OP_COMPARITHL=			0x23,	
+	_OP_INC=				0x24,	
+	_OP_INCL=				0x25,	
+	_OP_PINC=				0x26,	
+	_OP_PINCL=				0x27,	
+	_OP_CMP=				0x28,
+	_OP_EXISTS=				0x29,	
+	_OP_INSTANCEOF=			0x2A,
+	_OP_AND=				0x2B,
+	_OP_OR=					0x2C,
+	_OP_NEG=				0x2D,
+	_OP_NOT=				0x2E,
+	_OP_BWNOT=				0x2F,	
+	_OP_CLOSURE=			0x30,	
+	_OP_YIELD=				0x31,	
+	_OP_RESUME=				0x32,
+	_OP_FOREACH=			0x33,
+	_OP_POSTFOREACH=		0x34,
+	_OP_DELEGATE=			0x35,
+	_OP_CLONE=				0x36,
+	_OP_TYPEOF=				0x37,
+	_OP_PUSHTRAP=			0x38,
+	_OP_POPTRAP=			0x39,
+	_OP_THROW=				0x3A,
+	_OP_CLASS=				0x3B,
+	_OP_NEWSLOTA=			0x3C,
 };							  
 
 struct SQInstructionDesc {	  
diff -rupwN ../dnl3/SqPlus/squirrel/sqstate.cpp SqPlus/squirrel/sqstate.cpp
--- ../dnl3/SqPlus/squirrel/sqstate.cpp	2006-03-19 14:32:58.000000000 -0500
+++ SqPlus/squirrel/sqstate.cpp	2008-02-09 16:17:46.000000000 -0500
@@ -145,6 +145,7 @@ void SQSharedState::Init()
 
 	_constructoridx = SQString::Create(this,_SC("constructor"));
 	_registry = SQTable::Create(this,0);
+	_consts = SQTable::Create(this,0);
 	_table_default_delegate=CreateDefaultDelegate(this,_table_default_delegate_funcz);
 	_array_default_delegate=CreateDefaultDelegate(this,_array_default_delegate_funcz);
 	_string_default_delegate=CreateDefaultDelegate(this,_string_default_delegate_funcz);
@@ -161,11 +162,11 @@ void SQSharedState::Init()
 SQSharedState::~SQSharedState()
 {
 	_constructoridx = _null_;
-	_refs_table.Finalize();
 	_table(_registry)->Finalize();
+	_table(_consts)->Finalize();
 	_table(_metamethodsmap)->Finalize();
-//	_refs_table = _null_;
 	_registry = _null_;
+	_consts = _null_;
 	_metamethodsmap = _null_;
 	while(!_systemstrings->empty()){
 		_systemstrings->back()=_null_;
@@ -183,10 +184,8 @@ SQSharedState::~SQSharedState()
 	_class_default_delegate=_null_;
 	_instance_default_delegate=_null_;
 	_weakref_default_delegate=_null_;
-	
+	_refs_table.Finalize();
 #ifndef NO_GARBAGE_COLLECTOR
-	
-	
 	SQCollectable *t=_gc_chain;
 	SQCollectable *nx=NULL;
 	while(t){
@@ -203,6 +202,7 @@ SQSharedState::~SQSharedState()
 		_gc_chain->Release();
 	}
 #endif
+
 	sq_delete(_types,SQObjectPtrVec);
 	sq_delete(_systemstrings,SQObjectPtrVec);
 	sq_delete(_metamethods,SQObjectPtrVec);
@@ -251,6 +251,7 @@ SQInteger SQSharedState::CollectGarbage(
 	SQInteger x = _table(_thread(_root_vm)->_roottable)->CountUsed();
 	_refs_table.Mark(&tchain);
 	MarkObject(_registry,&tchain);
+	MarkObject(_consts,&tchain);
 	MarkObject(_metamethodsmap,&tchain);
 	MarkObject(_table_default_delegate,&tchain);
 	MarkObject(_array_default_delegate,&tchain);
@@ -332,7 +333,7 @@ RefTable::RefTable()
 
 void RefTable::Finalize()
 {
-	RefNode *nodes = (RefNode *)&_buckets[_numofslots];
+	RefNode *nodes = _nodes;
 	for(SQUnsignedInteger n = 0; n < _numofslots; n++) {
 		nodes->obj = _null_;
 		nodes++;
@@ -341,12 +342,13 @@ void RefTable::Finalize()
 
 RefTable::~RefTable()
 {
-	SQ_FREE(_buckets,_buffersize);
+	SQ_FREE(_buckets,(_numofslots * sizeof(RefNode *)) + (_numofslots * sizeof(RefNode)));
 }
+
 #ifndef NO_GARBAGE_COLLECTOR
 void RefTable::Mark(SQCollectable **chain)
 {
-	RefNode *nodes = (RefNode *)&_buckets[_numofslots];
+	RefNode *nodes = (RefNode *)_nodes;
 	for(SQUnsignedInteger n = 0; n < _numofslots; n++) {
 		if(type(nodes->obj) != OT_NULL) {
 			SQSharedState::MarkObject(nodes->obj,chain);
@@ -355,6 +357,7 @@ void RefTable::Mark(SQCollectable **chai
 	}
 }
 #endif
+
 void RefTable::AddRef(SQObject &obj)
 {
 	SQHash mainpos;
@@ -370,7 +373,7 @@ SQBool RefTable::Release(SQObject &obj)
 	RefNode *ref = Get(obj,mainpos,&prev,false);
 	if(ref) {
 		if(--ref->refs == 0) {
-			ref->obj = _null_;
+			SQObjectPtr o = ref->obj;
 			if(prev) {
 				prev->next = ref->next;
 			}
@@ -380,32 +383,38 @@ SQBool RefTable::Release(SQObject &obj)
 			ref->next = _freelist;
 			_freelist = ref;
 			_slotused--;
+			ref->obj = _null_;
 			//<<FIXME>>test for shrink?
 			return SQTrue;
 		}
 	}
+	else {
+		assert(0);
+	}
 	return SQFalse;
 }
 
 void RefTable::Resize(SQUnsignedInteger size)
 {
-	RefNode **oldbuffer = _buckets;
-	RefNode *oldnodes = (RefNode *)&_buckets[_numofslots];
+	RefNode **oldbucks = _buckets;
+	RefNode *t = _nodes;
 	SQUnsignedInteger oldnumofslots = _numofslots;
-	SQUnsignedInteger oldbuffersize = _buffersize;
 	AllocNodes(size);
 	//rehash
+	SQUnsignedInteger nfound = 0;
 	for(SQUnsignedInteger n = 0; n < oldnumofslots; n++) {
-		if(type(oldnodes->obj) != OT_NULL) {
+		if(type(t->obj) != OT_NULL) {
 			//add back;
-			assert(oldnodes->refs != 0);
-			RefNode *nn = Add(::HashObj(oldnodes->obj)&(_numofslots-1),oldnodes->obj);
-			nn->refs = oldnodes->refs; 
-			oldnodes->obj = _null_;
+			assert(t->refs != 0);
+			RefNode *nn = Add(::HashObj(t->obj)&(_numofslots-1),t->obj);
+			nn->refs = t->refs; 
+			t->obj = _null_;
+			nfound++;
 		}
-		oldnodes++;
+		t++;
 	}
-	SQ_FREE(oldbuffer,oldbuffersize);
+	assert(nfound == oldnumofslots);
+	SQ_FREE(oldbucks,(oldnumofslots * sizeof(RefNode *)) + (oldnumofslots * sizeof(RefNode)));
 }
 
 RefTable::RefNode *RefTable::Add(SQHash mainpos,SQObject &obj)
@@ -434,7 +443,9 @@ RefTable::RefNode *RefTable::Get(SQObjec
 	}
 	if(ref == NULL && add) {
 		if(_numofslots == _slotused) {
+			assert(_freelist == 0);
 			Resize(_numofslots*2);
+			mainpos = ::HashObj(obj)&(_numofslots-1);
 		}
 		ref = Add(mainpos,obj);
 	}
@@ -444,11 +455,10 @@ RefTable::RefNode *RefTable::Get(SQObjec
 void RefTable::AllocNodes(SQUnsignedInteger size)
 {
 	RefNode **bucks;
-	RefNode *firstnode;
-	_buffersize = size * sizeof(RefNode *) + size * sizeof(RefNode);
-	bucks = (RefNode **)SQ_MALLOC(_buffersize);
-	firstnode = (RefNode *)&bucks[size];
-	RefNode *temp = firstnode;
+	RefNode *nodes;
+	bucks = (RefNode **)SQ_MALLOC((size * sizeof(RefNode *)) + (size * sizeof(RefNode)));
+	nodes = (RefNode *)&bucks[size];
+	RefNode *temp = nodes;
 	SQUnsignedInteger n;
 	for(n = 0; n < size - 1; n++) {
 		bucks[n] = NULL;
@@ -461,7 +471,8 @@ void RefTable::AllocNodes(SQUnsignedInte
 	temp->refs = 0;
 	new (&temp->obj) SQObjectPtr;
 	temp->next = NULL;
-	_freelist = firstnode;
+	_freelist = nodes;
+	_nodes = nodes;
 	_buckets = bucks;
 	_slotused = 0;
 	_numofslots = size;
@@ -489,7 +500,6 @@ StringTable::~StringTable()
 void StringTable::AllocNodes(SQInteger size)
 {
 	_numofslots=size;
-	//_slotused=0;
 	_strings=(SQString**)SQ_MALLOC(sizeof(SQString*)*_numofslots);
 	memset(_strings,0,sizeof(SQString*)*_numofslots);
 }
diff -rupwN ../dnl3/SqPlus/squirrel/sqstate.h SqPlus/squirrel/sqstate.h
--- ../dnl3/SqPlus/squirrel/sqstate.h	2006-03-19 14:32:58.000000000 -0500
+++ SqPlus/squirrel/sqstate.h	2007-10-14 16:21:35.000000000 -0400
@@ -44,7 +44,7 @@ private:
 	void AllocNodes(SQUnsignedInteger size);
 	SQUnsignedInteger _numofslots;
 	SQUnsignedInteger _slotused;
-	SQUnsignedInteger _buffersize;
+	RefNode *_nodes;
 	RefNode *_freelist;
 	RefNode **_buckets;
 };
@@ -73,6 +73,7 @@ public:
 	StringTable *_stringtable;
 	RefTable _refs_table;
 	SQObjectPtr _registry;
+	SQObjectPtr _consts;
 	SQObjectPtr _constructoridx;
 #ifndef NO_GARBAGE_COLLECTOR
 	SQCollectable *_gc_chain;
diff -rupwN ../dnl3/SqPlus/squirrel/sqtable.cpp SqPlus/squirrel/sqtable.cpp
--- ../dnl3/SqPlus/squirrel/sqtable.cpp	2006-03-19 14:32:58.000000000 -0500
+++ SqPlus/squirrel/sqtable.cpp	2007-07-29 09:47:24.000000000 -0400
@@ -177,8 +177,20 @@ bool SQTable::Set(const SQObjectPtr &key
 	return false;
 }
 
-void SQTable::Finalize()
+void SQTable::_ClearNodes()
 {
 	for(SQInteger i = 0;i < _numofnodes; i++) { _nodes[i].key = _null_; _nodes[i].val = _null_; }
+}
+
+void SQTable::Finalize()
+{
+	_ClearNodes();
 		SetDelegate(NULL);
 }
+
+void SQTable::Clear()
+{
+	_ClearNodes();
+	_usednodes = 0;
+	Rehash(true);
+}
diff -rupwN ../dnl3/SqPlus/squirrel/sqtable.h SqPlus/squirrel/sqtable.h
--- ../dnl3/SqPlus/squirrel/sqtable.h	2006-03-19 14:32:58.000000000 -0500
+++ SqPlus/squirrel/sqtable.h	2006-12-16 09:48:08.000000000 -0500
@@ -41,6 +41,7 @@ private:
 	void AllocNodes(SQInteger nSize);
 	void Rehash(bool force);
 	SQTable(SQSharedState *ss, SQInteger nInitialSize);
+	void _ClearNodes();
 public:
 	static SQTable* Create(SQSharedState *ss,SQInteger nInitialSize)
 	{
@@ -79,6 +80,7 @@ public:
 	SQInteger Next(bool getweakrefs,const SQObjectPtr &refpos, SQObjectPtr &outkey, SQObjectPtr &outval);
 	
 	SQInteger CountUsed(){ return _usednodes;}
+	void Clear();
 	void Release()
 	{
 		sq_delete(this, SQTable);
diff -rupwN ../dnl3/SqPlus/squirrel/squirrel71.vcproj SqPlus/squirrel/squirrel71.vcproj
--- ../dnl3/SqPlus/squirrel/squirrel71.vcproj	2006-05-29 15:10:46.000000000 -0400
+++ SqPlus/squirrel/squirrel71.vcproj	1969-12-31 19:00:00.000000000 -0500
@@ -1,750 +0,0 @@
-<?xml version="1.0" encoding="Windows-1252"?>
-<VisualStudioProject
-	ProjectType="Visual C++"
-	Version="7.10"
-	Name="squirrel"
-	ProjectGUID="{D2EB28F5-6B67-4823-8051-B564EF852CED}"
-	RootNamespace="squirrel"
-	SccProjectName=""
-	SccLocalPath="..">
-	<Platforms>
-		<Platform
-			Name="Win32"/>
-	</Platforms>
-	<Configurations>
-		<Configuration
-			Name="Debug|Win32"
-			OutputDirectory="$(ConfigurationName)"
-			IntermediateDirectory="$(ConfigurationName)"
-			ConfigurationType="4"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="FALSE"
-			CharacterSet="2">
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="..\include"
-				PreprocessorDefinitions="WIN32;_DEBUG;_LIB;GARBAGE_COLLECTOR"
-				BasicRuntimeChecks="3"
-				RuntimeLibrary="1"
-				UsePrecompiledHeader="0"
-				PrecompiledHeaderFile=".\Debug/squirrel.pch"
-				AssemblerListingLocation="$(IntDir)/"
-				ObjectFile="$(IntDir)/"
-				ProgramDataBaseFileName="$(IntDir)/"
-				WarningLevel="3"
-				SuppressStartupBanner="TRUE"
-				DebugInformationFormat="4"
-				CompileAs="0"/>
-			<Tool
-				Name="VCCustomBuildTool"/>
-			<Tool
-				Name="VCLibrarianTool"
-				OutputFile="..\lib\squirrelD.lib"
-				SuppressStartupBanner="TRUE"/>
-			<Tool
-				Name="VCMIDLTool"/>
-			<Tool
-				Name="VCPostBuildEventTool"/>
-			<Tool
-				Name="VCPreBuildEventTool"/>
-			<Tool
-				Name="VCPreLinkEventTool"/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="_DEBUG"
-				Culture="1040"/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"/>
-			<Tool
-				Name="VCManagedWrapperGeneratorTool"/>
-			<Tool
-				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
-		</Configuration>
-		<Configuration
-			Name="Release|Win32"
-			OutputDirectory="$(ConfigurationName)"
-			IntermediateDirectory="$(ConfigurationName)"
-			ConfigurationType="4"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="FALSE"
-			CharacterSet="2">
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="2"
-				InlineFunctionExpansion="1"
-				AdditionalIncludeDirectories="..\include"
-				PreprocessorDefinitions="WIN32;NDEBUG;_LIB;GARBAGE_COLLECTOR"
-				StringPooling="TRUE"
-				RuntimeLibrary="0"
-				EnableFunctionLevelLinking="TRUE"
-				UsePrecompiledHeader="0"
-				PrecompiledHeaderFile=".\Release/squirrel.pch"
-				AssemblerListingLocation="$(IntDir)/"
-				ObjectFile="$(IntDir)/"
-				ProgramDataBaseFileName="$(IntDir)/"
-				WarningLevel="3"
-				SuppressStartupBanner="TRUE"
-				CompileAs="0"/>
-			<Tool
-				Name="VCCustomBuildTool"/>
-			<Tool
-				Name="VCLibrarianTool"
-				OutputFile="..\lib\squirrel.lib"
-				SuppressStartupBanner="TRUE"/>
-			<Tool
-				Name="VCMIDLTool"/>
-			<Tool
-				Name="VCPostBuildEventTool"/>
-			<Tool
-				Name="VCPreBuildEventTool"/>
-			<Tool
-				Name="VCPreLinkEventTool"/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="NDEBUG"
-				Culture="1040"/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"/>
-			<Tool
-				Name="VCManagedWrapperGeneratorTool"/>
-			<Tool
-				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
-		</Configuration>
-		<Configuration
-			Name="Debug - Unicode|Win32"
-			OutputDirectory="$(ConfigurationName)"
-			IntermediateDirectory="$(ConfigurationName)"
-			ConfigurationType="4"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="FALSE"
-			CharacterSet="1">
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="..\include"
-				PreprocessorDefinitions="WIN32;_DEBUG;_LIB;GARBAGE_COLLECTOR"
-				BasicRuntimeChecks="3"
-				RuntimeLibrary="1"
-				UsePrecompiledHeader="0"
-				PrecompiledHeaderFile=".\DebugU/squirrel.pch"
-				AssemblerListingLocation="$(IntDir)/"
-				ObjectFile="$(IntDir)/"
-				ProgramDataBaseFileName="$(IntDir)/"
-				WarningLevel="3"
-				SuppressStartupBanner="TRUE"
-				DebugInformationFormat="4"
-				CompileAs="0"/>
-			<Tool
-				Name="VCCustomBuildTool"/>
-			<Tool
-				Name="VCLibrarianTool"
-				OutputFile="..\lib\squirrelDU.lib"
-				SuppressStartupBanner="TRUE"/>
-			<Tool
-				Name="VCMIDLTool"/>
-			<Tool
-				Name="VCPostBuildEventTool"/>
-			<Tool
-				Name="VCPreBuildEventTool"/>
-			<Tool
-				Name="VCPreLinkEventTool"/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="_DEBUG"
-				Culture="1040"/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"/>
-			<Tool
-				Name="VCManagedWrapperGeneratorTool"/>
-			<Tool
-				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
-		</Configuration>
-		<Configuration
-			Name="Release - Unicode|Win32"
-			OutputDirectory="$(ConfigurationName)"
-			IntermediateDirectory="$(ConfigurationName)"
-			ConfigurationType="4"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="FALSE"
-			CharacterSet="1">
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="2"
-				InlineFunctionExpansion="1"
-				AdditionalIncludeDirectories="..\include"
-				PreprocessorDefinitions="WIN32;NDEBUG;_LIB;GARBAGE_COLLECTOR"
-				StringPooling="TRUE"
-				RuntimeLibrary="0"
-				EnableFunctionLevelLinking="TRUE"
-				UsePrecompiledHeader="0"
-				PrecompiledHeaderFile=".\Release/squirrel.pch"
-				AssemblerListingLocation="$(IntDir)/"
-				ObjectFile="$(IntDir)/"
-				ProgramDataBaseFileName="$(IntDir)/"
-				WarningLevel="3"
-				SuppressStartupBanner="TRUE"
-				CompileAs="0"/>
-			<Tool
-				Name="VCCustomBuildTool"/>
-			<Tool
-				Name="VCLibrarianTool"
-				OutputFile="..\lib\squirrelU.lib"
-				SuppressStartupBanner="TRUE"/>
-			<Tool
-				Name="VCMIDLTool"/>
-			<Tool
-				Name="VCPostBuildEventTool"/>
-			<Tool
-				Name="VCPreBuildEventTool"/>
-			<Tool
-				Name="VCPreLinkEventTool"/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="NDEBUG"
-				Culture="1040"/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"/>
-			<Tool
-				Name="VCManagedWrapperGeneratorTool"/>
-			<Tool
-				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
-		</Configuration>
-	</Configurations>
-	<References>
-	</References>
-	<Files>
-		<Filter
-			Name="Source Files"
-			Filter="cpp;c;cxx;rc;def;r;odl;idl;hpj;bat">
-			<File
-				RelativePath="sqapi.cpp">
-				<FileConfiguration
-					Name="Debug|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"
-						PrecompiledHeaderThrough="stdafx.h"/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug - Unicode|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"
-						PrecompiledHeaderThrough="stdafx.h"/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release - Unicode|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""/>
-				</FileConfiguration>
-			</File>
-			<File
-				RelativePath="sqbaselib.cpp">
-				<FileConfiguration
-					Name="Debug|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"
-						PrecompiledHeaderThrough="stdafx.h"/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug - Unicode|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"
-						PrecompiledHeaderThrough="stdafx.h"/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release - Unicode|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""/>
-				</FileConfiguration>
-			</File>
-			<File
-				RelativePath="sqclass.cpp">
-				<FileConfiguration
-					Name="Debug|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"
-						PrecompiledHeaderThrough="stdafx.h"/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug - Unicode|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"
-						PrecompiledHeaderThrough="stdafx.h"/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release - Unicode|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""/>
-				</FileConfiguration>
-			</File>
-			<File
-				RelativePath="sqcompiler.cpp">
-				<FileConfiguration
-					Name="Debug|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"
-						PrecompiledHeaderThrough="stdafx.h"/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug - Unicode|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"
-						PrecompiledHeaderThrough="stdafx.h"/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release - Unicode|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""/>
-				</FileConfiguration>
-			</File>
-			<File
-				RelativePath="sqdebug.cpp">
-				<FileConfiguration
-					Name="Debug|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"
-						PrecompiledHeaderThrough="stdafx.h"/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug - Unicode|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"
-						PrecompiledHeaderThrough="stdafx.h"/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release - Unicode|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""/>
-				</FileConfiguration>
-			</File>
-			<File
-				RelativePath="sqfuncstate.cpp">
-				<FileConfiguration
-					Name="Debug|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"
-						PrecompiledHeaderThrough="stdafx.h"/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug - Unicode|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"
-						PrecompiledHeaderThrough="stdafx.h"/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release - Unicode|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""/>
-				</FileConfiguration>
-			</File>
-			<File
-				RelativePath="sqlexer.cpp">
-				<FileConfiguration
-					Name="Debug|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"
-						PrecompiledHeaderThrough="stdafx.h"/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug - Unicode|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"
-						PrecompiledHeaderThrough="stdafx.h"/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release - Unicode|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""/>
-				</FileConfiguration>
-			</File>
-			<File
-				RelativePath="sqmem.cpp">
-				<FileConfiguration
-					Name="Debug|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug - Unicode|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release - Unicode|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""/>
-				</FileConfiguration>
-			</File>
-			<File
-				RelativePath="sqobject.cpp">
-				<FileConfiguration
-					Name="Debug|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"
-						PrecompiledHeaderThrough="stdafx.h"/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug - Unicode|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"
-						PrecompiledHeaderThrough="stdafx.h"/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release - Unicode|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""/>
-				</FileConfiguration>
-			</File>
-			<File
-				RelativePath="sqstate.cpp">
-				<FileConfiguration
-					Name="Debug|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"
-						PrecompiledHeaderThrough="stdafx.h"/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug - Unicode|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"
-						PrecompiledHeaderThrough="stdafx.h"/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release - Unicode|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""/>
-				</FileConfiguration>
-			</File>
-			<File
-				RelativePath="sqtable.cpp">
-				<FileConfiguration
-					Name="Debug|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"
-						PrecompiledHeaderThrough="stdafx.h"/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug - Unicode|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"
-						PrecompiledHeaderThrough="stdafx.h"/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release - Unicode|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""/>
-				</FileConfiguration>
-			</File>
-			<File
-				RelativePath="sqvm.cpp">
-				<FileConfiguration
-					Name="Debug|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"
-						PrecompiledHeaderThrough="stdafx.h"/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug - Unicode|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"
-						PrecompiledHeaderThrough="stdafx.h"/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release - Unicode|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""/>
-				</FileConfiguration>
-			</File>
-		</Filter>
-		<Filter
-			Name="Header Files"
-			Filter="h;hpp;hxx;hm;inl">
-			<File
-				RelativePath="sqarray.h">
-			</File>
-			<File
-				RelativePath="sqclass.h">
-			</File>
-			<File
-				RelativePath="sqclosure.h">
-			</File>
-			<File
-				RelativePath="sqcompiler.h">
-			</File>
-			<File
-				RelativePath="sqfuncproto.h">
-			</File>
-			<File
-				RelativePath="sqfuncstate.h">
-			</File>
-			<File
-				RelativePath="sqlexer.h">
-			</File>
-			<File
-				RelativePath="sqobject.h">
-			</File>
-			<File
-				RelativePath="sqopcodes.h">
-			</File>
-			<File
-				RelativePath="sqpcheader.h">
-			</File>
-			<File
-				RelativePath="sqstate.h">
-			</File>
-			<File
-				RelativePath="sqstring.h">
-			</File>
-			<File
-				RelativePath="sqtable.h">
-			</File>
-			<File
-				RelativePath="squserdata.h">
-			</File>
-			<File
-				RelativePath="squtils.h">
-			</File>
-			<File
-				RelativePath="sqvm.h">
-			</File>
-		</Filter>
-	</Files>
-	<Globals>
-	</Globals>
-</VisualStudioProject>
diff -rupwN ../dnl3/SqPlus/squirrel/squirrel.cbp SqPlus/squirrel/squirrel.cbp
--- ../dnl3/SqPlus/squirrel/squirrel.cbp	2006-04-25 17:05:30.000000000 -0400
+++ SqPlus/squirrel/squirrel.cbp	1969-12-31 19:00:00.000000000 -0500
@@ -1,324 +0,0 @@
-<?xml version="1.0"?>
-<!DOCTYPE CodeBlocks_project_file>
-<CodeBlocks_project_file>
-	<FileVersion major="1" minor="1"/>
-	<Project>
-		<Option title="squirrel"/>
-		<Option makefile="Makefile"/>
-		<Option makefile_is_custom="0"/>
-		<Option default_target="-1"/>
-		<Option compiler="0"/>
-		<Build>
-			<Target title="Debug">
-				<Option output="..\lib\libsquirrelD.a"/>
-				<Option working_dir=""/>
-				<Option object_output="Debug"/>
-				<Option deps_output=".deps"/>
-				<Option type="2"/>
-				<Option compiler="0"/>
-				<Option createDefFile="1"/>
-				<Option projectResourceIncludeDirsRelation="2"/>
-				<Compiler>
-					<Add option="-DWIN32"/>
-					<Add option="-D_DEBUG"/>
-					<Add option="-D_LIB"/>
-					<Add option="-DGARBAGE_COLLECTOR"/>
-					<Add option="-D_CRT_SECURE_NO_DEPRECATE"/>
-					<Add option="-W"/>
-					<Add option="-O0"/>
-					<Add directory="..\include"/>
-				</Compiler>
-			</Target>
-			<Target title="Release">
-				<Option output="..\lib\libsquirrel.a"/>
-				<Option working_dir=""/>
-				<Option object_output="Release"/>
-				<Option deps_output=".deps"/>
-				<Option type="2"/>
-				<Option compiler="0"/>
-				<Option createDefFile="1"/>
-				<Option projectResourceIncludeDirsRelation="2"/>
-				<Compiler>
-					<Add option="-DWIN32"/>
-					<Add option="-DNDEBUG"/>
-					<Add option="-D_LIB"/>
-					<Add option="-DGARBAGE_COLLECTOR"/>
-					<Add option="-D_CRT_SECURE_NO_DEPRECATE"/>
-					<Add option="-W"/>
-					<Add option="-O2"/>
-					<Add directory="..\include"/>
-				</Compiler>
-			</Target>
-			<Target title="Debug - Unicode">
-				<Option output="..\lib\libsquirrelDU.a"/>
-				<Option working_dir=""/>
-				<Option object_output="Debug - Unicode"/>
-				<Option deps_output=".deps"/>
-				<Option type="2"/>
-				<Option compiler="0"/>
-				<Option createDefFile="1"/>
-				<Option projectResourceIncludeDirsRelation="2"/>
-				<Compiler>
-					<Add option="-DWIN32"/>
-					<Add option="-D_DEBUG"/>
-					<Add option="-D_LIB"/>
-					<Add option="-DGARBAGE_COLLECTOR"/>
-					<Add option="-D_CRT_SECURE_NO_DEPRECATE"/>
-					<Add option="-D_CRT_NON_CONFORMING_SWPRINTFS"/>
-					<Add option="-W"/>
-					<Add option="-O0"/>
-					<Add directory="..\include"/>
-				</Compiler>
-			</Target>
-			<Target title="Release - Unicode">
-				<Option output="..\lib\libsquirrelU.a"/>
-				<Option working_dir=""/>
-				<Option object_output="Release - Unicode"/>
-				<Option deps_output=".deps"/>
-				<Option type="2"/>
-				<Option compiler="0"/>
-				<Option createDefFile="1"/>
-				<Option projectResourceIncludeDirsRelation="2"/>
-				<Compiler>
-					<Add option="-DWIN32"/>
-					<Add option="-DNDEBUG"/>
-					<Add option="-D_LIB"/>
-					<Add option="-DGARBAGE_COLLECTOR"/>
-					<Add option="-D_CRT_SECURE_NO_DEPRECATE"/>
-					<Add option="-D_CRT_NON_CONFORMING_SWPRINTFS"/>
-					<Add option="-W"/>
-					<Add option="-O2"/>
-					<Add directory="..\include"/>
-				</Compiler>
-			</Target>
-		</Build>
-		<Unit filename="sqapi.cpp">
-			<Option compilerVar="CPP"/>
-			<Option target="Debug"/>
-			<Option target="Release"/>
-			<Option target="Debug - Unicode"/>
-			<Option target="Release - Unicode"/>
-		</Unit>
-		<Unit filename="sqarray.h">
-			<Option compilerVar=""/>
-			<Option compile="0"/>
-			<Option link="0"/>
-			<Option target="Debug"/>
-			<Option target="Release"/>
-			<Option target="Debug - Unicode"/>
-			<Option target="Release - Unicode"/>
-		</Unit>
-		<Unit filename="sqbaselib.cpp">
-			<Option compilerVar="CPP"/>
-			<Option target="Debug"/>
-			<Option target="Release"/>
-			<Option target="Debug - Unicode"/>
-			<Option target="Release - Unicode"/>
-		</Unit>
-		<Unit filename="sqclass.cpp">
-			<Option compilerVar="CPP"/>
-			<Option target="Debug"/>
-			<Option target="Release"/>
-			<Option target="Debug - Unicode"/>
-			<Option target="Release - Unicode"/>
-		</Unit>
-		<Unit filename="sqclass.h">
-			<Option compilerVar=""/>
-			<Option compile="0"/>
-			<Option link="0"/>
-			<Option target="Debug"/>
-			<Option target="Release"/>
-			<Option target="Debug - Unicode"/>
-			<Option target="Release - Unicode"/>
-		</Unit>
-		<Unit filename="sqclosure.h">
-			<Option compilerVar=""/>
-			<Option compile="0"/>
-			<Option link="0"/>
-			<Option target="Debug"/>
-			<Option target="Release"/>
-			<Option target="Debug - Unicode"/>
-			<Option target="Release - Unicode"/>
-		</Unit>
-		<Unit filename="sqcompiler.cpp">
-			<Option compilerVar="CPP"/>
-			<Option target="Debug"/>
-			<Option target="Release"/>
-			<Option target="Debug - Unicode"/>
-			<Option target="Release - Unicode"/>
-		</Unit>
-		<Unit filename="sqcompiler.h">
-			<Option compilerVar=""/>
-			<Option compile="0"/>
-			<Option link="0"/>
-			<Option target="Debug"/>
-			<Option target="Release"/>
-			<Option target="Debug - Unicode"/>
-			<Option target="Release - Unicode"/>
-		</Unit>
-		<Unit filename="sqdebug.cpp">
-			<Option compilerVar="CPP"/>
-			<Option target="Debug"/>
-			<Option target="Release"/>
-			<Option target="Debug - Unicode"/>
-			<Option target="Release - Unicode"/>
-		</Unit>
-		<Unit filename="sqfuncproto.h">
-			<Option compilerVar=""/>
-			<Option compile="0"/>
-			<Option link="0"/>
-			<Option target="Debug"/>
-			<Option target="Release"/>
-			<Option target="Debug - Unicode"/>
-			<Option target="Release - Unicode"/>
-		</Unit>
-		<Unit filename="sqfuncstate.cpp">
-			<Option compilerVar="CPP"/>
-			<Option target="Debug"/>
-			<Option target="Release"/>
-			<Option target="Debug - Unicode"/>
-			<Option target="Release - Unicode"/>
-		</Unit>
-		<Unit filename="sqfuncstate.h">
-			<Option compilerVar=""/>
-			<Option compile="0"/>
-			<Option link="0"/>
-			<Option target="Debug"/>
-			<Option target="Release"/>
-			<Option target="Debug - Unicode"/>
-			<Option target="Release - Unicode"/>
-		</Unit>
-		<Unit filename="sqlexer.cpp">
-			<Option compilerVar="CPP"/>
-			<Option target="Debug"/>
-			<Option target="Release"/>
-			<Option target="Debug - Unicode"/>
-			<Option target="Release - Unicode"/>
-		</Unit>
-		<Unit filename="sqlexer.h">
-			<Option compilerVar=""/>
-			<Option compile="0"/>
-			<Option link="0"/>
-			<Option target="Debug"/>
-			<Option target="Release"/>
-			<Option target="Debug - Unicode"/>
-			<Option target="Release - Unicode"/>
-		</Unit>
-		<Unit filename="sqmem.cpp">
-			<Option compilerVar="CPP"/>
-			<Option target="Debug"/>
-			<Option target="Release"/>
-			<Option target="Debug - Unicode"/>
-			<Option target="Release - Unicode"/>
-		</Unit>
-		<Unit filename="sqobject.cpp">
-			<Option compilerVar="CPP"/>
-			<Option target="Debug"/>
-			<Option target="Release"/>
-			<Option target="Debug - Unicode"/>
-			<Option target="Release - Unicode"/>
-		</Unit>
-		<Unit filename="sqobject.h">
-			<Option compilerVar=""/>
-			<Option compile="0"/>
-			<Option link="0"/>
-			<Option target="Debug"/>
-			<Option target="Release"/>
-			<Option target="Debug - Unicode"/>
-			<Option target="Release - Unicode"/>
-		</Unit>
-		<Unit filename="sqopcodes.h">
-			<Option compilerVar=""/>
-			<Option compile="0"/>
-			<Option link="0"/>
-			<Option target="Debug"/>
-			<Option target="Release"/>
-			<Option target="Debug - Unicode"/>
-			<Option target="Release - Unicode"/>
-		</Unit>
-		<Unit filename="sqpcheader.h">
-			<Option compilerVar=""/>
-			<Option compile="0"/>
-			<Option link="0"/>
-			<Option target="Debug"/>
-			<Option target="Release"/>
-			<Option target="Debug - Unicode"/>
-			<Option target="Release - Unicode"/>
-		</Unit>
-		<Unit filename="sqstate.cpp">
-			<Option compilerVar="CPP"/>
-			<Option target="Debug"/>
-			<Option target="Release"/>
-			<Option target="Debug - Unicode"/>
-			<Option target="Release - Unicode"/>
-		</Unit>
-		<Unit filename="sqstate.h">
-			<Option compilerVar=""/>
-			<Option compile="0"/>
-			<Option link="0"/>
-			<Option target="Debug"/>
-			<Option target="Release"/>
-			<Option target="Debug - Unicode"/>
-			<Option target="Release - Unicode"/>
-		</Unit>
-		<Unit filename="sqstring.h">
-			<Option compilerVar=""/>
-			<Option compile="0"/>
-			<Option link="0"/>
-			<Option target="Debug"/>
-			<Option target="Release"/>
-			<Option target="Debug - Unicode"/>
-			<Option target="Release - Unicode"/>
-		</Unit>
-		<Unit filename="sqtable.cpp">
-			<Option compilerVar="CPP"/>
-			<Option target="Debug"/>
-			<Option target="Release"/>
-			<Option target="Debug - Unicode"/>
-			<Option target="Release - Unicode"/>
-		</Unit>
-		<Unit filename="sqtable.h">
-			<Option compilerVar=""/>
-			<Option compile="0"/>
-			<Option link="0"/>
-			<Option target="Debug"/>
-			<Option target="Release"/>
-			<Option target="Debug - Unicode"/>
-			<Option target="Release - Unicode"/>
-		</Unit>
-		<Unit filename="squserdata.h">
-			<Option compilerVar=""/>
-			<Option compile="0"/>
-			<Option link="0"/>
-			<Option target="Debug"/>
-			<Option target="Release"/>
-			<Option target="Debug - Unicode"/>
-			<Option target="Release - Unicode"/>
-		</Unit>
-		<Unit filename="squtils.h">
-			<Option compilerVar=""/>
-			<Option compile="0"/>
-			<Option link="0"/>
-			<Option target="Debug"/>
-			<Option target="Release"/>
-			<Option target="Debug - Unicode"/>
-			<Option target="Release - Unicode"/>
-		</Unit>
-		<Unit filename="sqvm.cpp">
-			<Option compilerVar="CPP"/>
-			<Option target="Debug"/>
-			<Option target="Release"/>
-			<Option target="Debug - Unicode"/>
-			<Option target="Release - Unicode"/>
-		</Unit>
-		<Unit filename="sqvm.h">
-			<Option compilerVar=""/>
-			<Option compile="0"/>
-			<Option link="0"/>
-			<Option target="Debug"/>
-			<Option target="Release"/>
-			<Option target="Debug - Unicode"/>
-			<Option target="Release - Unicode"/>
-		</Unit>
-	</Project>
-</CodeBlocks_project_file>
diff -rupwN ../dnl3/SqPlus/squirrel/squirrel.dsp SqPlus/squirrel/squirrel.dsp
--- ../dnl3/SqPlus/squirrel/squirrel.dsp	1969-12-31 19:00:00.000000000 -0500
+++ SqPlus/squirrel/squirrel.dsp	2004-11-27 04:11:27.000000000 -0500
@@ -0,0 +1,302 @@
+# Microsoft Developer Studio Project File - Name="squirrel" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE "Win32 (x86) Static Library" 0x0104
+
+CFG=squirrel - Win32 Debug
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f "squirrel.mak".
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f "squirrel.mak" CFG="squirrel - Win32 Debug"
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE "squirrel - Win32 Release" (based on "Win32 (x86) Static Library")
+!MESSAGE "squirrel - Win32 Debug" (based on "Win32 (x86) Static Library")
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_LocalPath ".."
+CPP=cl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "squirrel - Win32 Release"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir "Release"
+# PROP BASE Intermediate_Dir "Release"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir "Release"
+# PROP Intermediate_Dir "Release"
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_MBCS" /D "_LIB" /YX /FD /c
+# ADD CPP /nologo /W3 /GX /O2 /I "..\include" /D "WIN32" /D "NDEBUG" /D "_MBCS" /D "_LIB" /D "GARBAGE_COLLECTOR" /YX /FD /c
+# ADD BASE RSC /l 0x410 /d "NDEBUG"
+# ADD RSC /l 0x410 /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LIB32=link.exe -lib
+# ADD BASE LIB32 /nologo
+# ADD LIB32 /nologo /out:"..\lib\squirrel.lib"
+
+!ELSEIF  "$(CFG)" == "squirrel - Win32 Debug"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "Debug"
+# PROP BASE Intermediate_Dir "Debug"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "Debug"
+# PROP Intermediate_Dir "Debug"
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_MBCS" /D "_LIB" /YX /FD /GZ /c
+# ADD CPP /nologo /W3 /Gm /GX /ZI /Od /I "..\include" /D "WIN32" /D "_DEBUG" /D "_MBCS" /D "_LIB" /D "GARBAGE_COLLECTOR" /YX /FD /GZ /c
+# ADD BASE RSC /l 0x410 /d "_DEBUG"
+# ADD RSC /l 0x410 /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LIB32=link.exe -lib
+# ADD BASE LIB32 /nologo
+# ADD LIB32 /nologo /out:"..\lib\squirrel.lib"
+
+!ENDIF 
+
+# Begin Target
+
+# Name "squirrel - Win32 Release"
+# Name "squirrel - Win32 Debug"
+# Begin Group "Source Files"
+
+# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
+# Begin Source File
+
+SOURCE=.\sqapi.cpp
+
+!IF  "$(CFG)" == "squirrel - Win32 Release"
+
+!ELSEIF  "$(CFG)" == "squirrel - Win32 Debug"
+
+# ADD CPP /YX"stdafx.h"
+
+!ENDIF 
+
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqbaselib.cpp
+
+!IF  "$(CFG)" == "squirrel - Win32 Release"
+
+!ELSEIF  "$(CFG)" == "squirrel - Win32 Debug"
+
+# ADD CPP /YX"stdafx.h"
+
+!ENDIF 
+
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqcompiler.cpp
+
+!IF  "$(CFG)" == "squirrel - Win32 Release"
+
+!ELSEIF  "$(CFG)" == "squirrel - Win32 Debug"
+
+# ADD CPP /YX"stdafx.h"
+
+!ENDIF 
+
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqdebug.cpp
+
+!IF  "$(CFG)" == "squirrel - Win32 Release"
+
+!ELSEIF  "$(CFG)" == "squirrel - Win32 Debug"
+
+# ADD CPP /YX"stdafx.h"
+
+!ENDIF 
+
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqfuncstate.cpp
+
+!IF  "$(CFG)" == "squirrel - Win32 Release"
+
+!ELSEIF  "$(CFG)" == "squirrel - Win32 Debug"
+
+# ADD CPP /YX"stdafx.h"
+
+!ENDIF 
+
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqlexer.cpp
+
+!IF  "$(CFG)" == "squirrel - Win32 Release"
+
+!ELSEIF  "$(CFG)" == "squirrel - Win32 Debug"
+
+# ADD CPP /YX"stdafx.h"
+
+!ENDIF 
+
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqmem.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqobject.cpp
+
+!IF  "$(CFG)" == "squirrel - Win32 Release"
+
+!ELSEIF  "$(CFG)" == "squirrel - Win32 Debug"
+
+# ADD CPP /YX"stdafx.h"
+
+!ENDIF 
+
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqstate.cpp
+
+!IF  "$(CFG)" == "squirrel - Win32 Release"
+
+!ELSEIF  "$(CFG)" == "squirrel - Win32 Debug"
+
+# ADD CPP /YX"stdafx.h"
+
+!ENDIF 
+
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqtable.cpp
+
+!IF  "$(CFG)" == "squirrel - Win32 Release"
+
+!ELSEIF  "$(CFG)" == "squirrel - Win32 Debug"
+
+# ADD CPP /YX"stdafx.h"
+
+!ENDIF 
+
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqclass.cpp
+
+!IF  "$(CFG)" == "squirrel - Win32 Release"
+
+!ELSEIF  "$(CFG)" == "squirrel - Win32 Debug"
+
+# ADD CPP /YX"stdafx.h"
+
+!ENDIF 
+
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqvm.cpp
+
+!IF  "$(CFG)" == "squirrel - Win32 Release"
+
+!ELSEIF  "$(CFG)" == "squirrel - Win32 Debug"
+
+# ADD CPP /YX"stdafx.h"
+
+!ENDIF 
+
+# End Source File
+# End Group
+# Begin Group "Header Files"
+
+# PROP Default_Filter "h;hpp;hxx;hm;inl"
+# Begin Source File
+
+SOURCE=.\sqarray.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqclosure.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqcompiler.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqfuncproto.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqfuncstate.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqlexer.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqobject.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqopcodes.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqpcheader.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqstate.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqstring.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqtable.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\squserdata.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\squtils.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqclass.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqvm.h
+# End Source File
+# End Group
+# End Target
+# End Project
diff -rupwN ../dnl3/SqPlus/squirrel/squirrellib.cbp SqPlus/squirrel/squirrellib.cbp
--- ../dnl3/SqPlus/squirrel/squirrellib.cbp	2006-04-25 17:05:30.000000000 -0400
+++ SqPlus/squirrel/squirrellib.cbp	1969-12-31 19:00:00.000000000 -0500
@@ -1,20 +0,0 @@
-<?xml version="1.0"?>
-<!DOCTYPE CodeBlocks_project_file>
-<CodeBlocks_project_file>
-	<FileVersion major="1" minor="1"/>
-	<Project>
-		<Option title="Static library"/>
-		<Option makefile="Makefile"/>
-		<Build>
-			<Target title="default">
-				<Option type="2"/>
-				<Option parameters=""/>
-				<Option includeInTargetAll="1"/>
-				<Option projectCompilerOptionsRelation="3"/>
-				<Option projectLinkerOptionsRelation="3"/>
-				<Option projectIncludeDirsRelation="3"/>
-				<Option projectLibDirsRelation="3"/>
-			</Target>
-		</Build>
-	</Project>
-</CodeBlocks_project_file>
diff -rupwN ../dnl3/SqPlus/squirrel/squirrel.vcproj SqPlus/squirrel/squirrel.vcproj
--- ../dnl3/SqPlus/squirrel/squirrel.vcproj	2006-03-26 18:21:16.000000000 -0500
+++ SqPlus/squirrel/squirrel.vcproj	1969-12-31 19:00:00.000000000 -0500
@@ -1,971 +0,0 @@
-<?xml version="1.0" encoding="Windows-1252"?>
-<VisualStudioProject
-	ProjectType="Visual C++"
-	Version="8.00"
-	Name="squirrel"
-	ProjectGUID="{A79653F2-73F4-4F57-AE86-4AEBDE795232}"
-	RootNamespace="squirrel"
-	SccLocalPath=".."
-	>
-	<Platforms>
-		<Platform
-			Name="Win32"
-		/>
-	</Platforms>
-	<ToolFiles>
-	</ToolFiles>
-	<Configurations>
-		<Configuration
-			Name="Debug|Win32"
-			OutputDirectory="$(ConfigurationName)"
-			IntermediateDirectory="$(ConfigurationName)"
-			ConfigurationType="4"
-			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC71.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			CharacterSet="2"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="..\include"
-				PreprocessorDefinitions="WIN32;_DEBUG;_LIB;GARBAGE_COLLECTOR;_CRT_SECURE_NO_DEPRECATE"
-				BasicRuntimeChecks="3"
-				RuntimeLibrary="1"
-				UsePrecompiledHeader="0"
-				PrecompiledHeaderFile=".\Debug/squirrel.pch"
-				AssemblerListingLocation="$(IntDir)/"
-				ObjectFile="$(IntDir)/"
-				ProgramDataBaseFileName="$(IntDir)/"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-				DebugInformationFormat="4"
-				CompileAs="0"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="_DEBUG"
-				Culture="1040"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLibrarianTool"
-				OutputFile="..\lib\squirrelD.lib"
-				SuppressStartupBanner="true"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|Win32"
-			OutputDirectory="$(ConfigurationName)"
-			IntermediateDirectory="$(ConfigurationName)"
-			ConfigurationType="4"
-			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC71.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			CharacterSet="2"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="2"
-				InlineFunctionExpansion="1"
-				AdditionalIncludeDirectories="..\include"
-				PreprocessorDefinitions="WIN32;NDEBUG;_LIB;GARBAGE_COLLECTOR;_CRT_SECURE_NO_DEPRECATE"
-				StringPooling="true"
-				RuntimeLibrary="0"
-				EnableFunctionLevelLinking="true"
-				UsePrecompiledHeader="0"
-				PrecompiledHeaderFile=".\Release/squirrel.pch"
-				AssemblerListingLocation="$(IntDir)/"
-				ObjectFile="$(IntDir)/"
-				ProgramDataBaseFileName="$(IntDir)/"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-				CompileAs="0"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="NDEBUG"
-				Culture="1040"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLibrarianTool"
-				OutputFile="..\lib\squirrel.lib"
-				SuppressStartupBanner="true"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Debug - Unicode|Win32"
-			OutputDirectory="$(ConfigurationName)"
-			IntermediateDirectory="$(ConfigurationName)"
-			ConfigurationType="4"
-			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC71.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			CharacterSet="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="..\include"
-				PreprocessorDefinitions="WIN32;_DEBUG;_LIB;GARBAGE_COLLECTOR;_CRT_SECURE_NO_DEPRECATE;_CRT_NON_CONFORMING_SWPRINTFS"
-				BasicRuntimeChecks="3"
-				RuntimeLibrary="1"
-				UsePrecompiledHeader="0"
-				PrecompiledHeaderFile=".\DebugU/squirrel.pch"
-				AssemblerListingLocation="$(IntDir)/"
-				ObjectFile="$(IntDir)/"
-				ProgramDataBaseFileName="$(IntDir)/"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-				DebugInformationFormat="4"
-				CompileAs="0"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="_DEBUG"
-				Culture="1040"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLibrarianTool"
-				OutputFile="..\lib\squirrelDU.lib"
-				SuppressStartupBanner="true"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release - Unicode|Win32"
-			OutputDirectory="$(ConfigurationName)"
-			IntermediateDirectory="$(ConfigurationName)"
-			ConfigurationType="4"
-			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC71.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			CharacterSet="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="2"
-				InlineFunctionExpansion="1"
-				AdditionalIncludeDirectories="..\include"
-				PreprocessorDefinitions="WIN32;NDEBUG;_LIB;GARBAGE_COLLECTOR;_CRT_SECURE_NO_DEPRECATE;_CRT_NON_CONFORMING_SWPRINTFS"
-				StringPooling="true"
-				RuntimeLibrary="0"
-				EnableFunctionLevelLinking="true"
-				UsePrecompiledHeader="0"
-				PrecompiledHeaderFile=".\Release/squirrel.pch"
-				AssemblerListingLocation="$(IntDir)/"
-				ObjectFile="$(IntDir)/"
-				ProgramDataBaseFileName="$(IntDir)/"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-				CompileAs="0"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="NDEBUG"
-				Culture="1040"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLibrarianTool"
-				OutputFile="..\lib\squirrelU.lib"
-				SuppressStartupBanner="true"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-	</Configurations>
-	<References>
-	</References>
-	<Files>
-		<Filter
-			Name="Source Files"
-			Filter="cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
-			>
-			<File
-				RelativePath="sqapi.cpp"
-				>
-				<FileConfiguration
-					Name="Debug|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"
-						PrecompiledHeaderThrough="stdafx.h"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug - Unicode|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"
-						PrecompiledHeaderThrough="stdafx.h"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release - Unicode|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-					/>
-				</FileConfiguration>
-			</File>
-			<File
-				RelativePath="sqbaselib.cpp"
-				>
-				<FileConfiguration
-					Name="Debug|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"
-						PrecompiledHeaderThrough="stdafx.h"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug - Unicode|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"
-						PrecompiledHeaderThrough="stdafx.h"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release - Unicode|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-					/>
-				</FileConfiguration>
-			</File>
-			<File
-				RelativePath="sqclass.cpp"
-				>
-				<FileConfiguration
-					Name="Debug|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"
-						PrecompiledHeaderThrough="stdafx.h"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug - Unicode|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"
-						PrecompiledHeaderThrough="stdafx.h"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release - Unicode|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-					/>
-				</FileConfiguration>
-			</File>
-			<File
-				RelativePath="sqcompiler.cpp"
-				>
-				<FileConfiguration
-					Name="Debug|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"
-						PrecompiledHeaderThrough="stdafx.h"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug - Unicode|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"
-						PrecompiledHeaderThrough="stdafx.h"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release - Unicode|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-					/>
-				</FileConfiguration>
-			</File>
-			<File
-				RelativePath="sqdebug.cpp"
-				>
-				<FileConfiguration
-					Name="Debug|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"
-						PrecompiledHeaderThrough="stdafx.h"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug - Unicode|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"
-						PrecompiledHeaderThrough="stdafx.h"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release - Unicode|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-					/>
-				</FileConfiguration>
-			</File>
-			<File
-				RelativePath="sqfuncstate.cpp"
-				>
-				<FileConfiguration
-					Name="Debug|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"
-						PrecompiledHeaderThrough="stdafx.h"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug - Unicode|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"
-						PrecompiledHeaderThrough="stdafx.h"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release - Unicode|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-					/>
-				</FileConfiguration>
-			</File>
-			<File
-				RelativePath="sqlexer.cpp"
-				>
-				<FileConfiguration
-					Name="Debug|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"
-						PrecompiledHeaderThrough="stdafx.h"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug - Unicode|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"
-						PrecompiledHeaderThrough="stdafx.h"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release - Unicode|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-					/>
-				</FileConfiguration>
-			</File>
-			<File
-				RelativePath="sqmem.cpp"
-				>
-				<FileConfiguration
-					Name="Debug|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug - Unicode|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release - Unicode|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-					/>
-				</FileConfiguration>
-			</File>
-			<File
-				RelativePath="sqobject.cpp"
-				>
-				<FileConfiguration
-					Name="Debug|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"
-						PrecompiledHeaderThrough="stdafx.h"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug - Unicode|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"
-						PrecompiledHeaderThrough="stdafx.h"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release - Unicode|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-					/>
-				</FileConfiguration>
-			</File>
-			<File
-				RelativePath="sqstate.cpp"
-				>
-				<FileConfiguration
-					Name="Debug|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"
-						PrecompiledHeaderThrough="stdafx.h"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug - Unicode|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"
-						PrecompiledHeaderThrough="stdafx.h"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release - Unicode|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-					/>
-				</FileConfiguration>
-			</File>
-			<File
-				RelativePath="sqtable.cpp"
-				>
-				<FileConfiguration
-					Name="Debug|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"
-						PrecompiledHeaderThrough="stdafx.h"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug - Unicode|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"
-						PrecompiledHeaderThrough="stdafx.h"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release - Unicode|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-					/>
-				</FileConfiguration>
-			</File>
-			<File
-				RelativePath="sqvm.cpp"
-				>
-				<FileConfiguration
-					Name="Debug|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"
-						PrecompiledHeaderThrough="stdafx.h"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug - Unicode|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="0"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-						BasicRuntimeChecks="3"
-						PrecompiledHeaderThrough="stdafx.h"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release - Unicode|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						Optimization="2"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions=""
-					/>
-				</FileConfiguration>
-			</File>
-		</Filter>
-		<Filter
-			Name="Header Files"
-			Filter="h;hpp;hxx;hm;inl"
-			>
-			<File
-				RelativePath="sqarray.h"
-				>
-			</File>
-			<File
-				RelativePath="sqclass.h"
-				>
-			</File>
-			<File
-				RelativePath="sqclosure.h"
-				>
-			</File>
-			<File
-				RelativePath="sqcompiler.h"
-				>
-			</File>
-			<File
-				RelativePath="sqfuncproto.h"
-				>
-			</File>
-			<File
-				RelativePath="sqfuncstate.h"
-				>
-			</File>
-			<File
-				RelativePath="sqlexer.h"
-				>
-			</File>
-			<File
-				RelativePath="sqobject.h"
-				>
-			</File>
-			<File
-				RelativePath="sqopcodes.h"
-				>
-			</File>
-			<File
-				RelativePath="sqpcheader.h"
-				>
-			</File>
-			<File
-				RelativePath="sqstate.h"
-				>
-			</File>
-			<File
-				RelativePath="sqstring.h"
-				>
-			</File>
-			<File
-				RelativePath="sqtable.h"
-				>
-			</File>
-			<File
-				RelativePath="squserdata.h"
-				>
-			</File>
-			<File
-				RelativePath="squtils.h"
-				>
-			</File>
-			<File
-				RelativePath="sqvm.h"
-				>
-			</File>
-		</Filter>
-	</Files>
-	<Globals>
-	</Globals>
-</VisualStudioProject>
diff -rupwN ../dnl3/SqPlus/squirrel/squtils.h SqPlus/squirrel/squtils.h
--- ../dnl3/SqPlus/squirrel/squtils.h	2005-09-25 17:56:20.000000000 -0400
+++ SqPlus/squirrel/squtils.h	2006-03-30 09:36:30.000000000 -0500
@@ -4,9 +4,9 @@
 
 #define sq_new(__ptr,__type) {__ptr=(__type *)sq_vm_malloc(sizeof(__type));new (__ptr) __type;}
 #define sq_delete(__ptr,__type) {__ptr->~__type();sq_vm_free(__ptr,sizeof(__type));}
-#define SQ_MALLOC(__size) sq_vm_malloc(__size);
-#define SQ_FREE(__ptr,__size) sq_vm_free(__ptr,__size);
-#define SQ_REALLOC(__ptr,__oldsize,__size) sq_vm_realloc(__ptr,__oldsize,__size);
+#define SQ_MALLOC(__size) sq_vm_malloc((__size));
+#define SQ_FREE(__ptr,__size) sq_vm_free((__ptr),(__size));
+#define SQ_REALLOC(__ptr,__oldsize,__size) sq_vm_realloc((__ptr),(__oldsize),(__size));
 
 //sqvector mini vector class, supports objects by value
 template<typename T> class sqvector
diff -rupwN ../dnl3/SqPlus/squirrel/sqvm.cpp SqPlus/squirrel/sqvm.cpp
--- ../dnl3/SqPlus/squirrel/sqvm.cpp	2006-03-19 14:32:58.000000000 -0500
+++ SqPlus/squirrel/sqvm.cpp	2009-04-02 12:55:48.000000000 -0400
@@ -14,7 +14,7 @@
 #include "sqarray.h"
 #include "sqclass.h"
 
-#define TOP() (_stack[_top-1])
+#define TOP() (_stack._vals[_top-1])
 
 bool SQVM::BW_OP(SQUnsignedInteger op,SQObjectPtr &trg,const SQObjectPtr &o1,const SQObjectPtr &o2)
 {
@@ -41,23 +41,29 @@ bool SQVM::ARITH_OP(SQUnsignedInteger op
 {
 	if(sq_isnumeric(o1) && sq_isnumeric(o2)) {
 			if((type(o1)==OT_INTEGER) && (type(o2)==OT_INTEGER)) {
+				SQInteger res, i1 = _integer(o1), i2 = _integer(o2);
 				switch(op) {
-				case '+': trg = _integer(o1) + _integer(o2); break;
-				case '-': trg = _integer(o1) - _integer(o2); break;
-				case '/': if(_integer(o2) == 0) { Raise_Error(_SC("division by zero")); return false; }
-					trg = _integer(o1) / _integer(o2); 
-					break;
-				case '*': trg = _integer(o1) * _integer(o2); break;
-				case '%': trg = _integer(o1) % _integer(o2); break;
+				case '+': res = i1 + i2; break;
+				case '-': res = i1 - i2; break;
+				case '/': if(i2 == 0) { Raise_Error(_SC("division by zero")); return false; }
+					res = i1 / i2; 
+					break;
+				case '*': res = i1 * i2; break;
+				case '%': res = i1 % i2; break;
+				default: res = 0xDEADBEEF;
 				}
+				trg = res;
 			}else{
+				SQFloat res, f1 = tofloat(o1), f2 = tofloat(o2);
 				switch(op) {
-				case '+': trg = tofloat(o1) + tofloat(o2); break;
-				case '-': trg = tofloat(o1) - tofloat(o2); break;
-				case '/': trg = tofloat(o1) / tofloat(o2); break;
-				case '*': trg = tofloat(o1) * tofloat(o2); break;
-				case '%': trg = SQFloat(fmod((double)tofloat(o1),(double)tofloat(o2))); break;
+				case '+': res = f1 + f2; break;
+				case '-': res = f1 - f2; break;
+				case '/': res = f1 / f2; break;
+				case '*': res = f1 * f2; break;
+				case '%': res = SQFloat(fmod((double)f1,(double)f2)); break;
+				default: res = 0x0f;
 				}
+				trg = res;
 			}	
 		} else {
 			if(op == '+' &&	(type(o1) == OT_STRING || type(o2) == OT_STRING)){
@@ -93,6 +99,7 @@ void SQVM::Finalize()
 	_errorhandler = _null_;
 	_debughook = _null_;
 	temp_reg = _null_;
+	_callstackdata.resize(0);
 	SQInteger size=_stack.size();
 	for(SQInteger i=0;i<size;i++)
 		_stack[i]=_null_;
@@ -101,6 +108,7 @@ void SQVM::Finalize()
 SQVM::~SQVM()
 {
 	Finalize();
+	//sq_free(_callsstack,_alloccallsstacksize*sizeof(CallInfo));
 	REMOVE_FROM_CHAIN(&_ss(this)->_gc_chain,this);
 }
 
@@ -164,10 +172,13 @@ bool SQVM::ObjCmp(const SQObjectPtr &o1,
 		case OT_TABLE:
 		case OT_USERDATA:
 		case OT_INSTANCE:
+			if(_delegable(o1)->_delegate) {
 			Push(o1);Push(o2);
-			if(_delegable(o1)->_delegate)CallMetaMethod(_delegable(o1),MT_CMP,2,res);
-			break;
-		default: break; //shutup compiler
+				if(CallMetaMethod(_delegable(o1),MT_CMP,2,res)) break;
+			}
+			//continues through (no break needed)
+		default: 
+			_RET_SUCCEED( _userpointer(o1) < _userpointer(o2)?-1:1 );
 		}
 		if(type(res)!=OT_INTEGER) { Raise_CompareError(o1,o2); return false; }
 			_RET_SUCCEED(_integer(res));
@@ -218,13 +229,25 @@ void SQVM::ToString(const SQObjectPtr &o
 		res = o;
 		return;
 	case OT_FLOAT:
+#if !defined( SQUNICODE ) || defined( _MSC_VER ) || defined( _WIN32_WCE )
 		scsprintf(_sp(rsl(NUMBER_MAX_CHAR+1)),_SC("%g"),_float(o));
+#else
+		scsprintf(_sp(rsl(NUMBER_MAX_CHAR+1)),NUMBER_MAX_CHAR,_SC("%g"),_float(o));
+#endif
 		break;
 	case OT_INTEGER:
+#if !defined( SQUNICODE ) || defined( _MSC_VER ) || defined( _WIN32_WCE )
 		scsprintf(_sp(rsl(NUMBER_MAX_CHAR+1)),_SC("%d"),_integer(o));
+#else
+		scsprintf(_sp(rsl(NUMBER_MAX_CHAR+1)),NUMBER_MAX_CHAR,_SC("%d"),_integer(o));
+#endif
 		break;
 	case OT_BOOL:
+#if !defined( SQUNICODE ) || defined( _MSC_VER ) || defined( _WIN32_WCE )
 		scsprintf(_sp(rsl(6)),_integer(o)?_SC("true"):_SC("false"));
+#else
+		scsprintf(_sp(rsl(6)),NUMBER_MAX_CHAR,_integer(o)?_SC("true"):_SC("false"));
+#endif
 		break;
 	case OT_TABLE:
 	case OT_USERDATA:
@@ -238,7 +261,11 @@ void SQVM::ToString(const SQObjectPtr &o
 			}
 		}
 	default:
+#if !defined( SQUNICODE ) || defined( _MSC_VER ) || defined( _WIN32_WCE )
 		scsprintf(_sp(rsl(sizeof(void*)+20)),_SC("(%s : 0x%p)"),GetTypeName(o),(void*)_rawval(o));
+#else
+		scsprintf(_sp(rsl(sizeof(void*)+20)),NUMBER_MAX_CHAR,_SC("(%s : 0x%p)"),GetTypeName(o),(void*)_rawval(o));
+#endif
 	}
 	res = SQString::Create(_ss(this),_spval);
 }
@@ -257,39 +284,6 @@ bool SQVM::StringCat(const SQObjectPtr &
 	return true;
 }
 
-const SQChar *IdType2Name(SQObjectType type)
-{
-	switch(_RAW_TYPE(type))
-	{
-	case _RT_NULL:return _SC("null");
-	case _RT_INTEGER:return _SC("integer");
-	case _RT_FLOAT:return _SC("float");
-	case _RT_BOOL:return _SC("bool");
-	case _RT_STRING:return _SC("string");
-	case _RT_TABLE:return _SC("table");
-	case _RT_ARRAY:return _SC("array");
-	case _RT_GENERATOR:return _SC("generator");
-	case _RT_CLOSURE:
-	case _RT_NATIVECLOSURE:
-		return _SC("function");
-	case _RT_USERDATA:
-	case _RT_USERPOINTER:
-		return _SC("userdata");
-	case _RT_THREAD: return _SC("thread");
-	case _RT_FUNCPROTO: return _SC("function");
-	case _RT_CLASS: return _SC("class");
-	case _RT_INSTANCE: return _SC("instance");
-	case _RT_WEAKREF: return _SC("weakref");
-	default:
-		return NULL;
-	}
-}
-
-const SQChar *GetTypeName(const SQObjectPtr &obj1)
-{
-	return IdType2Name(type(obj1));	
-}
-
 void SQVM::TypeOf(const SQObjectPtr &obj1,SQObjectPtr &dest)
 {
 	if(is_delegable(obj1) && _delegable(obj1)->_delegate) {
@@ -303,7 +297,12 @@ void SQVM::TypeOf(const SQObjectPtr &obj
 bool SQVM::Init(SQVM *friendvm, SQInteger stacksize)
 {
 	_stack.resize(stacksize);
-	_callsstack.reserve(4);
+	//_callsstack.reserve(4);
+	_alloccallsstacksize = 4;
+	_callstackdata.resize(_alloccallsstacksize);
+	_callsstacksize = 0;
+	_callsstack = &_callstackdata[0];
+	//_callsstack = (CallInfo*)sq_malloc(_alloccallsstacksize*sizeof(CallInfo));
 	_stackbase = 0;
 	_top = 0;
 	if(!friendvm) 
@@ -320,24 +319,30 @@ bool SQVM::Init(SQVM *friendvm, SQIntege
 
 extern SQInstructionDesc g_InstrDesc[];
 
-bool SQVM::StartCall(SQClosure *closure,SQInteger target,SQInteger nargs,SQInteger stackbase,bool tailcall)
+bool SQVM::StartCall(SQClosure *closure,SQInteger target,SQInteger args,SQInteger stackbase,bool tailcall)
 {
 	SQFunctionProto *func = _funcproto(closure->_function);
 	
-	const SQInteger paramssize = func->_parameters.size();
+	const SQInteger paramssize = func->_nparameters;
 	const SQInteger newtop = stackbase + func->_stacksize;
-	
-	
+	SQInteger nargs = args;
 	if (paramssize != nargs) {
-		if(func->_varparams)
+		SQInteger ndef = func->_ndefaultparams;
+		if(ndef && nargs < paramssize) {
+			SQInteger diff = paramssize - nargs;
+			for(SQInteger n = ndef - diff; n < ndef; n++) {
+				_stack._vals[stackbase + (nargs++)] = closure->_defaultparams[n];
+			}
+		}
+		else if(func->_varparams)
 		{
 			if (nargs < paramssize) {
 				Raise_Error(_SC("wrong number of parameters"));
 				return false;
 			}
 			for(SQInteger n = 0; n < nargs - paramssize; n++) {
-				_vargsstack.push_back(_stack[stackbase+paramssize+n]);
-				_stack[stackbase+paramssize+n] = _null_;
+				_vargsstack.push_back(_stack._vals[stackbase+paramssize+n]);
+				_stack._vals[stackbase+paramssize+n] = _null_;
 			}
 		}
 		else {
@@ -347,29 +352,28 @@ bool SQVM::StartCall(SQClosure *closure,
 	}
 
 	if(type(closure->_env) == OT_WEAKREF) {
-		_stack[stackbase] = _weakref(closure->_env)->_obj;
+		_stack._vals[stackbase] = _weakref(closure->_env)->_obj;
 	}
 
 	if (!tailcall) {
 		CallInfo lc;
+		lc._generator = NULL;
 		lc._etraps = 0;
-		lc._prevstkbase = stackbase - _stackbase;
-		lc._target = target;
-		lc._prevtop = _top - _stackbase;
+		lc._prevstkbase = (SQInt32) ( stackbase - _stackbase );
+		lc._target = (SQInt32) target;
+		lc._prevtop = (SQInt32) (_top - _stackbase);
 		lc._ncalls = 1;
 		lc._root = SQFalse;
 		PUSH_CALLINFO(this, lc);
 	}
 	else {
 		ci->_ncalls++;
-		if(ci->_vargs.size) PopVarArgs(ci->_vargs);
 	}
-	ci->_vargs.size = (nargs - paramssize);
-	ci->_vargs.base = _vargsstack.size()-(ci->_vargs.size);
-	ci->_closure._unVal.pClosure = closure;
-	ci->_closure._type = OT_CLOSURE;
-	ci->_iv = &func->_instructions;
-	ci->_literals = &func->_literals;
+	ci->_vargs.size = (SQInt32)(nargs - paramssize);
+	ci->_vargs.base = (SQInt32)(_vargsstack.size()-(ci->_vargs.size));
+	ci->_closure = closure;
+	ci->_literals = func->_literals;
+	ci->_ip = func->_instructions;
 	//grows the stack if needed
 	if (((SQUnsignedInteger)newtop + (func->_stacksize<<1)) > _stack.size()) {
 		_stack.resize(_stack.size() + (func->_stacksize<<1));
@@ -377,7 +381,8 @@ bool SQVM::StartCall(SQClosure *closure,
 		
 	_top = newtop;
 	_stackbase = stackbase;
-	ci->_ip = ci->_iv->_vals;
+	if (type(_debughook) != OT_NULL && _rawval(_debughook) != _rawval(ci->_closure))
+		CallDebugHook(_SC('c'));
 	return true;
 }
 
@@ -396,19 +401,19 @@ bool SQVM::Return(SQInteger _arg0, SQInt
 	if(ci->_vargs.size) PopVarArgs(ci->_vargs);
 	POP_CALLINFO(this);
 	if (broot) {
-		if (_arg0 != MAX_FUNC_STACKSIZE) retval = _stack[oldstackbase+_arg1];
+		if (_arg0 != MAX_FUNC_STACKSIZE) retval = _stack._vals[oldstackbase+_arg1];
 		else retval = _null_;
 	}
 	else {
 		if(target != -1) { //-1 is when a class contructor ret value has to be ignored
 			if (_arg0 != MAX_FUNC_STACKSIZE)
-				STK(target) = _stack[oldstackbase+_arg1];
+				STK(target) = _stack._vals[oldstackbase+_arg1];
 			else
 				STK(target) = _null_;
 		}
 	}
 
-	while (last_top >= _top) _stack[last_top--].Null();
+	while (last_top >= _top) _stack._vals[last_top--].Null();
 	assert(oldstackbase >= _stackbase); 
 	return broot?true:false;
 }
@@ -463,24 +468,24 @@ void SQVM::PopVarArgs(VarArgs &vargs)
 		_vargsstack.pop_back();
 }
 
-#define _FINISH(stoploop) {finished = stoploop; return true; }
+#define _FINISH(howmuchtojump) {jump = howmuchtojump; return true; }
 bool SQVM::FOREACH_OP(SQObjectPtr &o1,SQObjectPtr &o2,SQObjectPtr 
-&o3,SQObjectPtr &o4,SQInteger arg_2,bool &finished)
+&o3,SQObjectPtr &o4,SQInteger arg_2,int exitpos,int &jump)
 {
 	SQInteger nrefidx;
 	switch(type(o1)) {
 	case OT_TABLE:
-		if((nrefidx = _table(o1)->Next(false,o4, o2, o3)) == -1) _FINISH(true);
-		o4 = (SQInteger)nrefidx; _FINISH(false);
+		if((nrefidx = _table(o1)->Next(false,o4, o2, o3)) == -1) _FINISH(exitpos);
+		o4 = (SQInteger)nrefidx; _FINISH(1);
 	case OT_ARRAY:
-		if((nrefidx = _array(o1)->Next(o4, o2, o3)) == -1) _FINISH(true);
-		o4 = (SQInteger) nrefidx; _FINISH(false);
+		if((nrefidx = _array(o1)->Next(o4, o2, o3)) == -1) _FINISH(exitpos);
+		o4 = (SQInteger) nrefidx; _FINISH(1);
 	case OT_STRING:
-		if((nrefidx = _string(o1)->Next(o4, o2, o3)) == -1)_FINISH(true);
-		o4 = (SQInteger)nrefidx; _FINISH(false);
+		if((nrefidx = _string(o1)->Next(o4, o2, o3)) == -1)_FINISH(exitpos);
+		o4 = (SQInteger)nrefidx; _FINISH(1);
 	case OT_CLASS:
-		if((nrefidx = _class(o1)->Next(o4, o2, o3)) == -1)_FINISH(true);
-		o4 = (SQInteger)nrefidx; _FINISH(false);
+		if((nrefidx = _class(o1)->Next(o4, o2, o3)) == -1)_FINISH(exitpos);
+		o4 = (SQInteger)nrefidx; _FINISH(1);
 	case OT_USERDATA:
 	case OT_INSTANCE:
 		if(_delegable(o1)->_delegate) {
@@ -489,19 +494,19 @@ bool SQVM::FOREACH_OP(SQObjectPtr &o1,SQ
 			Push(o4);
 			if(CallMetaMethod(_delegable(o1), MT_NEXTI, 2, itr)){
 				o4 = o2 = itr;
-				if(type(itr) == OT_NULL) _FINISH(true);
+				if(type(itr) == OT_NULL) _FINISH(exitpos);
 				if(!Get(o1, itr, o3, false,false)) {
 					Raise_Error(_SC("_nexti returned an invalid idx"));
 					return false;
 				}
-				_FINISH(false);
+				_FINISH(1);
 			}
 			Raise_Error(_SC("_nexti failed"));
 			return false;
 		}
 		break;
 	case OT_GENERATOR:
-		if(_generator(o1)->_state == SQGenerator::eDead) _FINISH(true);
+		if(_generator(o1)->_state == SQGenerator::eDead) _FINISH(exitpos);
 		if(_generator(o1)->_state == SQGenerator::eSuspended) {
 			SQInteger idx = 0;
 			if(type(o4) == OT_INTEGER) {
@@ -510,7 +515,7 @@ bool SQVM::FOREACH_OP(SQObjectPtr &o1,SQ
 			o2 = idx;
 			o4 = idx;
 			_generator(o1)->Resume(this, arg_2+1);
-			_FINISH(false);
+			_FINISH(0);
 		}
 	default: 
 		Raise_Error(_SC("cannot iterate %s"), GetTypeName(o1));
@@ -539,7 +544,7 @@ bool SQVM::DELEGATE_OP(SQObjectPtr &trg,
 	trg = o1;
 	return true;
 }
-#define COND_LITERAL (arg3!=0?(*ci->_literals)[arg1]:STK(arg1))
+#define COND_LITERAL (arg3!=0?ci->_literals[arg1]:STK(arg1))
 
 #define _GUARD(exp) { if(!exp) { Raise_Error(_lasterror); SQ_THROW();} }
 
@@ -549,7 +554,7 @@ bool SQVM::CLOSURE_OP(SQObjectPtr &targe
 {
 	SQInteger nouters;
 	SQClosure *closure = SQClosure::Create(_ss(this), func);
-	if((nouters = func->_outervalues.size())) {
+	if((nouters = func->_noutervalues)) {
 		closure->_outervalues.reserve(nouters);
 		for(SQInteger i = 0; i<nouters; i++) {
 			SQOuterVar &v = func->_outervalues[i];
@@ -568,6 +573,14 @@ bool SQVM::CLOSURE_OP(SQObjectPtr &targe
 			}
 		}
 	}
+	SQInteger ndefparams;
+	if((ndefparams = func->_ndefaultparams)) {
+		closure->_defaultparams.reserve(ndefparams);
+		for(SQInteger i = 0; i < ndefparams; i++) {
+			SQInteger spos = func->_defaultparams[i];
+			closure->_defaultparams.push_back(_stack._vals[_stackbase + spos]);
+		}
+	}
 	target = closure;
 	return true;
 
@@ -663,6 +676,7 @@ bool SQVM::Execute(SQObjectPtr &closure,
 	SQInteger traps = 0;
 	//temp_reg vars for OP_CALL
 	SQInteger ct_target;
+	SQInteger ct_stackbase;
 	bool ct_tailcall; 
 
 	switch(et) {
@@ -678,6 +692,7 @@ bool SQVM::Execute(SQObjectPtr &closure,
 		case ET_RESUME_VM:
 			traps = _suspended_traps;
 			ci->_root = _suspended_root;
+			ci->_vargs = _suspend_varargs;
 			_suspended = SQFalse;
 			break;
 	}
@@ -696,9 +711,10 @@ exception_restore:
 				if(type(_debughook) != OT_NULL && _rawval(_debughook) != _rawval(ci->_closure))
 					CallDebugHook(_SC('l'),arg1);
 				continue;
-			case _OP_LOAD: TARGET = (*ci->_literals)[arg1]; continue;
+			case _OP_LOAD: TARGET = ci->_literals[arg1]; continue;
 			case _OP_LOADINT: TARGET = (SQInteger)arg1; continue;
-			case _OP_DLOAD: TARGET = (*ci->_literals)[arg1]; STK(arg2) = (*ci->_literals)[arg3];continue;
+			case _OP_LOADFLOAT: TARGET = *((SQFloat *)&arg1); continue;
+			case _OP_DLOAD: TARGET = ci->_literals[arg1]; STK(arg2) = ci->_literals[arg3];continue;
 			case _OP_TAILCALL:
 				temp_reg = STK(arg1);
 				if (type(temp_reg) == OT_CLOSURE){ 
@@ -706,53 +722,56 @@ exception_restore:
 					if(ci->_vargs.size) PopVarArgs(ci->_vargs);
 					for (SQInteger i = 0; i < arg3; i++) STK(i) = STK(arg2 + i);
 					ct_target = ci->_target;
+					ct_stackbase = _stackbase;
 					goto common_call;
 				}
 			case _OP_CALL: {
 					ct_tailcall = false;
 					ct_target = arg0;
 					temp_reg = STK(arg1);
+					ct_stackbase = _stackbase+arg2;
+
 common_call:
+					SQObjectPtr clo = temp_reg;
 					SQInteger last_top = _top;
-					switch (type(temp_reg)) {
+					switch (type(clo)) {
 					case OT_CLOSURE:{
-						_GUARD(StartCall(_closure(temp_reg), ct_target, arg3, ct_tailcall?_stackbase:_stackbase+arg2, ct_tailcall));
-						if (_funcproto(_closure(temp_reg)->_function)->_bgenerator) {
-							SQGenerator *gen = SQGenerator::Create(_ss(this), _closure(temp_reg));
+						_GUARD(StartCall(_closure(clo), ct_target, arg3, ct_stackbase, ct_tailcall));
+						if (_funcproto(_closure(clo)->_function)->_bgenerator) {
+							SQGenerator *gen = SQGenerator::Create(_ss(this), _closure(clo));
 							_GUARD(gen->Yield(this));
-							Return(1, ct_target, temp_reg);
+							Return(1, ct_target, clo);
 							STK(ct_target) = gen;
-							while (last_top >= _top) _stack[last_top--].Null();
+							while (last_top >= _top) _stack._vals[last_top--].Null();
 							continue;
 						}
-						if (type(_debughook) != OT_NULL && _rawval(_debughook) != _rawval(ci->_closure))
-							CallDebugHook(_SC('c'));
 						}
-						break;
+						continue;
 					case OT_NATIVECLOSURE: {
 						bool suspend;
-						_GUARD(CallNative(_nativeclosure(temp_reg), arg3, _stackbase+arg2, ct_tailcall, temp_reg,suspend));
+						_GUARD(CallNative(_nativeclosure(clo), arg3, ct_stackbase, clo,suspend));
 						if(suspend){
 							_suspended = SQTrue;
 							_suspended_target = ct_target;
 							_suspended_root = ci->_root;
 							_suspended_traps = traps;
-							outres = temp_reg;
+							_suspend_varargs = ci->_vargs;
+							outres = clo;
 							return true;
 						}
-						if(ct_target != -1) { //skip return value for contructors
-							STK(ct_target) = temp_reg;
+						if(ct_target != -1) { //skip return value for constructors
+							STK(ct_target) = clo;
 						}
 										   }
-						break;
+						continue;
 					case OT_CLASS:{
 						SQObjectPtr inst;
-						_GUARD(CreateClassInstance(_class(temp_reg),inst,temp_reg));
+						_GUARD(CreateClassInstance(_class(clo),inst,temp_reg));
 						STK(ct_target) = inst;
-						ct_target = -1; //fakes return value target so that is not overwritten by the contructor
+						ct_target = -1; //fakes return value target so that is not overwritten by the constructor
 						if(type(temp_reg) != OT_NULL) {
-							_stack[_stackbase+arg2] = inst;
-							goto common_call; //hard core spaghetti code(reissues the OP_CALL to invoke the contructor)
+							_stack._vals[ct_stackbase] = inst;
+							goto common_call; //hard core spaghetti code(reissues the OP_CALL to invoke the constructor)
 						}
 						}
 						break;
@@ -760,47 +779,43 @@ common_call:
 					case OT_USERDATA:
 					case OT_INSTANCE:
 						{
-						Push(temp_reg);
+						Push(clo);
 						for (SQInteger i = 0; i < arg3; i++) Push(STK(arg2 + i));
-						if (_delegable(temp_reg) && CallMetaMethod(_delegable(temp_reg), MT_CALL, arg3+1, temp_reg)){
-							STK(ct_target) = temp_reg;
+						if (_delegable(clo) && CallMetaMethod(_delegable(clo), MT_CALL, arg3+1, clo)){
+							STK(ct_target) = clo;
 							break;
 						}
-						Raise_Error(_SC("attempt to call '%s'"), GetTypeName(temp_reg));
+						Raise_Error(_SC("attempt to call '%s'"), GetTypeName(clo));
 						SQ_THROW();
 					  }
 					default:
-						Raise_Error(_SC("attempt to call '%s'"), GetTypeName(temp_reg));
+						Raise_Error(_SC("attempt to call '%s'"), GetTypeName(clo));
 						SQ_THROW();
 					}
 				}
 				  continue;
 			case _OP_PREPCALL:
-					if (!Get(STK(arg2), STK(arg1), temp_reg, false,true))
-					{ Raise_IdxError(STK(arg1)); SQ_THROW(); }
-					goto common_prepcall;
 			case _OP_PREPCALLK:
-					if (!Get(STK(arg2), (*ci->_literals)[arg1], temp_reg,false,true)) {
-						if(type(STK(arg2)) == OT_CLASS) { //hack?
-							if(_class_ddel->Get((*ci->_literals)[arg1],temp_reg)) {
-								STK(arg3) = STK(arg2);
+				{
+					SQObjectPtr &key = _i_.op == _OP_PREPCALLK?(ci->_literals)[arg1]:STK(arg1);
+					SQObjectPtr &o = STK(arg2);
+					if (!Get(o, key, temp_reg,false,true)) {
+						if(type(o) == OT_CLASS) { //hack?
+							if(_class_ddel->Get(key,temp_reg)) {
+								STK(arg3) = o;
 								TARGET = temp_reg;
 								continue;
 							}
 						}
-						{ Raise_IdxError((*ci->_literals)[arg1]); SQ_THROW();}
-					}
-common_prepcall:
-					if(type(STK(arg2)) == OT_CLASS) {
-						STK(arg3) = STK(0); // this
-					}
-					else {
-						STK(arg3) = STK(arg2);
+						{ Raise_IdxError(key); SQ_THROW();}
 					}
+
+					STK(arg3) = type(o) == OT_CLASS?STK(0):o;
 					TARGET = temp_reg;
+				}
 				continue;
 			case _OP_GETK:
-				if (!Get(STK(arg2), (*ci->_literals)[arg1], temp_reg, false,true)) { Raise_IdxError((*ci->_literals)[arg1]); SQ_THROW();}
+				if (!Get(STK(arg2), ci->_literals[arg1], temp_reg, false,true)) { Raise_IdxError(ci->_literals[arg1]); SQ_THROW();}
 				TARGET = temp_reg;
 				continue;
 			case _OP_MOVE: TARGET = STK(arg1); continue;
@@ -830,8 +845,8 @@ common_prepcall:
 			case _OP_ARITH: _GUARD(ARITH_OP( arg3 , temp_reg, STK(arg2), STK(arg1))); TARGET = temp_reg; continue;
 			case _OP_BITW:	_GUARD(BW_OP( arg3,TARGET,STK(arg2),STK(arg1))); continue;
 			case _OP_RETURN:
-				if(type((ci)->_generator) == OT_GENERATOR) {
-					_generator((ci)->_generator)->Kill();
+				if(ci->_generator) {
+					ci->_generator->Kill();
 				}
 				if(Return(arg0, arg1, temp_reg)){
 					assert(traps==0);
@@ -897,9 +912,9 @@ common_prepcall:
 				continue;
 			}
 			case _OP_YIELD:{
-				if(type(ci->_generator) == OT_GENERATOR) {
+				if(ci->_generator) {
 					if(sarg1 != MAX_FUNC_STACKSIZE) temp_reg = STK(arg1);
-					_GUARD(_generator(ci->_generator)->Yield(this));
+					_GUARD(ci->_generator->Yield(this));
 					traps -= ci->_etraps;
 					if(sarg1 != MAX_FUNC_STACKSIZE) STK(arg1) = temp_reg;
 				}
@@ -917,9 +932,14 @@ common_prepcall:
 				_GUARD(_generator(STK(arg1))->Resume(this, arg0));
 				traps += ci->_etraps;
                 continue;
-			case _OP_FOREACH:{ bool finished;
-				_GUARD(FOREACH_OP(STK(arg0),STK(arg2),STK(arg2+1),STK(arg2+2),arg2,finished));
-				if(finished) ci->_ip += sarg1; }
+			case _OP_FOREACH:{ int tojump;
+				_GUARD(FOREACH_OP(STK(arg0),STK(arg2),STK(arg2+1),STK(arg2+2),arg2,sarg1,tojump));
+				ci->_ip += tojump; }
+				continue;
+			case _OP_POSTFOREACH:
+				assert(type(STK(arg0)) == OT_GENERATOR);
+				if(_generator(STK(arg0))->_state == SQGenerator::eDead) 
+					ci->_ip += (sarg1 - 1);
 				continue;
 			case _OP_DELEGATE: _GUARD(DELEGATE_OP(TARGET,STK(arg1),STK(arg2))); continue;
 			case _OP_CLONE:
@@ -927,15 +947,18 @@ common_prepcall:
 				{ Raise_Error(_SC("cloning a %s"), GetTypeName(STK(arg1))); SQ_THROW();}
 				continue;
 			case _OP_TYPEOF: TypeOf(STK(arg1), TARGET); continue;
-			case _OP_PUSHTRAP:
-				_etraps.push_back(SQExceptionTrap(_top,_stackbase, &ci->_iv->_vals[(ci->_ip-ci->_iv->_vals)+arg1], arg0)); traps++;
+			case _OP_PUSHTRAP:{
+				SQInstruction *_iv = _funcproto(_closure(ci->_closure)->_function)->_instructions;
+				_etraps.push_back(SQExceptionTrap(_top,_stackbase, &_iv[(ci->_ip-_iv)+arg1], arg0)); traps++;
 				ci->_etraps++;
+							  }
 				continue;
-			case _OP_POPTRAP:
+			case _OP_POPTRAP: {
 				for(SQInteger i = 0; i < arg0; i++) {
 					_etraps.pop_back(); traps--;
 					ci->_etraps--;
 				}
+							  }
 				continue;
 			case _OP_THROW:	Raise_Error(TARGET); SQ_THROW(); continue;
 			case _OP_CLASS: _GUARD(CLASS_OP(TARGET,arg1,arg2)); continue;
@@ -977,19 +1000,19 @@ exception_trap:
 						ci->_ip = et._ip;
 						_top = et._stacksize;
 						_stackbase = et._stackbase;
-						_stack[_stackbase+et._extarget] = currerror;
+						_stack._vals[_stackbase+et._extarget] = currerror;
 						_etraps.pop_back(); traps--; ci->_etraps--;
-						while(last_top >= _top) _stack[last_top--].Null();
+						while(last_top >= _top) _stack._vals[last_top--].Null();
 						goto exception_restore;
 					}
 					//if is a native closure
 					if(type(ci->_closure) != OT_CLOSURE && n)
 						break;
-					if(type(ci->_generator) == OT_GENERATOR) _generator(ci->_generator)->Kill();
+					if(ci->_generator) ci->_generator->Kill();
 					PopVarArgs(ci->_vargs);
 					POP_CALLINFO(this);
 					n++;
-				} while(_callsstack.size());
+				} while(_callsstacksize);
 			}
 			else {
 				//call the hook
@@ -999,15 +1022,15 @@ exception_trap:
 			//remove call stack until a C function is found or the cstack is empty
 			if(ci) do {
 				SQBool exitafterthisone = ci->_root;
-				if(type(ci->_generator) == OT_GENERATOR) _generator(ci->_generator)->Kill();
+				if(ci->_generator) ci->_generator->Kill();
 				_stackbase -= ci->_prevstkbase;
 				_top = _stackbase + ci->_prevtop;
 				PopVarArgs(ci->_vargs);
 				POP_CALLINFO(this);
 				if( (ci && type(ci->_closure) != OT_CLOSURE) || exitafterthisone) break;
-			} while(_callsstack.size());
+			} while(_callsstacksize);
 
-			while(last_top >= _top) _stack[last_top--].Null();
+			while(last_top >= _top) _stack._vals[last_top--].Null();
 		}
 		_lasterror = currerror;
 		return false;
@@ -1046,7 +1069,7 @@ void SQVM::CallDebugHook(SQInteger type,
 	Pop(nparams);
 }
 
-bool SQVM::CallNative(SQNativeClosure *nclosure,SQInteger nargs,SQInteger stackbase,bool tailcall,SQObjectPtr &retval,bool &suspend)
+bool SQVM::CallNative(SQNativeClosure *nclosure,SQInteger nargs,SQInteger stackbase,SQObjectPtr &retval,bool &suspend)
 {
 	if (_nnativecalls + 1 > MAX_NATIVE_CALLS) { Raise_Error(_SC("Native stack overflow")); return false; }
 	SQInteger nparamscheck = nclosure->_nparamscheck;
@@ -1059,8 +1082,8 @@ bool SQVM::CallNative(SQNativeClosure *n
 	SQInteger tcs;
 	if((tcs = nclosure->_typecheck.size())) {
 		for(SQInteger i = 0; i < nargs && i < tcs; i++)
-			if((nclosure->_typecheck[i] != -1) && !(type(_stack[stackbase+i]) & nclosure->_typecheck[i])) {
-                Raise_ParamTypeError(i,nclosure->_typecheck[i],type(_stack[stackbase+i]));
+			if((nclosure->_typecheck._vals[i] != -1) && !(type(_stack._vals[stackbase+i]) & nclosure->_typecheck[i])) {
+                Raise_ParamTypeError(i,nclosure->_typecheck._vals[i],type(_stack._vals[stackbase+i]));
 				return false;
 			}
 	}
@@ -1071,12 +1094,14 @@ bool SQVM::CallNative(SQNativeClosure *n
 	SQInteger oldtop = _top;
 	SQInteger oldstackbase = _stackbase;
 	_top = stackbase + nargs;
-	PUSH_CALLINFO(this, CallInfo());
-	ci->_etraps = 0;
-	ci->_closure._unVal.pNativeClosure = nclosure;
-	ci->_closure._type = OT_NATIVECLOSURE;
-	ci->_prevstkbase = stackbase - _stackbase;
-	ci->_ncalls = 1;
+	CallInfo lci;
+	lci._closure = nclosure;
+	lci._generator = NULL;
+	lci._etraps = 0;
+	lci._prevstkbase = (SQInt32) (stackbase - _stackbase);
+	lci._ncalls = 1;
+	lci._prevtop = (SQInt32) (oldtop - oldstackbase);
+	PUSH_CALLINFO(this, lci);
 	_stackbase = stackbase;
 	//push free variables
 	SQInteger outers = nclosure->_outervalues.size();
@@ -1088,7 +1113,7 @@ bool SQVM::CallNative(SQNativeClosure *n
 		_stack[stackbase] = _weakref(nclosure->_env)->_obj;
 	}
 
-	ci->_prevtop = (oldtop - oldstackbase);
+	
 	SQInteger ret = (nclosure->_function)(this);
 	_nnativecalls--;
 	suspend = false;
@@ -1101,7 +1126,7 @@ bool SQVM::CallNative(SQNativeClosure *n
 		return false;
 	}
 	
-	if (ret != 0){ retval = TOP(); }
+	if (ret != 0){ retval = TOP(); TOP().Null(); }
 	else { retval = _null_; }
 	_stackbase = oldstackbase;
 	_top = oldtop;
@@ -1288,6 +1313,14 @@ bool SQVM::NewSlot(const SQObjectPtr &se
 		if(rawcall) _table(self)->NewSlot(key,val); //cannot fail
 		
 		break;}
+	case OT_INSTANCE: {
+		SQObjectPtr res;
+		Push(self);Push(key);Push(val);
+		if(!CallMetaMethod(_instance(self),MT_NEWSLOT,3,res)) {
+			Raise_Error(_SC("class instances do not support the new slot operator"));
+			return false;
+		}
+		break;}
 	case OT_CLASS: 
 		if(!_class(self)->NewSlot(_ss(this),key,val,bstatic)) {
 			if(_class(self)->_locked) {
@@ -1358,7 +1391,7 @@ SQInteger prevstackbase = _stackbase;
 		break;
 	case OT_NATIVECLOSURE:{
 		bool suspend;
-		return CallNative(_nativeclosure(closure), nparams, stackbase, false, outres,suspend);
+		return CallNative(_nativeclosure(closure), nparams, stackbase, outres,suspend);
 		
 						  }
 		break;
@@ -1428,7 +1461,7 @@ void SQVM::dumpstack(SQInteger stackbase
 	SQInteger size=dumpall?_stack.size():_top;
 	SQInteger n=0;
 	scprintf(_SC("\n>>>>stack dump<<<<\n"));
-	CallInfo &ci=_callsstack.back();
+	CallInfo &ci=_callsstack[_callsstacksize-1];
 	scprintf(_SC("IP: %p\n"),ci._ip);
 	scprintf(_SC("prev stack base: %d\n"),ci._prevstkbase);
 	scprintf(_SC("prev top: %d\n"),ci._prevtop);
@@ -1447,7 +1480,7 @@ void SQVM::dumpstack(SQInteger stackbase
 		case OT_CLOSURE:		scprintf(_SC("CLOSURE [%p]"),_closure(obj));break;
 		case OT_NATIVECLOSURE:	scprintf(_SC("NATIVECLOSURE"));break;
 		case OT_USERDATA:		scprintf(_SC("USERDATA %p[%p]"),_userdataval(obj),_userdata(obj)->_delegate);break;
-		case OT_GENERATOR:		scprintf(_SC("GENERATOR"));break;
+		case OT_GENERATOR:		scprintf(_SC("GENERATOR %p"),_generator(obj));break;
 		case OT_THREAD:			scprintf(_SC("THREAD [%p]"),_thread(obj));break;
 		case OT_USERPOINTER:	scprintf(_SC("USERPOINTER %p"),_userpointer(obj));break;
 		case OT_CLASS:			scprintf(_SC("CLASS %p"),_class(obj));break;
diff -rupwN ../dnl3/SqPlus/squirrel/sqvm.h SqPlus/squirrel/sqvm.h
--- ../dnl3/SqPlus/squirrel/sqvm.h	2006-03-19 14:32:58.000000000 -0500
+++ SqPlus/squirrel/sqvm.h	2008-05-16 09:23:46.000000000 -0400
@@ -32,23 +32,21 @@ struct SQVM : public CHAINABLE_OBJ
 {
 	struct VarArgs {
 		VarArgs() { size = 0; base = 0; }
-		SQInteger size;
-		SQInteger base;
+		unsigned short size;
+		unsigned short base;
 	};
 
 	struct CallInfo{
-		CallInfo() { _generator._type = OT_NULL;}
-		//CallInfo(const CallInfo& ci) {  }
-		SQInstructionVec *_iv;
-		SQObjectPtrVec *_literals;
-		SQObject _closure;
-		SQObject _generator;
-		SQInteger _etraps;
-		SQInteger _prevstkbase;
-		SQInteger _prevtop;
-		SQInteger _target;
+		//CallInfo() { _generator._type = OT_NULL;}
 		SQInstruction *_ip;
-		SQInteger _ncalls;
+		SQObjectPtr *_literals;
+		SQObjectPtr _closure;
+		SQGenerator *_generator;
+		SQInt32 _etraps;
+		SQInt32 _prevstkbase;
+		SQInt32 _prevtop;
+		SQInt32 _target;
+		SQInt32 _ncalls;
 		SQBool _root;
 		VarArgs _vargs;
 	};
@@ -61,7 +59,7 @@ public:
 	bool Init(SQVM *friendvm, SQInteger stacksize);
 	bool Execute(SQObjectPtr &func, SQInteger target, SQInteger nargs, SQInteger stackbase, SQObjectPtr &outres, SQBool raiseerror, ExecutionType et = ET_CALL);
 	//starts a native call return when the NATIVE closure returns
-	bool CallNative(SQNativeClosure *nclosure, SQInteger nargs, SQInteger stackbase, bool tailcall, SQObjectPtr &retval,bool &suspend);
+	bool CallNative(SQNativeClosure *nclosure, SQInteger nargs, SQInteger stackbase, SQObjectPtr &retval,bool &suspend);
 	//starts a SQUIRREL call in the same "Execution loop"
 	bool StartCall(SQClosure *closure, SQInteger target, SQInteger nargs, SQInteger stackbase, bool tailcall);
 	bool CreateClassInstance(SQClass *theclass, SQObjectPtr &inst, SQObjectPtr &constructor);
@@ -104,7 +102,7 @@ public:
 	bool CLASS_OP(SQObjectPtr &target,SQInteger base,SQInteger attrs);
 	bool GETPARENT_OP(SQObjectPtr &o,SQObjectPtr &target);
 	//return true if the loop is finished
-	bool FOREACH_OP(SQObjectPtr &o1,SQObjectPtr &o2,SQObjectPtr &o3,SQObjectPtr &o4,SQInteger arg_2,bool &finished);
+	bool FOREACH_OP(SQObjectPtr &o1,SQObjectPtr &o2,SQObjectPtr &o3,SQObjectPtr &o4,SQInteger arg_2,int exitpos,int &jump);
 	bool DELEGATE_OP(SQObjectPtr &trg,SQObjectPtr &o1,SQObjectPtr &o2);
 	_INLINE bool LOCAL_INC(SQInteger op,SQObjectPtr &target, SQObjectPtr &a, SQObjectPtr &incr);
 	_INLINE bool PLOCAL_INC(SQInteger op,SQObjectPtr &target, SQObjectPtr &a, SQObjectPtr &incr);
@@ -118,7 +116,12 @@ public:
 	void Mark(SQCollectable **chain);
 #endif
 	void Finalize();
-
+	void GrowCallStack() {
+		SQInteger newsize = _alloccallsstacksize*2;
+		_callstackdata.resize(newsize);
+		_callsstack = &_callstackdata[0];
+		_alloccallsstacksize = newsize;
+	}
 	void Release(){ sq_delete(this,SQVM); } //does nothing
 ////////////////////////////////////////////////////////////////////////////
 	//stack functions for the api
@@ -144,7 +147,13 @@ public:
 	SQObjectPtr _debughook;
 
 	SQObjectPtr temp_reg;
-	CallInfoVec _callsstack;
+	
+
+	CallInfo* _callsstack;
+	SQInteger _callsstacksize;
+	SQInteger _alloccallsstacksize;
+	sqvector<CallInfo>  _callstackdata;
+
 	ExceptionsTraps _etraps;
 	CallInfo *ci;
 	void *_foreignptr;
@@ -156,6 +165,7 @@ public:
 	SQBool _suspended_root;
 	SQInteger _suspended_target;
 	SQInteger _suspended_traps;
+	VarArgs _suspend_varargs;
 };
 
 struct AutoDec{
@@ -165,8 +175,6 @@ struct AutoDec{
 };
 
 inline SQObjectPtr &stack_get(HSQUIRRELVM v,SQInteger idx){return ((idx>=0)?(v->GetAt(idx+v->_stackbase-1)):(v->GetUp(idx)));}
-const SQChar *GetTypeName(const SQObjectPtr &obj1);
-const SQChar *IdType2Name(SQObjectType type);
 
 #define _ss(_vm_) (_vm_)->_sharedstate
 
@@ -177,13 +185,19 @@ const SQChar *IdType2Name(SQObjectType t
 #endif
 
 #define PUSH_CALLINFO(v,nci){ \
-	v->ci = &v->_callsstack.push_back(nci); \
+	if(v->_callsstacksize == v->_alloccallsstacksize) { \
+		v->GrowCallStack(); \
+	} \
+	v->ci = &v->_callsstack[v->_callsstacksize]; \
+	*(v->ci) = nci; \
+	v->_callsstacksize++; \
 }
 
 #define POP_CALLINFO(v){ \
-	v->_callsstack.pop_back(); \
-	if(v->_callsstack.size())	\
-		v->ci = &v->_callsstack.back() ; \
+	v->_callsstacksize--; \
+	v->ci->_closure.Null(); \
+	if(v->_callsstacksize)	\
+		v->ci = &v->_callsstack[v->_callsstacksize-1] ; \
 	else	\
 		v->ci = NULL; \
 }
diff -rupwN ../dnl3/SqPlus/_squirrel/Makefile SqPlus/_squirrel/Makefile
--- ../dnl3/SqPlus/_squirrel/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ SqPlus/_squirrel/Makefile	2006-03-19 14:32:58.000000000 -0500
@@ -0,0 +1,52 @@
+SQUIRREL= ..
+
+
+OUT= $(SQUIRREL)/lib/libsquirrel.a
+INCZ= -I$(SQUIRREL)/include -I. -Iinclude
+DEFS= 
+LIB=	
+
+OBJS= \
+	sqapi.o \
+	sqbaselib.o \
+	sqcompiler.o \
+	sqdebug.o \
+	sqlexer.o \
+	sqobject.o \
+	sqparser.o \
+	sqstate.o \
+	sqtable.o \
+	sqvm.o \
+	sqmem.o \
+	sqclass.o
+	
+SRCS= \
+	sqapi.cpp \
+	sqbaselib.cpp \
+	sqfuncstate.cpp \
+	sqdebug.cpp \
+	sqlexer.cpp \
+	sqobject.cpp \
+	sqcompiler.cpp \
+	sqstate.cpp \
+	sqtable.cpp \
+	sqmem.cpp \
+	sqvm.cpp \
+	sqclass.cpp
+
+	
+	
+sq32:
+	gcc -O2  -fno-rtti -Wall -c $(SRCS) $(INCZ) $(DEFS)
+	ar rc $(OUT) *.o
+	rm *.o
+
+sqprof:
+	gcc -O2 -pg -fno-rtti -pie -gstabs -g3 -Wall -c $(SRCS) $(INCZ) $(DEFS)
+	ar rc $(OUT) *.o
+	rm *.o
+
+sq64:
+	gcc -O2  -D_SQ64 -fno-rtti -Wall -c $(SRCS) $(INCZ) $(DEFS)
+	ar rc $(OUT) *.o
+	rm *.o
diff -rupwN ../dnl3/SqPlus/_squirrel/sqapi.cpp SqPlus/_squirrel/sqapi.cpp
--- ../dnl3/SqPlus/_squirrel/sqapi.cpp	1969-12-31 19:00:00.000000000 -0500
+++ SqPlus/_squirrel/sqapi.cpp	2006-03-19 14:32:58.000000000 -0500
@@ -0,0 +1,1203 @@
+/*
+	see copyright notice in squirrel.h
+*/
+#include "sqpcheader.h"
+#include "sqvm.h"
+#include "sqstring.h"
+#include "sqtable.h"
+#include "sqarray.h"
+#include "sqfuncproto.h"
+#include "sqclosure.h"
+#include "squserdata.h"
+#include "sqcompiler.h"
+#include "sqfuncstate.h"
+#include "sqclass.h"
+
+bool sq_aux_gettypedarg(HSQUIRRELVM v,SQInteger idx,SQObjectType type,SQObjectPtr **o)
+{
+	*o = &stack_get(v,idx);
+	if(type(**o) != type){
+		SQObjectPtr oval = v->PrintObjVal(**o);
+		v->Raise_Error(_SC("wrong argument type, expected '%s' got '%.50s'"),IdType2Name(type),_stringval(oval));
+		return false;
+	}
+	return true;
+}
+
+#define _GETSAFE_OBJ(v,idx,type,o) { if(!sq_aux_gettypedarg(v,idx,type,&o)) return SQ_ERROR; }
+
+#define sq_aux_paramscheck(v,count) \
+{ \
+	if(sq_gettop(v) < count){ v->Raise_Error(_SC("not enough params in the stack")); return SQ_ERROR; }\
+}		
+
+SQInteger sq_aux_throwobject(HSQUIRRELVM v,SQObjectPtr &e)
+{
+	v->_lasterror = e;
+	return SQ_ERROR;
+}
+
+SQInteger sq_aux_invalidtype(HSQUIRRELVM v,SQObjectType type)
+{
+	scsprintf(_ss(v)->GetScratchPad(100), _SC("unexpected type %s"), IdType2Name(type));
+	return sq_throwerror(v, _ss(v)->GetScratchPad(-1));
+}
+
+HSQUIRRELVM sq_open(SQInteger initialstacksize)
+{
+	SQSharedState *ss;
+	SQVM *v;
+	sq_new(ss, SQSharedState);
+	ss->Init();
+	v = (SQVM *)SQ_MALLOC(sizeof(SQVM));
+	new (v) SQVM(ss);
+	ss->_root_vm = v;
+	if(v->Init(NULL, initialstacksize)) {
+		return v;
+	} else {
+		sq_delete(v, SQVM);
+		return NULL;
+	}
+	return v;
+}
+
+HSQUIRRELVM sq_newthread(HSQUIRRELVM friendvm, SQInteger initialstacksize)
+{
+	SQSharedState *ss;
+	SQVM *v;
+	ss=_ss(friendvm);
+	
+	v= (SQVM *)SQ_MALLOC(sizeof(SQVM));
+	new (v) SQVM(ss);
+	
+	if(v->Init(friendvm, initialstacksize)) {
+		friendvm->Push(v);
+		return v;
+	} else {
+		sq_delete(v, SQVM);
+		return NULL;
+	}
+}
+
+SQInteger sq_getvmstate(HSQUIRRELVM v)
+{
+	if(v->_suspended)
+		return SQ_VMSTATE_SUSPENDED;
+	else { 
+		if(v->_callsstack.size() != 0) return SQ_VMSTATE_RUNNING;
+		else return SQ_VMSTATE_IDLE;
+	}
+}
+
+void sq_seterrorhandler(HSQUIRRELVM v)
+{
+	SQObject o = stack_get(v, -1);
+	if(sq_isclosure(o) || sq_isnativeclosure(o) || sq_isnull(o)) {
+		v->_errorhandler = o;
+		v->Pop();
+	}
+}
+
+void sq_setdebughook(HSQUIRRELVM v)
+{
+	SQObject o = stack_get(v,-1);
+	if(sq_isclosure(o) || sq_isnativeclosure(o) || sq_isnull(o)) {
+		v->_debughook = o;
+		v->Pop();
+	}
+}
+
+void sq_close(HSQUIRRELVM v)
+{
+	SQSharedState *ss = _ss(v);
+	_thread(ss->_root_vm)->Finalize();
+	sq_delete(ss, SQSharedState);
+}
+
+SQRESULT sq_compile(HSQUIRRELVM v,SQLEXREADFUNC read,SQUserPointer p,const SQChar *sourcename,SQBool raiseerror)
+{
+	SQObjectPtr o;
+	if(Compile(v, read, p, sourcename, o, raiseerror?true:false, _ss(v)->_debuginfo)) {
+		v->Push(SQClosure::Create(_ss(v), _funcproto(o)));
+		return SQ_OK;
+	}
+	return SQ_ERROR;
+}
+
+void sq_enabledebuginfo(HSQUIRRELVM v, SQBool enable)
+{
+	_ss(v)->_debuginfo = enable?true:false;
+}
+
+void sq_notifyallexceptions(HSQUIRRELVM v, SQBool enable)
+{
+	_ss(v)->_notifyallexceptions = enable?true:false;
+}
+
+void sq_addref(HSQUIRRELVM v,HSQOBJECT *po)
+{
+	if(!ISREFCOUNTED(type(*po))) return;
+	_ss(v)->_refs_table.AddRef(*po);
+}
+
+SQBool sq_release(HSQUIRRELVM v,HSQOBJECT *po)
+{
+	if(!ISREFCOUNTED(type(*po))) return SQTrue;
+	return _ss(v)->_refs_table.Release(*po);
+}
+
+const SQChar *sq_objtostring(HSQOBJECT *o) 
+{
+	if(sq_type(*o) == OT_STRING) {
+		return _stringval(*o);
+	}
+	return NULL;
+}
+
+SQInteger sq_objtointeger(HSQOBJECT *o) 
+{
+	if(sq_isnumeric(*o)) {
+		return tointeger(*o);
+	}
+	return 0;
+}
+
+SQFloat sq_objtofloat(HSQOBJECT *o) 
+{
+	if(sq_isnumeric(*o)) {
+		return tofloat(*o);
+	}
+	return 0;
+}
+
+SQBool sq_objtobool(HSQOBJECT *o) 
+{
+	if(sq_isbool(*o)) {
+		return _integer(*o);
+	}
+	return SQFalse;
+}
+
+void sq_pushnull(HSQUIRRELVM v)
+{
+	v->Push(_null_);
+}
+
+void sq_pushstring(HSQUIRRELVM v,const SQChar *s,SQInteger len)
+{
+	if(s)
+		v->Push(SQObjectPtr(SQString::Create(_ss(v), s, len)));
+	else v->Push(_null_);
+}
+
+void sq_pushinteger(HSQUIRRELVM v,SQInteger n)
+{
+	v->Push(n);
+}
+
+void sq_pushbool(HSQUIRRELVM v,SQBool b)
+{
+	v->Push(b?true:false);
+}
+
+void sq_pushfloat(HSQUIRRELVM v,SQFloat n)
+{
+	v->Push(n);
+}
+
+void sq_pushuserpointer(HSQUIRRELVM v,SQUserPointer p)
+{
+	v->Push(p);
+}
+
+SQUserPointer sq_newuserdata(HSQUIRRELVM v,SQUnsignedInteger size)
+{
+	SQUserData *ud = SQUserData::Create(_ss(v), size);
+	v->Push(ud);
+	return ud->_val;
+}
+
+void sq_newtable(HSQUIRRELVM v)
+{
+	v->Push(SQTable::Create(_ss(v), 0));	
+}
+
+void sq_newarray(HSQUIRRELVM v,SQInteger size)
+{
+	v->Push(SQArray::Create(_ss(v), size));	
+}
+
+SQRESULT sq_newclass(HSQUIRRELVM v,SQBool hasbase)
+{
+	SQClass *baseclass = NULL;
+	if(hasbase) {
+		SQObjectPtr &base = stack_get(v,-1);
+		if(type(base) != OT_CLASS)
+			return sq_throwerror(v,_SC("invalid base type"));
+		baseclass = _class(base);
+	}
+	SQClass *newclass = SQClass::Create(_ss(v), baseclass);
+	if(baseclass) v->Pop();
+	v->Push(newclass);	
+	return SQ_OK;
+}
+
+SQBool sq_instanceof(HSQUIRRELVM v)
+{
+	SQObjectPtr &inst = stack_get(v,-1);
+	SQObjectPtr &cl = stack_get(v,-2);
+	if(type(inst) != OT_INSTANCE || type(cl) != OT_CLASS)
+		return sq_throwerror(v,_SC("invalid param type"));
+	return _instance(inst)->InstanceOf(_class(cl))?SQTrue:SQFalse;
+}
+
+SQRESULT sq_arrayappend(HSQUIRRELVM v,SQInteger idx)
+{
+	sq_aux_paramscheck(v,2);
+	SQObjectPtr *arr;
+	_GETSAFE_OBJ(v, idx, OT_ARRAY,arr);
+	_array(*arr)->Append(v->GetUp(-1));
+	v->Pop(1);
+	return SQ_OK;
+}
+
+SQRESULT sq_arraypop(HSQUIRRELVM v,SQInteger idx,SQBool pushval)
+{
+	sq_aux_paramscheck(v, 1);
+	SQObjectPtr *arr;
+	_GETSAFE_OBJ(v, idx, OT_ARRAY,arr);
+	if(_array(*arr)->Size() > 0) {
+        if(pushval != 0){ v->Push(_array(*arr)->Top()); }
+		_array(*arr)->Pop();
+		return SQ_OK;
+	}
+	return sq_throwerror(v, _SC("empty array"));
+}
+
+SQRESULT sq_arrayresize(HSQUIRRELVM v,SQInteger idx,SQInteger newsize)
+{
+	sq_aux_paramscheck(v,1);
+	SQObjectPtr *arr;
+	_GETSAFE_OBJ(v, idx, OT_ARRAY,arr);
+	if(_array(*arr)->Size() > 0) {
+		_array(*arr)->Resize(newsize);
+		return SQ_OK;
+	}
+	return SQ_OK;
+}
+
+SQRESULT sq_arrayreverse(HSQUIRRELVM v,SQInteger idx)
+{
+	sq_aux_paramscheck(v, 1);
+	SQObjectPtr *o;
+	_GETSAFE_OBJ(v, idx, OT_ARRAY,o);
+	SQArray *arr = _array(*o);
+	if(arr->Size() > 0) {
+		SQObjectPtr t;
+		SQInteger size = arr->Size();
+		SQInteger n = size >> 1; size -= 1;
+		for(SQInteger i = 0; i < n; i++) {
+			t = arr->_values[i];
+			arr->_values[i] = arr->_values[size-i];
+			arr->_values[size-i] = t;
+		}
+		return SQ_OK;
+	}
+	return SQ_OK;
+}
+
+void sq_newclosure(HSQUIRRELVM v,SQFUNCTION func,SQUnsignedInteger nfreevars)
+{
+	SQNativeClosure *nc = SQNativeClosure::Create(_ss(v), func);
+	nc->_nparamscheck = 0;
+	for(SQUnsignedInteger i = 0; i < nfreevars; i++) {
+		nc->_outervalues.push_back(v->Top());
+		v->Pop();
+	}
+	v->Push(SQObjectPtr(nc));	
+}
+
+SQRESULT sq_getclosureinfo(HSQUIRRELVM v,SQInteger idx,SQUnsignedInteger *nparams,SQUnsignedInteger *nfreevars)
+{
+	SQObject o = stack_get(v, idx);
+	if(sq_isclosure(o)) {
+		SQClosure *c = _closure(o);
+		SQFunctionProto *proto = _funcproto(c->_function);
+		*nparams = (SQUnsignedInteger)proto->_parameters.size();
+        *nfreevars = (SQUnsignedInteger)c->_outervalues.size();
+		return SQ_OK;
+	}
+	return sq_throwerror(v,_SC("the object is not a closure"));
+}
+
+SQRESULT sq_setnativeclosurename(HSQUIRRELVM v,SQInteger idx,const SQChar *name)
+{
+	SQObject o = stack_get(v, idx);
+	if(sq_isnativeclosure(o)) {
+		SQNativeClosure *nc = _nativeclosure(o);
+		nc->_name = SQString::Create(_ss(v),name);
+		return SQ_OK;
+	}
+	return sq_throwerror(v,_SC("the object is not a nativeclosure"));
+}
+
+SQRESULT sq_setparamscheck(HSQUIRRELVM v,SQInteger nparamscheck,const SQChar *typemask)
+{
+	SQObject o = stack_get(v, -1);
+	if(!sq_isnativeclosure(o))
+		return sq_throwerror(v, _SC("native closure expected"));
+	SQNativeClosure *nc = _nativeclosure(o);
+	nc->_nparamscheck = nparamscheck;
+	if(typemask) {
+		SQIntVec res;
+		if(!CompileTypemask(res, typemask))
+			return sq_throwerror(v, _SC("invalid typemask"));
+		nc->_typecheck.copy(res);
+	}
+	else {
+		nc->_typecheck.resize(0);
+	}
+	if(nparamscheck == SQ_MATCHTYPEMASKSTRING) {
+		nc->_nparamscheck = nc->_typecheck.size();
+	}
+	return SQ_OK;
+}
+
+SQRESULT sq_bindenv(HSQUIRRELVM v,SQInteger idx)
+{
+	SQObjectPtr &o = stack_get(v,idx);
+	if(!sq_isnativeclosure(o) &&
+		!sq_isclosure(o))
+		return sq_throwerror(v,_SC("the target is not a closure"));
+    SQObjectPtr &env = stack_get(v,-1);
+	if(!sq_istable(env) &&
+		!sq_isclass(env) &&
+		!sq_isinstance(env))
+		return sq_throwerror(v,_SC("invalid environment"));
+	SQObjectPtr w = _refcounted(env)->GetWeakRef(type(env));
+	SQObjectPtr ret;
+	if(sq_isclosure(o)) {
+		SQClosure *c = _closure(o)->Clone();
+		c->_env = w;
+		ret = c;
+	}
+	else { //then must be a native closure
+		SQNativeClosure *c = _nativeclosure(o)->Clone();
+		c->_env = w;
+		ret = c;
+	}
+	v->Pop();
+	v->Push(ret);
+	return SQ_OK;
+}
+
+void sq_pushroottable(HSQUIRRELVM v)
+{
+	v->Push(v->_roottable);
+}
+
+void sq_pushregistrytable(HSQUIRRELVM v)
+{
+	v->Push(_ss(v)->_registry);
+}
+
+SQRESULT sq_setroottable(HSQUIRRELVM v)
+{
+	SQObject o = stack_get(v, -1);
+	if(sq_istable(o) || sq_isnull(o)) {
+		v->_roottable = o;
+		v->Pop();
+		return SQ_OK;
+	}
+	return sq_throwerror(v, _SC("ivalid type"));
+}
+
+void sq_setforeignptr(HSQUIRRELVM v,SQUserPointer p)
+{
+	v->_foreignptr = p;
+}
+
+SQUserPointer sq_getforeignptr(HSQUIRRELVM v)
+{
+	return v->_foreignptr;
+}
+
+void sq_push(HSQUIRRELVM v,SQInteger idx)
+{
+	v->Push(stack_get(v, idx));
+}
+
+SQObjectType sq_gettype(HSQUIRRELVM v,SQInteger idx)
+{
+	return type(stack_get(v, idx));
+}
+
+void sq_tostring(HSQUIRRELVM v,SQInteger idx)
+{
+	SQObjectPtr &o = stack_get(v, idx);
+	SQObjectPtr res;
+	v->ToString(o,res);
+	v->Push(res);
+}
+
+void sq_tobool(HSQUIRRELVM v, SQInteger idx, SQBool *b)
+{
+	SQObjectPtr &o = stack_get(v, idx);
+	*b = v->IsFalse(o)?SQFalse:SQTrue;
+}
+
+SQRESULT sq_getinteger(HSQUIRRELVM v,SQInteger idx,SQInteger *i)
+{
+	SQObjectPtr &o = stack_get(v, idx);
+	if(sq_isnumeric(o)) {
+		*i = tointeger(o);
+		return SQ_OK;
+	}
+	return SQ_ERROR;
+}
+
+SQRESULT sq_getfloat(HSQUIRRELVM v,SQInteger idx,SQFloat *f)
+{
+	SQObjectPtr &o = stack_get(v, idx);
+	if(sq_isnumeric(o)) {
+		*f = tofloat(o);
+		return SQ_OK;
+	}
+	return SQ_ERROR;
+}
+
+SQRESULT sq_getbool(HSQUIRRELVM v,SQInteger idx,SQBool *b)
+{
+	SQObjectPtr &o = stack_get(v, idx);
+	if(sq_isbool(o)) {
+		*b = _integer(o);
+		return SQ_OK;
+	}
+	return SQ_ERROR;
+}
+
+SQRESULT sq_getstring(HSQUIRRELVM v,SQInteger idx,const SQChar **c)
+{
+	SQObjectPtr *o = NULL;
+	_GETSAFE_OBJ(v, idx, OT_STRING,o);
+	*c = _stringval(*o);
+	return SQ_OK;
+}
+
+SQRESULT sq_getthread(HSQUIRRELVM v,SQInteger idx,HSQUIRRELVM *thread)
+{
+	SQObjectPtr *o = NULL;
+	_GETSAFE_OBJ(v, idx, OT_THREAD,o);
+	*thread = _thread(*o);
+	return SQ_OK;
+}
+
+SQRESULT sq_clone(HSQUIRRELVM v,SQInteger idx)
+{
+	SQObjectPtr &o = stack_get(v,idx);
+	v->Push(_null_);
+	if(!v->Clone(o, stack_get(v, -1))){
+		v->Pop();
+		return sq_aux_invalidtype(v, type(o));
+	}
+	return SQ_OK;
+}
+
+SQInteger sq_getsize(HSQUIRRELVM v, SQInteger idx)
+{
+	SQObjectPtr &o = stack_get(v, idx);
+	SQObjectType type = type(o);
+	switch(type) {
+	case OT_STRING:		return _string(o)->_len;
+	case OT_TABLE:		return _table(o)->CountUsed();
+	case OT_ARRAY:		return _array(o)->Size();
+	case OT_USERDATA:	return _userdata(o)->_size;
+	default:
+		return sq_aux_invalidtype(v, type);
+	}
+}
+
+SQRESULT sq_getuserdata(HSQUIRRELVM v,SQInteger idx,SQUserPointer *p,SQUserPointer *typetag)
+{
+	SQObjectPtr *o = NULL;
+	_GETSAFE_OBJ(v, idx, OT_USERDATA,o);
+	(*p) = _userdataval(*o);
+	if(typetag) *typetag = _userdata(*o)->_typetag;
+	return SQ_OK;
+}
+
+SQRESULT sq_settypetag(HSQUIRRELVM v,SQInteger idx,SQUserPointer typetag)
+{
+	SQObjectPtr &o = stack_get(v,idx);
+	switch(type(o)) {
+		case OT_USERDATA:	_userdata(o)->_typetag = typetag;	break;
+		case OT_CLASS:		_class(o)->_typetag = typetag;		break;
+		default:			return sq_throwerror(v,_SC("invalid object type"));
+	}
+	return SQ_OK;
+}
+
+SQRESULT sq_getobjtypetag(HSQOBJECT *o,SQUserPointer * typetag)
+{
+  switch(type(*o)) {
+    case OT_INSTANCE: *typetag = _instance(*o)->_class->_typetag; break;
+    case OT_USERDATA: *typetag = _userdata(*o)->_typetag; break;
+    case OT_CLASS:    *typetag = _class(*o)->_typetag; break;
+    default: return SQ_ERROR;
+  }
+  return SQ_OK;
+}
+
+SQRESULT sq_gettypetag(HSQUIRRELVM v,SQInteger idx,SQUserPointer *typetag)
+{
+	SQObjectPtr &o = stack_get(v,idx);
+	if(SQ_FAILED(sq_getobjtypetag(&o,typetag)))
+		return sq_throwerror(v,_SC("invalid object type"));
+	return SQ_OK;
+}
+
+SQRESULT sq_getuserpointer(HSQUIRRELVM v, SQInteger idx, SQUserPointer *p)
+{
+	SQObjectPtr *o = NULL;
+	_GETSAFE_OBJ(v, idx, OT_USERPOINTER,o);
+	(*p) = _userpointer(*o);
+	return SQ_OK;
+}
+
+SQRESULT sq_setinstanceup(HSQUIRRELVM v, SQInteger idx, SQUserPointer p)
+{
+	SQObjectPtr &o = stack_get(v,idx);
+	if(type(o) != OT_INSTANCE) return sq_throwerror(v,_SC("the object is not a class instance"));
+	_instance(o)->_userpointer = p;
+	return SQ_OK;
+}
+
+SQRESULT sq_getinstanceup(HSQUIRRELVM v, SQInteger idx, SQUserPointer *p,SQUserPointer typetag)
+{
+	SQObjectPtr &o = stack_get(v,idx);
+	if(type(o) != OT_INSTANCE) return sq_throwerror(v,_SC("the object is not a class instance"));
+	(*p) = _instance(o)->_userpointer;
+	if(typetag != 0) {
+		SQClass *cl = _instance(o)->_class;
+		do{
+			if(cl->_typetag == typetag)
+				return SQ_OK;
+			cl = cl->_base;
+		}while(cl != NULL);
+		return sq_throwerror(v,_SC("invalid type tag"));
+	}
+	return SQ_OK;
+}
+
+SQInteger sq_gettop(HSQUIRRELVM v)
+{
+	return (v->_top) - v->_stackbase;
+}
+
+void sq_settop(HSQUIRRELVM v, SQInteger newtop)
+{
+	SQInteger top = sq_gettop(v);
+	if(top > newtop)
+		sq_pop(v, top - newtop);
+	else
+		while(top < newtop) sq_pushnull(v);
+}
+
+void sq_pop(HSQUIRRELVM v, SQInteger nelemstopop)
+{
+	assert(v->_top >= nelemstopop);
+	v->Pop(nelemstopop);
+}
+
+void sq_poptop(HSQUIRRELVM v)
+{
+	assert(v->_top >= 1);
+    v->Pop();
+}
+
+
+void sq_remove(HSQUIRRELVM v, SQInteger idx)
+{
+	v->Remove(idx);
+}
+
+SQInteger sq_cmp(HSQUIRRELVM v)
+{
+	SQInteger res;
+	v->ObjCmp(stack_get(v, -1), stack_get(v, -2),res);
+	return res;
+}
+
+SQRESULT sq_newslot(HSQUIRRELVM v, SQInteger idx, SQBool bstatic)
+{
+	sq_aux_paramscheck(v, 3);
+	SQObjectPtr &self = stack_get(v, idx);
+	if(type(self) == OT_TABLE || type(self) == OT_CLASS) {
+		SQObjectPtr &key = v->GetUp(-2);
+		if(type(key) == OT_NULL) return sq_throwerror(v, _SC("null is not a valid key"));
+		v->NewSlot(self, key, v->GetUp(-1),bstatic?true:false);
+		v->Pop(2);
+	}
+	return SQ_OK;
+}
+
+/*SQRESULT sq_createslot(HSQUIRRELVM v, SQInteger idx)
+{
+	sq_aux_paramscheck(v, 3);
+	SQObjectPtr &self = stack_get(v, idx);
+	if(type(self) == OT_TABLE || type(self) == OT_CLASS) {
+		SQObjectPtr &key = v->GetUp(-2);
+		if(type(key) == OT_NULL) return sq_throwerror(v, _SC("null is not a valid key"));
+		v->NewSlot(self, key, v->GetUp(-1));
+		v->Pop(2);
+	}
+	return SQ_OK;
+}*/
+
+SQRESULT sq_deleteslot(HSQUIRRELVM v,SQInteger idx,SQBool pushval)
+{
+	sq_aux_paramscheck(v, 2);
+	SQObjectPtr *self;
+	_GETSAFE_OBJ(v, idx, OT_TABLE,self);
+	SQObjectPtr &key = v->GetUp(-1);
+	if(type(key) == OT_NULL) return sq_throwerror(v, _SC("null is not a valid key"));
+	SQObjectPtr res;
+	if(!v->DeleteSlot(*self, key, res)){
+		return SQ_ERROR;
+	}
+	if(pushval)	v->GetUp(-1) = res;
+	else v->Pop(1);
+	return SQ_OK;
+}
+
+SQRESULT sq_set(HSQUIRRELVM v,SQInteger idx)
+{
+	SQObjectPtr &self = stack_get(v, idx);
+	if(v->Set(self, v->GetUp(-2), v->GetUp(-1),false)) {
+		v->Pop(2);
+		return SQ_OK;
+	}
+	v->Raise_IdxError(v->GetUp(-2));return SQ_ERROR;
+}
+
+SQRESULT sq_rawset(HSQUIRRELVM v,SQInteger idx)
+{
+	SQObjectPtr &self = stack_get(v, idx);
+	if(type(v->GetUp(-2)) == OT_NULL) return sq_throwerror(v, _SC("null key"));
+	switch(type(self)) {
+	case OT_TABLE:
+		_table(self)->NewSlot(v->GetUp(-2), v->GetUp(-1));
+		v->Pop(2);
+		return SQ_OK;
+	break;
+	case OT_CLASS:
+		_class(self)->NewSlot(_ss(v), v->GetUp(-2), v->GetUp(-1),false);
+		v->Pop(2);
+		return SQ_OK;
+	break;
+	case OT_INSTANCE:
+		if(_instance(self)->Set(v->GetUp(-2), v->GetUp(-1))) {
+			v->Pop(2);
+			return SQ_OK;
+		}
+	break;
+	case OT_ARRAY:
+		if(v->Set(self, v->GetUp(-2), v->GetUp(-1),false)) {
+			v->Pop(2);
+			return SQ_OK;
+		}
+	break;
+	default:
+		v->Pop(2);
+		return sq_throwerror(v, _SC("rawset works only on array/table/calsse and instance"));
+	}
+	v->Raise_IdxError(v->GetUp(-2));return SQ_ERROR;
+}
+
+SQRESULT sq_setdelegate(HSQUIRRELVM v,SQInteger idx)
+{
+	SQObjectPtr &self = stack_get(v, idx);
+	SQObjectPtr &mt = v->GetUp(-1);
+	SQObjectType type = type(self);
+	switch(type) {
+	case OT_TABLE:
+		if(type(mt) == OT_TABLE) {
+			if(!_table(self)->SetDelegate(_table(mt))) return sq_throwerror(v, _SC("delagate cycle")); v->Pop();}
+		else if(type(mt)==OT_NULL) {
+			_table(self)->SetDelegate(NULL); v->Pop(); }
+		else return sq_aux_invalidtype(v,type);
+		break;
+	case OT_USERDATA:
+		if(type(mt)==OT_TABLE) {
+			_userdata(self)->SetDelegate(_table(mt)); v->Pop(); }
+		else if(type(mt)==OT_NULL) {
+			_userdata(self)->SetDelegate(NULL); v->Pop(); }
+		else return sq_aux_invalidtype(v, type);
+		break;
+	default:
+			return sq_aux_invalidtype(v, type);
+		break;
+	}
+	return SQ_OK;
+}
+
+SQRESULT sq_rawdeleteslot(HSQUIRRELVM v,SQInteger idx,SQBool pushval)
+{
+	sq_aux_paramscheck(v, 2);
+	SQObjectPtr *self;
+	_GETSAFE_OBJ(v, idx, OT_TABLE,self);
+	SQObjectPtr &key = v->GetUp(-1);
+	SQObjectPtr t;
+	if(_table(*self)->Get(key,t)) {
+		_table(*self)->Remove(key);
+	}
+	if(pushval != 0)
+		if(pushval)	v->GetUp(-1) = t;
+	else
+		v->Pop(1);
+	return SQ_OK;
+}
+
+SQRESULT sq_getdelegate(HSQUIRRELVM v,SQInteger idx)
+{
+	SQObjectPtr &self=stack_get(v,idx);
+	switch(type(self)){
+	case OT_TABLE:
+		if(!_table(self)->_delegate)break;
+		v->Push(SQObjectPtr(_table(self)->_delegate));
+		break;
+	case OT_USERDATA:
+		if(!_userdata(self)->_delegate)break;
+		v->Push(SQObjectPtr(_userdata(self)->_delegate));
+		break;
+	default: return sq_throwerror(v,_SC("wrong type")); break;
+	}
+	return SQ_OK;
+	
+}
+
+SQRESULT sq_get(HSQUIRRELVM v,SQInteger idx)
+{
+	SQObjectPtr &self=stack_get(v,idx);
+	if(v->Get(self,v->GetUp(-1),v->GetUp(-1),false,false))
+		return SQ_OK;
+	v->Pop(1);
+	return sq_throwerror(v,_SC("the index doesn't exist"));
+}
+
+SQRESULT sq_rawget(HSQUIRRELVM v,SQInteger idx)
+{
+	SQObjectPtr &self=stack_get(v,idx);
+	switch(type(self)) {
+	case OT_TABLE:
+		if(_table(self)->Get(v->GetUp(-1),v->GetUp(-1)))
+			return SQ_OK;
+		break;
+	case OT_CLASS:
+		if(_class(self)->Get(v->GetUp(-1),v->GetUp(-1)))
+			return SQ_OK;
+		break;
+	case OT_INSTANCE:
+		if(_instance(self)->Get(v->GetUp(-1),v->GetUp(-1)))
+			return SQ_OK;
+		break;
+	case OT_ARRAY:
+		if(v->Get(self,v->GetUp(-1),v->GetUp(-1),false,false))
+			return SQ_OK;
+		break;
+	default:
+		v->Pop(1);
+		return sq_throwerror(v,_SC("rawget works only on array/table/instance and class"));
+	}	
+	v->Pop(1);
+	return sq_throwerror(v,_SC("the index doesn't exist"));
+}
+
+SQRESULT sq_getstackobj(HSQUIRRELVM v,SQInteger idx,HSQOBJECT *po)
+{
+	*po=stack_get(v,idx);
+	return SQ_OK;
+}
+
+const SQChar *sq_getlocal(HSQUIRRELVM v,SQUnsignedInteger level,SQUnsignedInteger idx)
+{
+	SQUnsignedInteger cstksize=v->_callsstack.size();
+	SQUnsignedInteger lvl=(cstksize-level)-1;
+	SQInteger stackbase=v->_stackbase;
+	if(lvl<cstksize){
+		for(SQUnsignedInteger i=0;i<level;i++){
+			SQVM::CallInfo &ci=v->_callsstack[(cstksize-i)-1];
+			stackbase-=ci._prevstkbase;
+		}
+		SQVM::CallInfo &ci=v->_callsstack[lvl];
+		if(type(ci._closure)!=OT_CLOSURE)
+			return NULL;
+		SQClosure *c=_closure(ci._closure);
+		SQFunctionProto *func=_funcproto(c->_function);
+		return func->GetLocal(v,stackbase,idx,(SQInteger)(ci._ip-func->_instructions._vals)-1);
+	}
+	return NULL;
+}
+
+void sq_pushobject(HSQUIRRELVM v,HSQOBJECT obj)
+{
+	v->Push(SQObjectPtr(obj));
+}
+
+void sq_resetobject(HSQOBJECT *po)
+{
+	po->_unVal.pUserPointer=NULL;po->_type=OT_NULL;
+}
+
+SQRESULT sq_throwerror(HSQUIRRELVM v,const SQChar *err)
+{
+	v->_lasterror=SQString::Create(_ss(v),err);
+	return -1;
+}
+
+void sq_reseterror(HSQUIRRELVM v)
+{
+	v->_lasterror = _null_;
+}
+
+void sq_getlasterror(HSQUIRRELVM v)
+{
+	v->Push(v->_lasterror);
+}
+
+void sq_reservestack(HSQUIRRELVM v,SQInteger nsize)
+{
+	if (((SQUnsignedInteger)v->_top + nsize) > v->_stack.size()) {
+		v->_stack.resize(v->_stack.size() + ((v->_top + nsize) - v->_stack.size()));
+	}
+}
+
+SQRESULT sq_resume(HSQUIRRELVM v,SQBool retval,SQBool raiseerror)
+{
+	if(type(v->GetUp(-1))==OT_GENERATOR){
+		v->Push(_null_); //retval
+		if(!v->Execute(v->GetUp(-2),v->_top,0,v->_top,v->GetUp(-1),raiseerror,SQVM::ET_RESUME_GENERATOR))
+		{v->Raise_Error(v->_lasterror); return SQ_ERROR;}
+		if(!retval)
+			v->Pop();
+		return SQ_OK;
+	}
+	return sq_throwerror(v,_SC("only generators can be resumed"));
+}
+
+SQRESULT sq_call(HSQUIRRELVM v,SQInteger params,SQBool retval,SQBool raiseerror)
+{
+	SQObjectPtr res;
+	if(v->Call(v->GetUp(-(params+1)),params,v->_top-params,res,raiseerror?true:false)){
+		v->Pop(params);//pop closure and args
+		if(retval){
+			v->Push(res); return SQ_OK;
+		}
+		return SQ_OK;
+	}
+	else {
+		v->Pop(params);
+		return SQ_ERROR;
+	}
+	if(!v->_suspended)
+		v->Pop(params);
+	return sq_throwerror(v,_SC("call failed"));
+}
+
+SQRESULT sq_suspendvm(HSQUIRRELVM v)
+{
+	return v->Suspend();
+}
+
+SQRESULT sq_wakeupvm(HSQUIRRELVM v,SQBool wakeupret,SQBool retval,SQBool raiseerror)
+{
+	SQObjectPtr ret;
+	if(!v->_suspended)
+		return sq_throwerror(v,_SC("cannot resume a vm that is not running any code"));
+	if(wakeupret) {
+		v->GetAt(v->_stackbase+v->_suspended_target)=v->GetUp(-1); //retval
+		v->Pop();
+	} else v->GetAt(v->_stackbase+v->_suspended_target)=_null_;
+	if(!v->Execute(_null_,v->_top,-1,-1,ret,raiseerror,SQVM::ET_RESUME_VM))
+		return SQ_ERROR;
+	if(sq_getvmstate(v) == SQ_VMSTATE_IDLE) {
+		while (v->_top > 1) v->_stack[--v->_top] = _null_;
+	}
+	if(retval)
+		v->Push(ret);
+	return SQ_OK;
+}
+
+void sq_setreleasehook(HSQUIRRELVM v,SQInteger idx,SQRELEASEHOOK hook)
+{
+	if(sq_gettop(v) >= 1){
+		SQObjectPtr &ud=stack_get(v,idx);
+		switch( type(ud) ) {
+		case OT_USERDATA:	_userdata(ud)->_hook = hook;	break;
+		case OT_INSTANCE:	_instance(ud)->_hook = hook;	break;
+		case OT_CLASS:		_class(ud)->_hook = hook;		break;
+		default: break; //shutup compiler
+		}
+	}
+}
+
+void sq_setcompilererrorhandler(HSQUIRRELVM v,SQCOMPILERERROR f)
+{
+	_ss(v)->_compilererrorhandler = f;
+}
+
+SQRESULT sq_writeclosure(HSQUIRRELVM v,SQWRITEFUNC w,SQUserPointer up)
+{
+	SQObjectPtr *o = NULL;
+	_GETSAFE_OBJ(v, -1, OT_CLOSURE,o);
+	unsigned short tag = SQ_BYTECODE_STREAM_TAG;
+	if(w(up,&tag,2) != 2)
+		return sq_throwerror(v,_SC("io error"));
+	if(!_closure(*o)->Save(v,up,w))
+		return SQ_ERROR;
+	return SQ_OK;
+}
+
+SQRESULT sq_readclosure(HSQUIRRELVM v,SQREADFUNC r,SQUserPointer up)
+{
+	SQObjectPtr func=SQFunctionProto::Create();
+	SQObjectPtr closure=SQClosure::Create(_ss(v),_funcproto(func));
+	unsigned short tag;
+	if(r(up,&tag,2) != 2)
+		return sq_throwerror(v,_SC("io error"));
+	if(tag != SQ_BYTECODE_STREAM_TAG)
+		return sq_throwerror(v,_SC("invalid stream"));
+	if(!_closure(closure)->Load(v,up,r))
+		return SQ_ERROR;
+	v->Push(closure);
+	return SQ_OK;
+}
+
+SQChar *sq_getscratchpad(HSQUIRRELVM v,SQInteger minsize)
+{
+	return _ss(v)->GetScratchPad(minsize);
+}
+
+SQInteger sq_collectgarbage(HSQUIRRELVM v)
+{
+#ifndef NO_GARBAGE_COLLECTOR
+	return _ss(v)->CollectGarbage(v);
+#else
+	return -1;
+#endif
+}
+
+const SQChar *sq_getfreevariable(HSQUIRRELVM v,SQInteger idx,SQUnsignedInteger nval)
+{
+	SQObjectPtr &self = stack_get(v,idx);
+	const SQChar *name = NULL;
+	if(type(self) == OT_CLOSURE) {
+		if(_closure(self)->_outervalues.size()>nval) {
+			v->Push(_closure(self)->_outervalues[nval]);
+			SQFunctionProto *fp = _funcproto(_closure(self)->_function);
+			SQOuterVar &ov = fp->_outervalues[nval];
+			name = _stringval(ov._name);
+		}
+	}
+	return name;
+}
+
+SQRESULT sq_setfreevariable(HSQUIRRELVM v,SQInteger idx,SQUnsignedInteger nval)
+{
+	SQObjectPtr &self=stack_get(v,idx);
+	switch(type(self))
+	{
+	case OT_CLOSURE:
+		if(_closure(self)->_outervalues.size()>nval){
+			_closure(self)->_outervalues[nval]=stack_get(v,-1);
+		}
+		else return sq_throwerror(v,_SC("invalid free var index"));
+		break;
+	case OT_NATIVECLOSURE:
+		if(_nativeclosure(self)->_outervalues.size()>nval){
+			_nativeclosure(self)->_outervalues[nval]=stack_get(v,-1);
+		}
+		else return sq_throwerror(v,_SC("invalid free var index"));
+		break;
+	default:
+		return sq_aux_invalidtype(v,type(self));
+	}
+	v->Pop(1);
+	return SQ_OK;
+}
+
+SQRESULT sq_setattributes(HSQUIRRELVM v,SQInteger idx)
+{
+	SQObjectPtr *o = NULL;
+	_GETSAFE_OBJ(v, idx, OT_CLASS,o);
+	SQObjectPtr &key = stack_get(v,-2);
+	SQObjectPtr &val = stack_get(v,-1);
+	SQObjectPtr attrs;
+	if(type(key) == OT_NULL) {
+		attrs = _class(*o)->_attributes;
+		_class(*o)->_attributes = val;
+		v->Pop(2);
+		v->Push(attrs);
+		return SQ_OK;
+	}else if(_class(*o)->GetAttributes(key,attrs)) {
+		_class(*o)->SetAttributes(key,val);
+		v->Pop(2);
+		v->Push(attrs);
+		return SQ_OK;
+	}
+	return sq_throwerror(v,_SC("wrong index"));
+}
+
+SQRESULT sq_getattributes(HSQUIRRELVM v,SQInteger idx)
+{
+	SQObjectPtr *o = NULL;
+	_GETSAFE_OBJ(v, idx, OT_CLASS,o);
+	SQObjectPtr &key = stack_get(v,-1);
+	SQObjectPtr attrs;
+	if(type(key) == OT_NULL) {
+		attrs = _class(*o)->_attributes;
+		v->Pop();
+		v->Push(attrs); 
+		return SQ_OK;
+	}
+	else if(_class(*o)->GetAttributes(key,attrs)) {
+		v->Pop();
+		v->Push(attrs);
+		return SQ_OK;
+	}
+	return sq_throwerror(v,_SC("wrong index"));
+}
+
+SQRESULT sq_getbase(HSQUIRRELVM v,SQInteger idx)
+{
+	SQObjectPtr *o = NULL;
+	_GETSAFE_OBJ(v, idx, OT_CLASS,o);
+	if(_class(*o)->_base)
+		v->Push(SQObjectPtr(_class(*o)->_base));
+	else
+		v->Push(_null_);
+	return SQ_OK;
+}
+
+SQRESULT sq_getclass(HSQUIRRELVM v,SQInteger idx)
+{
+	SQObjectPtr *o = NULL;
+	_GETSAFE_OBJ(v, idx, OT_INSTANCE,o);
+	v->Push(SQObjectPtr(_instance(*o)->_class));
+	return SQ_OK;
+}
+
+SQRESULT sq_createinstance(HSQUIRRELVM v,SQInteger idx)
+{
+	SQObjectPtr *o = NULL;
+	_GETSAFE_OBJ(v, idx, OT_CLASS,o);
+	v->Push(_class(*o)->CreateInstance());
+	return SQ_OK;
+}
+
+void sq_weakref(HSQUIRRELVM v,SQInteger idx)
+{
+	SQObject &o=stack_get(v,idx);
+	if(ISREFCOUNTED(type(o))) {
+		v->Push(_refcounted(o)->GetWeakRef(type(o)));
+		return;
+	}
+	v->Push(o);
+}
+
+SQRESULT sq_getweakrefval(HSQUIRRELVM v,SQInteger idx)
+{
+	SQObjectPtr &o = stack_get(v,idx);
+	if(type(o) != OT_WEAKREF) {
+		return sq_throwerror(v,_SC("the object must be a weakref"));
+	}
+	v->Push(_weakref(o)->_obj);
+	return SQ_OK;
+}
+
+SQRESULT sq_getdefaultdelegate(HSQUIRRELVM v,SQObjectType t)
+{
+	SQSharedState *ss = _ss(v);
+	switch(t) {
+	case OT_TABLE: v->Push(ss->_table_default_delegate); break;
+	case OT_ARRAY: v->Push(ss->_array_default_delegate); break;
+	case OT_STRING: v->Push(ss->_string_default_delegate); break;
+	case OT_INTEGER: case OT_FLOAT: v->Push(ss->_number_default_delegate); break;
+	case OT_GENERATOR: v->Push(ss->_generator_default_delegate); break;
+	case OT_CLOSURE: case OT_NATIVECLOSURE: v->Push(ss->_closure_default_delegate); break;
+	case OT_THREAD: v->Push(ss->_thread_default_delegate); break;
+	case OT_CLASS: v->Push(ss->_class_default_delegate); break;
+	case OT_INSTANCE: v->Push(ss->_instance_default_delegate); break;
+	case OT_WEAKREF: v->Push(ss->_weakref_default_delegate); break;
+	default: return sq_throwerror(v,_SC("the type doesn't have a default delegate"));
+	}
+	return SQ_OK;
+}
+
+SQRESULT sq_next(HSQUIRRELVM v,SQInteger idx)
+{
+	SQObjectPtr o=stack_get(v,idx),&refpos = stack_get(v,-1),realkey,val;
+	if(type(o) == OT_GENERATOR) {
+		return sq_throwerror(v,_SC("cannot iterate a generator"));
+	}
+	bool finished;
+	if(!v->FOREACH_OP(o,realkey,val,refpos,0,finished))
+		return SQ_ERROR;
+	if(!finished) {
+		v->Push(realkey);
+		v->Push(val);
+		return SQ_OK;
+	}
+	return SQ_ERROR;
+}
+
+struct BufState{
+	const SQChar *buf;
+	SQInteger ptr;
+	SQInteger size;
+};
+
+SQInteger buf_lexfeed(SQUserPointer file)
+{
+	BufState *buf=(BufState*)file;
+	if(buf->size<(buf->ptr+1))
+		return 0;
+	return buf->buf[buf->ptr++];
+}
+
+SQRESULT sq_compilebuffer(HSQUIRRELVM v,const SQChar *s,SQInteger size,const SQChar *sourcename,SQBool raiseerror) {
+	BufState buf;
+	buf.buf = s;
+	buf.size = size;
+	buf.ptr = 0;
+	return sq_compile(v, buf_lexfeed, &buf, sourcename, raiseerror);
+}
+
+void sq_move(HSQUIRRELVM dest,HSQUIRRELVM src,SQInteger idx)
+{
+	dest->Push(stack_get(src,idx));
+}
+
+void sq_setprintfunc(HSQUIRRELVM v, SQPRINTFUNCTION printfunc)
+{
+	_ss(v)->_printfunc = printfunc;
+}
+
+SQPRINTFUNCTION sq_getprintfunc(HSQUIRRELVM v)
+{
+	return _ss(v)->_printfunc;
+}
+
+void *sq_malloc(SQUnsignedInteger size)
+{
+	return SQ_MALLOC(size);
+}
+
+void *sq_realloc(void* p,SQUnsignedInteger oldsize,SQUnsignedInteger newsize)
+{
+	return SQ_REALLOC(p,oldsize,newsize);
+}
+void sq_free(void *p,SQUnsignedInteger size)
+{
+	SQ_FREE(p,size);
+}
diff -rupwN ../dnl3/SqPlus/_squirrel/sqarray.h SqPlus/_squirrel/sqarray.h
--- ../dnl3/SqPlus/_squirrel/sqarray.h	1969-12-31 19:00:00.000000000 -0500
+++ SqPlus/_squirrel/sqarray.h	2005-09-25 17:56:20.000000000 -0400
@@ -0,0 +1,79 @@
+/*	see copyright notice in squirrel.h */
+#ifndef _SQARRAY_H_
+#define _SQARRAY_H_
+
+struct SQArray : public CHAINABLE_OBJ
+{
+private:
+	SQArray(SQSharedState *ss,SQInteger nsize){_values.resize(nsize); INIT_CHAIN();ADD_TO_CHAIN(&_ss(this)->_gc_chain,this);}
+	~SQArray()
+	{
+		REMOVE_FROM_CHAIN(&_ss(this)->_gc_chain,this);
+	}
+public:
+	static SQArray* Create(SQSharedState *ss,SQInteger nInitialSize){
+		SQArray *newarray=(SQArray*)SQ_MALLOC(sizeof(SQArray));
+		new (newarray) SQArray(ss,nInitialSize);
+		return newarray;
+	}
+#ifndef NO_GARBAGE_COLLECTOR
+	void Mark(SQCollectable **chain);
+#endif
+	void Finalize(){
+		_values.resize(0);
+	}
+	bool Get(const SQInteger nidx,SQObjectPtr &val)
+	{
+		if(nidx>=0 && nidx<(SQInteger)_values.size()){
+			SQObjectPtr &o = _values[nidx];
+			val = _realval(o);
+			return true;
+		}
+		else return false;
+	}
+	bool Set(const SQInteger nidx,const SQObjectPtr &val)
+	{
+		if(nidx>=0 && nidx<(SQInteger)_values.size()){
+			_values[nidx]=val;
+			return true;
+		}
+		else return false;
+	}
+	SQInteger Next(const SQObjectPtr &refpos,SQObjectPtr &outkey,SQObjectPtr &outval)
+	{
+		SQUnsignedInteger idx=TranslateIndex(refpos);
+		while(idx<_values.size()){
+			//first found
+			outkey=(SQInteger)idx;
+			SQObjectPtr &o = _values[idx];
+			outval = _realval(o);
+			//return idx for the next iteration
+			return ++idx;
+		}
+		//nothing to iterate anymore
+		return -1;
+	}
+	SQArray *Clone(){SQArray *anew=Create(_opt_ss(this),Size()); anew->_values.copy(_values); return anew; }
+	SQInteger Size() const {return _values.size();}
+	void Resize(SQInteger size,SQObjectPtr &fill = _null_) { _values.resize(size,fill); ShrinkIfNeeded(); }
+	void Reserve(SQInteger size) { _values.reserve(size); }
+	void Append(const SQObject &o){_values.push_back(o);}
+	void Extend(const SQArray *a);
+	SQObjectPtr &Top(){return _values.top();}
+	void Pop(){_values.pop_back(); ShrinkIfNeeded(); }
+	void Insert(const SQObject& idx,const SQObject &val){_values.insert((SQUnsignedInteger)tointeger(idx),val);}
+	void ShrinkIfNeeded() {
+		if(_values.size() <= _values.capacity()>>2) //shrink the array
+			_values.shrinktofit();
+	}
+	void Remove(SQUnsignedInteger idx){
+		_values.remove(idx);
+		ShrinkIfNeeded();
+	}
+	void Release()
+	{
+		sq_delete(this,SQArray);
+	}
+	SQObjectPtrVec _values;
+};
+#endif //_SQARRAY_H_
diff -rupwN ../dnl3/SqPlus/_squirrel/sqbaselib.cpp SqPlus/_squirrel/sqbaselib.cpp
--- ../dnl3/SqPlus/_squirrel/sqbaselib.cpp	1969-12-31 19:00:00.000000000 -0500
+++ SqPlus/_squirrel/sqbaselib.cpp	2006-03-19 14:32:58.000000000 -0500
@@ -0,0 +1,862 @@
+/*
+	see copyright notice in squirrel.h
+*/
+#include "sqpcheader.h"
+#include "sqvm.h"
+#include "sqstring.h"
+#include "sqtable.h"
+#include "sqarray.h"
+#include "sqfuncproto.h"
+#include "sqclosure.h"
+#include "sqclass.h"
+#include <stdlib.h>
+#include <stdarg.h>
+#include <ctype.h>
+
+bool str2num(const SQChar *s,SQObjectPtr &res)
+{
+	SQChar *end;
+	if(scstrstr(s,_SC("."))){
+		SQFloat r = SQFloat(scstrtod(s,&end));
+		if(s == end) return false;
+		res = r;
+		return true;
+	}
+	else{
+		SQInteger r = SQInteger(scstrtol(s,&end,10));
+		if(s == end) return false;
+		res = r;
+		return true;
+	}
+}
+
+#ifndef NO_GARBAGE_COLLECTOR
+static SQInteger base_collectgarbage(HSQUIRRELVM v)
+{
+	sq_pushinteger(v, sq_collectgarbage(v));
+	return 1;
+}
+#endif
+
+static SQInteger base_getroottable(HSQUIRRELVM v)
+{
+	v->Push(v->_roottable);
+	return 1;
+}
+
+static SQInteger base_setroottable(HSQUIRRELVM v)
+{
+	SQObjectPtr &o=stack_get(v,2);
+	if(SQ_FAILED(sq_setroottable(v))) return SQ_ERROR;
+	v->Push(o);
+	return 1;
+}
+
+static SQInteger base_seterrorhandler(HSQUIRRELVM v)
+{
+	sq_seterrorhandler(v);
+	return 0;
+}
+
+static SQInteger base_setdebughook(HSQUIRRELVM v)
+{
+	sq_setdebughook(v);
+	return 0;
+}
+
+static SQInteger base_enabledebuginfo(HSQUIRRELVM v)
+{
+	SQObjectPtr &o=stack_get(v,2);
+	sq_enabledebuginfo(v,(type(o) != OT_NULL)?1:0);
+	return 0;
+}
+
+static SQInteger base_getstackinfos(HSQUIRRELVM v)
+{
+	SQInteger level;
+	SQStackInfos si;
+	SQInteger seq = 0;
+	const SQChar *name = NULL;
+	sq_getinteger(v, -1, &level);
+	if (SQ_SUCCEEDED(sq_stackinfos(v, level, &si)))
+	{
+		const SQChar *fn = _SC("unknown");
+		const SQChar *src = _SC("unknown");
+		if(si.funcname)fn = si.funcname;
+		if(si.source)src = si.source;
+		sq_newtable(v);
+		sq_pushstring(v, _SC("func"), -1);
+		sq_pushstring(v, fn, -1);
+		sq_createslot(v, -3);
+		sq_pushstring(v, _SC("src"), -1);
+		sq_pushstring(v, src, -1);
+		sq_createslot(v, -3);
+		sq_pushstring(v, _SC("line"), -1);
+		sq_pushinteger(v, si.line);
+		sq_createslot(v, -3);
+		sq_pushstring(v, _SC("locals"), -1);
+		sq_newtable(v);
+		seq=0;
+		while ((name = sq_getlocal(v, level, seq))) {
+			sq_pushstring(v, name, -1);
+			sq_push(v, -2);
+			sq_createslot(v, -4);
+			sq_pop(v, 1);
+			seq++;
+		}
+		sq_createslot(v, -3);
+		return 1;
+	}
+
+	return 0;
+}
+
+static SQInteger base_assert(HSQUIRRELVM v)
+{
+	if(v->IsFalse(stack_get(v,2))){
+		return sq_throwerror(v,_SC("assertion failed"));
+	}
+	return 0;
+}
+
+static SQInteger get_slice_params(HSQUIRRELVM v,SQInteger &sidx,SQInteger &eidx,SQObjectPtr &o)
+{
+	SQInteger top = sq_gettop(v);
+	sidx=0;
+	eidx=0;
+	o=stack_get(v,1);
+	SQObjectPtr &start=stack_get(v,2);
+	if(type(start)!=OT_NULL && sq_isnumeric(start)){
+		sidx=tointeger(start);
+	}
+	if(top>2){
+		SQObjectPtr &end=stack_get(v,3);
+		if(sq_isnumeric(end)){
+			eidx=tointeger(end);
+		}
+	}
+	else {
+		eidx = sq_getsize(v,1);
+	}
+	return 1;
+}
+
+static SQInteger base_print(HSQUIRRELVM v)
+{
+	const SQChar *str;
+	sq_tostring(v,2);
+	sq_getstring(v,-1,&str);
+	if(_ss(v)->_printfunc) _ss(v)->_printfunc(v,_SC("%s"),str);
+	return 0;
+}
+
+static SQInteger base_compilestring(HSQUIRRELVM v)
+{
+	SQInteger nargs=sq_gettop(v);
+	const SQChar *src=NULL,*name=_SC("unnamedbuffer");
+	SQInteger size;
+	sq_getstring(v,2,&src);
+	size=sq_getsize(v,2);
+	if(nargs>2){
+		sq_getstring(v,3,&name);
+	}
+	if(SQ_SUCCEEDED(sq_compilebuffer(v,src,size,name,SQFalse)))
+		return 1;
+	else
+		return SQ_ERROR;
+}
+
+static SQInteger base_newthread(HSQUIRRELVM v)
+{
+	SQObjectPtr &func = stack_get(v,2);
+	SQInteger stksize = (_funcproto(_closure(func)->_function)->_stacksize << 1) +2;
+	HSQUIRRELVM newv = sq_newthread(v, (stksize < MIN_STACK_OVERHEAD + 2)? MIN_STACK_OVERHEAD + 2 : stksize);
+	sq_move(newv,v,-2);
+	return 1;
+}
+
+static SQInteger base_suspend(HSQUIRRELVM v)
+{
+	return sq_suspendvm(v);
+}
+
+static SQInteger base_array(HSQUIRRELVM v)
+{
+	SQArray *a;
+	SQObject &size = stack_get(v,2);
+	if(sq_gettop(v) > 2) {
+		a = SQArray::Create(_ss(v),0);
+		a->Resize(tointeger(size),stack_get(v,3));
+	}
+	else {
+		a = SQArray::Create(_ss(v),tointeger(size));
+	}
+	v->Push(a);
+	return 1;
+}
+
+static SQInteger base_type(HSQUIRRELVM v)
+{
+	SQObjectPtr &o = stack_get(v,2);
+	v->Push(SQString::Create(_ss(v),GetTypeName(o),-1));
+	return 1;
+}
+
+static SQRegFunction base_funcs[]={
+	//generic
+	{_SC("seterrorhandler"),base_seterrorhandler,2, NULL},
+	{_SC("setdebughook"),base_setdebughook,2, NULL},
+	{_SC("enabledebuginfo"),base_enabledebuginfo,2, NULL},
+	{_SC("getstackinfos"),base_getstackinfos,2, _SC(".n")},
+	{_SC("getroottable"),base_getroottable,1, NULL},
+	{_SC("setroottable"),base_setroottable,2, NULL},
+	{_SC("assert"),base_assert,2, NULL},
+	{_SC("print"),base_print,2, NULL},
+	{_SC("compilestring"),base_compilestring,-2, _SC(".ss")},
+	{_SC("newthread"),base_newthread,2, _SC(".c")},
+	{_SC("suspend"),base_suspend,-1, NULL},
+	{_SC("array"),base_array,-2, _SC(".n")},
+	{_SC("type"),base_type,2, NULL},
+#ifndef NO_GARBAGE_COLLECTOR
+	{_SC("collectgarbage"),base_collectgarbage,1, _SC("t")},
+#endif
+	{0,0}
+};
+
+void sq_base_register(HSQUIRRELVM v)
+{
+	SQInteger i=0;
+	sq_pushroottable(v);
+	while(base_funcs[i].name!=0) {
+		sq_pushstring(v,base_funcs[i].name,-1);
+		sq_newclosure(v,base_funcs[i].f,0);
+		sq_setnativeclosurename(v,-1,base_funcs[i].name);
+		sq_setparamscheck(v,base_funcs[i].nparamscheck,base_funcs[i].typemask);
+		sq_createslot(v,-3);
+		i++;
+	}
+	sq_pushstring(v,_SC("_charsize_"),-1);
+	sq_pushinteger(v,sizeof(SQChar));
+	sq_createslot(v,-3);
+	sq_pushstring(v,_SC("_intsize_"),-1);
+	sq_pushinteger(v,sizeof(SQInteger));
+	sq_createslot(v,-3);
+	sq_pop(v,1);
+}
+
+static SQInteger default_delegate_len(HSQUIRRELVM v)
+{
+	v->Push(SQInteger(sq_getsize(v,1)));
+	return 1;
+}
+
+static SQInteger default_delegate_tofloat(HSQUIRRELVM v)
+{
+	SQObjectPtr &o=stack_get(v,1);
+	switch(type(o)){
+	case OT_STRING:{
+		SQObjectPtr res;
+		if(str2num(_stringval(o),res)){
+			v->Push(SQObjectPtr(tofloat(res)));
+			break;
+		}}
+		return sq_throwerror(v, _SC("cannot convert the string"));
+		break;
+	case OT_INTEGER:case OT_FLOAT:
+		v->Push(SQObjectPtr(tofloat(o)));
+		break;
+	case OT_BOOL:
+		v->Push(SQObjectPtr((SQFloat)(_integer(o)?1:0)));
+		break;
+	default:
+		v->Push(_null_);
+		break;
+	}
+	return 1;
+}
+
+static SQInteger default_delegate_tointeger(HSQUIRRELVM v)
+{
+	SQObjectPtr &o=stack_get(v,1);
+	switch(type(o)){
+	case OT_STRING:{
+		SQObjectPtr res;
+		if(str2num(_stringval(o),res)){
+			v->Push(SQObjectPtr(tointeger(res)));
+			break;
+		}}
+		return sq_throwerror(v, _SC("cannot convert the string"));
+		break;
+	case OT_INTEGER:case OT_FLOAT:
+		v->Push(SQObjectPtr(tointeger(o)));
+		break;
+	case OT_BOOL:
+		v->Push(SQObjectPtr(_integer(o)?(SQInteger)1:(SQInteger)0));
+		break;
+	default:
+		v->Push(_null_);
+		break;
+	}
+	return 1;
+}
+
+static SQInteger default_delegate_tostring(HSQUIRRELVM v)
+{
+	sq_tostring(v,1);
+	return 1;
+}
+
+static SQInteger obj_delegate_weakref(HSQUIRRELVM v)
+{
+	sq_weakref(v,1);
+	return 1;
+}
+
+static SQInteger number_delegate_tochar(HSQUIRRELVM v)
+{
+	SQObject &o=stack_get(v,1);
+	SQChar c = (SQChar)tointeger(o);
+	v->Push(SQString::Create(_ss(v),(const SQChar *)&c,1));
+	return 1;
+}
+
+
+/////////////////////////////////////////////////////////////////
+//TABLE DEFAULT DELEGATE
+
+static SQInteger table_rawdelete(HSQUIRRELVM v)
+{
+	if(SQ_FAILED(sq_rawdeleteslot(v,1,SQTrue)))
+		return SQ_ERROR;
+	return 1;
+}
+
+
+static SQInteger container_rawexists(HSQUIRRELVM v)
+{
+	if(SQ_SUCCEEDED(sq_rawget(v,-2))) {
+		sq_pushbool(v,SQTrue);
+		return 1;
+	}
+	sq_pushbool(v,SQFalse);
+	return 1;
+}
+
+static SQInteger table_rawset(HSQUIRRELVM v)
+{
+	return sq_rawset(v,-3);
+}
+
+
+static SQInteger table_rawget(HSQUIRRELVM v)
+{
+	return SQ_SUCCEEDED(sq_rawget(v,-2))?1:SQ_ERROR;
+}
+
+SQRegFunction SQSharedState::_table_default_delegate_funcz[]={
+	{_SC("len"),default_delegate_len,1, _SC("t")},
+	{_SC("rawget"),table_rawget,2, _SC("t")},
+	{_SC("rawset"),table_rawset,3, _SC("t")},
+	{_SC("rawdelete"),table_rawdelete,2, _SC("t")},
+	{_SC("rawin"),container_rawexists,2, _SC("t")},
+	{_SC("weakref"),obj_delegate_weakref,1, NULL },
+	{_SC("tostring"),default_delegate_tostring,1, _SC(".")},
+	{0,0}
+};
+
+//ARRAY DEFAULT DELEGATE///////////////////////////////////////
+
+static SQInteger array_append(HSQUIRRELVM v)
+{
+	return sq_arrayappend(v,-2);
+}
+
+static SQInteger array_extend(HSQUIRRELVM v)
+{
+	_array(stack_get(v,1))->Extend(_array(stack_get(v,2)));
+	return 0;
+}
+
+static SQInteger array_reverse(HSQUIRRELVM v)
+{
+	return sq_arrayreverse(v,-1);
+}
+
+static SQInteger array_pop(HSQUIRRELVM v)
+{
+	return SQ_SUCCEEDED(sq_arraypop(v,1,SQTrue))?1:SQ_ERROR;
+}
+
+static SQInteger array_top(HSQUIRRELVM v)
+{
+	SQObject &o=stack_get(v,1);
+	if(_array(o)->Size()>0){
+		v->Push(_array(o)->Top());
+		return 1;
+	}
+	else return sq_throwerror(v,_SC("top() on a empty array"));
+}
+
+static SQInteger array_insert(HSQUIRRELVM v)
+{
+	SQObject &o=stack_get(v,1);
+	SQObject &idx=stack_get(v,2);
+	SQObject &val=stack_get(v,3);
+	_array(o)->Insert(idx,val);
+	return 0;
+}
+
+static SQInteger array_remove(HSQUIRRELVM v)
+{
+	SQObject &o = stack_get(v, 1);
+	SQObject &idx = stack_get(v, 2);
+	if(!sq_isnumeric(idx)) return sq_throwerror(v, _SC("wrong type"));
+	SQObjectPtr val;
+	if(_array(o)->Get(tointeger(idx), val)) {
+		_array(o)->Remove(tointeger(idx));
+		v->Push(val);
+		return 1;
+	}
+	return sq_throwerror(v, _SC("idx out of range"));
+}
+
+static SQInteger array_resize(HSQUIRRELVM v)
+{
+	SQObject &o = stack_get(v, 1);
+	SQObject &nsize = stack_get(v, 2);
+	SQObjectPtr fill;
+	if(sq_isnumeric(nsize)) {
+		if(sq_gettop(v) > 2)
+			fill = stack_get(v, 3);
+		_array(o)->Resize(tointeger(nsize),fill);
+		return 0;
+	}
+	return sq_throwerror(v, _SC("size must be a number"));
+}
+
+
+//QSORT ala Sedgewick
+bool _qsort_compare(HSQUIRRELVM v,SQObjectPtr &arr,SQObjectPtr &a,SQObjectPtr &b,SQInteger func,SQInteger &ret)
+{
+	if(func < 0) {
+		if(!v->ObjCmp(a,b,ret)) return false;
+	}
+	else {
+		SQInteger top = sq_gettop(v);
+		sq_push(v, func);
+		sq_pushroottable(v);
+		v->Push(a);
+		v->Push(b);
+		if(SQ_FAILED(sq_call(v, 3, SQTrue, SQFalse))) {
+			v->Raise_Error(_SC("compare func failed"));
+			return false;
+		}
+		sq_getinteger(v, -1, &ret);
+		sq_settop(v, top);
+		return true;
+	}
+	return true;
+}
+//QSORT ala Sedgewick
+bool _qsort(HSQUIRRELVM v,SQObjectPtr &arr, SQInteger l, SQInteger r,SQInteger func)
+{
+	SQInteger i, j;
+	SQArray *a=_array(arr);
+	SQObjectPtr pivot,t;
+	if( l < r ){
+		pivot = a->_values[l];
+		i = l; j = r+1;
+		while(1){
+			SQInteger ret;
+			do { 
+				++i; 
+				if(i > r) break;
+				if(!_qsort_compare(v,arr,a->_values[i],pivot,func,ret))
+					return false;
+			} while( ret <= 0);
+			do {
+				--j; 
+				if(!_qsort_compare(v,arr,a->_values[j],pivot,func,ret))
+					return false;
+			}
+			while( ret > 0 );
+			if( i >= j ) break;
+			t = a->_values[i]; a->_values[i] = a->_values[j]; a->_values[j] = t;
+		}
+		t = a->_values[l]; a->_values[l] = a->_values[j]; a->_values[j] = t;
+		if(!_qsort( v, arr, l, j-1,func)) return false;
+		if(!_qsort( v, arr, j+1, r,func)) return false;
+	}
+	return true;
+}
+
+static SQInteger array_sort(HSQUIRRELVM v)
+{
+	SQInteger func = -1;
+	SQObjectPtr &o = stack_get(v,1);
+	SQObject &funcobj = stack_get(v,2);
+	if(_array(o)->Size() > 1) {
+		if(type(funcobj) == OT_CLOSURE || type(funcobj) == OT_NATIVECLOSURE) func = 2;
+		if(!_qsort(v, o, 0, _array(o)->Size()-1, func))
+			return SQ_ERROR;
+
+	}
+	return 0;
+}
+static SQInteger array_slice(HSQUIRRELVM v)
+{
+	SQInteger sidx,eidx;
+	SQObjectPtr o;
+	if(get_slice_params(v,sidx,eidx,o)==-1)return -1;
+	if(sidx<0)sidx=_array(o)->Size()+sidx;
+	if(eidx<0)eidx=_array(o)->Size()+eidx;
+	if(eidx <= sidx)return sq_throwerror(v,_SC("wrong indexes"));
+	SQArray *arr=SQArray::Create(_ss(v),eidx-sidx);
+	SQObjectPtr t;
+	SQInteger count=0;
+	for(SQInteger i=sidx;i<eidx;i++){
+		_array(o)->Get(i,t);
+		arr->Set(count++,t);
+	}
+	v->Push(arr);
+	return 1;
+	
+}
+
+SQRegFunction SQSharedState::_array_default_delegate_funcz[]={
+	{_SC("len"),default_delegate_len,1, _SC("a")},
+	{_SC("append"),array_append,2, _SC("a")},
+	{_SC("extend"),array_extend,2, _SC("aa")},
+	{_SC("push"),array_append,2, _SC("a")},
+	{_SC("pop"),array_pop,1, _SC("a")},
+	{_SC("top"),array_top,1, _SC("a")},
+	{_SC("insert"),array_insert,3, _SC("an")},
+	{_SC("remove"),array_remove,2, _SC("an")},
+	{_SC("resize"),array_resize,-2, _SC("an")},
+	{_SC("reverse"),array_reverse,1, _SC("a")},
+	{_SC("sort"),array_sort,-1, _SC("ac")},
+	{_SC("slice"),array_slice,-1, _SC("ann")},
+	{_SC("weakref"),obj_delegate_weakref,1, NULL },
+	{_SC("tostring"),default_delegate_tostring,1, _SC(".")},
+	{0,0}
+};
+
+//STRING DEFAULT DELEGATE//////////////////////////
+static SQInteger string_slice(HSQUIRRELVM v)
+{
+	SQInteger sidx,eidx;
+	SQObjectPtr o;
+	if(SQ_FAILED(get_slice_params(v,sidx,eidx,o)))return -1;
+	if(sidx<0)sidx=_string(o)->_len+sidx;
+	if(eidx<0)eidx=_string(o)->_len+eidx;
+	if(eidx<sidx)
+		return sq_throwerror(v,_SC("wrong indexes"));
+	v->Push(SQString::Create(_ss(v),&_stringval(o)[sidx],eidx-sidx));
+	return 1;
+}
+
+static SQInteger string_find(HSQUIRRELVM v)
+{
+	SQInteger top,start_idx=0;
+	const SQChar *str,*substr,*ret;
+	if(((top=sq_gettop(v))>1) && SQ_SUCCEEDED(sq_getstring(v,1,&str)) && SQ_SUCCEEDED(sq_getstring(v,2,&substr))){
+		if(top>2)sq_getinteger(v,3,&start_idx);
+		if((sq_getsize(v,1)>start_idx) && (start_idx>=0)){
+			ret=scstrstr(&str[start_idx],substr);
+			if(ret){
+				sq_pushinteger(v,(SQInteger)(ret-str));
+				return 1;
+			}
+		}
+		return 0;
+	}
+	return sq_throwerror(v,_SC("invalid param"));
+}
+
+#define STRING_TOFUNCZ(func) static SQInteger string_##func(HSQUIRRELVM v) \
+{ \
+	SQObject str=stack_get(v,1); \
+	SQInteger len=_string(str)->_len; \
+	const SQChar *sThis=_stringval(str); \
+	SQChar *sNew=(_ss(v)->GetScratchPad(rsl(len))); \
+	for(SQInteger i=0;i<len;i++) sNew[i]=func(sThis[i]); \
+	v->Push(SQString::Create(_ss(v),sNew,len)); \
+	return 1; \
+}
+
+
+STRING_TOFUNCZ(tolower)
+STRING_TOFUNCZ(toupper)
+
+SQRegFunction SQSharedState::_string_default_delegate_funcz[]={
+	{_SC("len"),default_delegate_len,1, _SC("s")},
+	{_SC("tointeger"),default_delegate_tointeger,1, _SC("s")},
+	{_SC("tofloat"),default_delegate_tofloat,1, _SC("s")},
+	{_SC("tostring"),default_delegate_tostring,1, _SC(".")},
+	{_SC("slice"),string_slice,-1, _SC(" s n  n")},
+	{_SC("find"),string_find,-2, _SC("s s n ")},
+	{_SC("tolower"),string_tolower,1, _SC("s")},
+	{_SC("toupper"),string_toupper,1, _SC("s")},
+	{_SC("weakref"),obj_delegate_weakref,1, NULL },
+	{0,0}
+};
+
+//INTEGER DEFAULT DELEGATE//////////////////////////
+SQRegFunction SQSharedState::_number_default_delegate_funcz[]={
+	{_SC("tointeger"),default_delegate_tointeger,1, _SC("n|b")},
+	{_SC("tofloat"),default_delegate_tofloat,1, _SC("n|b")},
+	{_SC("tostring"),default_delegate_tostring,1, _SC(".")},
+	{_SC("tochar"),number_delegate_tochar,1, _SC("n|b")},
+	{_SC("weakref"),obj_delegate_weakref,1, NULL },
+	{0,0}
+};
+
+//CLOSURE DEFAULT DELEGATE//////////////////////////
+static SQInteger closure_pcall(HSQUIRRELVM v)
+{
+	return SQ_SUCCEEDED(sq_call(v,sq_gettop(v)-1,SQTrue,SQFalse))?1:SQ_ERROR;
+}
+
+static SQInteger closure_call(HSQUIRRELVM v)
+{
+	return SQ_SUCCEEDED(sq_call(v,sq_gettop(v)-1,SQTrue,SQTrue))?1:SQ_ERROR;
+}
+
+static SQInteger _closure_acall(HSQUIRRELVM v,SQBool raiseerror)
+{
+	SQArray *aparams=_array(stack_get(v,2));
+	SQInteger nparams=aparams->Size();
+	v->Push(stack_get(v,1));
+	for(SQInteger i=0;i<nparams;i++)v->Push(aparams->_values[i]);
+	return SQ_SUCCEEDED(sq_call(v,nparams,SQTrue,raiseerror))?1:SQ_ERROR;
+}
+
+static SQInteger closure_acall(HSQUIRRELVM v)
+{
+	return _closure_acall(v,SQTrue);
+}
+
+static SQInteger closure_pacall(HSQUIRRELVM v)
+{
+	return _closure_acall(v,SQFalse);
+}
+
+static SQInteger closure_bindenv(HSQUIRRELVM v)
+{
+	if(SQ_FAILED(sq_bindenv(v,1)))
+		return SQ_ERROR;
+	return 1;
+}
+
+static SQInteger closure_getinfos(HSQUIRRELVM v) {
+	SQObject o = stack_get(v,1);
+	SQTable *res = SQTable::Create(_ss(v),4);
+	if(type(o) == OT_CLOSURE) {
+		SQFunctionProto *f = _funcproto(_closure(o)->_function);
+		SQInteger nparams = f->_parameters.size() + (f->_varparams?1:0);
+		SQObjectPtr params = SQArray::Create(_ss(v),nparams);
+		for(SQUnsignedInteger n = 0; n<f->_parameters.size(); n++) {
+			_array(params)->Set((SQInteger)n,f->_parameters[n]);
+		}
+		if(f->_varparams) {
+			_array(params)->Set(nparams-1,SQString::Create(_ss(v),_SC("..."),-1));
+		}
+		res->NewSlot(SQString::Create(_ss(v),_SC("native"),-1),false);
+		res->NewSlot(SQString::Create(_ss(v),_SC("name"),-1),f->_name);
+		res->NewSlot(SQString::Create(_ss(v),_SC("src"),-1),f->_sourcename);
+		res->NewSlot(SQString::Create(_ss(v),_SC("parameters"),-1),params);
+		res->NewSlot(SQString::Create(_ss(v),_SC("varargs"),-1),f->_varparams);
+	}
+	else { //OT_NATIVECLOSURE 
+		SQNativeClosure *nc = _nativeclosure(o);
+		res->NewSlot(SQString::Create(_ss(v),_SC("native"),-1),true);
+		res->NewSlot(SQString::Create(_ss(v),_SC("name"),-1),nc->_name);
+		res->NewSlot(SQString::Create(_ss(v),_SC("paramscheck"),-1),nc->_nparamscheck);
+		SQObjectPtr typecheck;
+		if(nc->_typecheck.size() > 0) {
+			typecheck =
+				SQArray::Create(_ss(v), nc->_typecheck.size());
+			for(SQUnsignedInteger n = 0; n<nc->_typecheck.size(); n++) {
+					_array(typecheck)->Set((SQInteger)n,nc->_typecheck[n]);
+			}
+		}
+		res->NewSlot(SQString::Create(_ss(v),_SC("typecheck"),-1),typecheck);
+	}
+	v->Push(res);
+	return 1;
+}
+
+
+SQRegFunction SQSharedState::_closure_default_delegate_funcz[]={
+	{_SC("call"),closure_call,-1, _SC("c")},
+	{_SC("pcall"),closure_pcall,-1, _SC("c")},
+	{_SC("acall"),closure_acall,2, _SC("ca")},
+	{_SC("pacall"),closure_pacall,2, _SC("ca")},
+	{_SC("weakref"),obj_delegate_weakref,1, NULL },
+	{_SC("tostring"),default_delegate_tostring,1, _SC(".")},
+	{_SC("bindenv"),closure_bindenv,2, _SC("c x|y|t")},
+	{_SC("getinfos"),closure_getinfos,1, _SC("c")},
+	{0,0}
+};
+
+//GENERATOR DEFAULT DELEGATE
+static SQInteger generator_getstatus(HSQUIRRELVM v)
+{
+	SQObject &o=stack_get(v,1);
+	switch(_generator(o)->_state){
+		case SQGenerator::eSuspended:v->Push(SQString::Create(_ss(v),_SC("suspended")));break;
+		case SQGenerator::eRunning:v->Push(SQString::Create(_ss(v),_SC("running")));break;
+		case SQGenerator::eDead:v->Push(SQString::Create(_ss(v),_SC("dead")));break;
+	}
+	return 1;
+}
+
+SQRegFunction SQSharedState::_generator_default_delegate_funcz[]={
+	{_SC("getstatus"),generator_getstatus,1, _SC("g")},
+	{_SC("weakref"),obj_delegate_weakref,1, NULL },
+	{_SC("tostring"),default_delegate_tostring,1, _SC(".")},
+	{0,0}
+};
+
+//THREAD DEFAULT DELEGATE
+
+static SQInteger thread_call(HSQUIRRELVM v)
+{
+	SQObjectPtr o = stack_get(v,1);
+	if(type(o) == OT_THREAD) {
+		SQInteger nparams = sq_gettop(v);
+		_thread(o)->Push(_thread(o)->_roottable);
+		for(SQInteger i = 2; i<(nparams+1); i++)
+			sq_move(_thread(o),v,i);
+		if(SQ_SUCCEEDED(sq_call(_thread(o),nparams,SQTrue,SQFalse))) {
+			sq_move(v,_thread(o),-1);
+			return 1;
+		}
+		return SQ_ERROR;
+	}
+	return sq_throwerror(v,_SC("wrong parameter"));
+}
+
+static SQInteger thread_wakeup(HSQUIRRELVM v)
+{
+	SQObjectPtr o = stack_get(v,1);
+	if(type(o) == OT_THREAD) {
+		SQVM *thread = _thread(o);
+		SQInteger state = sq_getvmstate(thread);
+		if(state != SQ_VMSTATE_SUSPENDED) {
+			switch(state) {
+				case SQ_VMSTATE_IDLE:
+					return sq_throwerror(v,_SC("cannot wakeup a idle thread"));
+				break;
+				case SQ_VMSTATE_RUNNING:
+					return sq_throwerror(v,_SC("cannot wakeup a running thread"));
+				break;
+			}
+		}
+			
+		SQInteger wakeupret = sq_gettop(v)>1?1:0;
+		if(wakeupret) {
+			sq_move(thread,v,2);
+		}
+		if(SQ_SUCCEEDED(sq_wakeupvm(thread,wakeupret,1,SQFalse))) {
+			sq_move(v,thread,-1);
+			sq_pop(thread,1);
+			if(sq_getvmstate(thread) == SQ_VMSTATE_IDLE) {
+				sq_pop(thread,1);
+			}
+			return 1;
+		}
+		return SQ_ERROR;
+	}
+	return sq_throwerror(v,_SC("wrong parameter"));
+}
+
+static SQInteger thread_getstatus(HSQUIRRELVM v)
+{
+	SQObjectPtr &o = stack_get(v,1);
+	switch(sq_getvmstate(_thread(o))) {
+		case SQ_VMSTATE_IDLE:
+			sq_pushstring(v,_SC("idle"),-1);
+		break;
+		case SQ_VMSTATE_RUNNING:
+			sq_pushstring(v,_SC("running"),-1);
+		break;
+		case SQ_VMSTATE_SUSPENDED:
+			sq_pushstring(v,_SC("suspended"),-1);
+		break;
+		default:
+			return sq_throwerror(v,_SC("internal VM error"));
+	}
+	return 1;
+}
+
+SQRegFunction SQSharedState::_thread_default_delegate_funcz[] = {
+	{_SC("call"), thread_call, -1, _SC("v")},
+	{_SC("wakeup"), thread_wakeup, -1, _SC("v")},
+	{_SC("getstatus"), thread_getstatus, 1, _SC("v")},
+	{_SC("weakref"),obj_delegate_weakref,1, NULL },
+	{_SC("tostring"),default_delegate_tostring,1, _SC(".")},
+	{0,0},
+};
+
+static SQInteger class_getattributes(HSQUIRRELVM v)
+{
+	if(SQ_SUCCEEDED(sq_getattributes(v,-2)))
+		return 1;
+	return SQ_ERROR;
+}
+
+static SQInteger class_setattributes(HSQUIRRELVM v)
+{
+	if(SQ_SUCCEEDED(sq_setattributes(v,-3)))
+		return 1;
+	return SQ_ERROR;
+}
+
+static SQInteger class_instance(HSQUIRRELVM v)
+{
+	if(SQ_SUCCEEDED(sq_createinstance(v,-1)))
+		return 1;
+	return SQ_ERROR;
+}
+
+SQRegFunction SQSharedState::_class_default_delegate_funcz[] = {
+	{_SC("getattributes"), class_getattributes, 2, _SC("y.")},
+	{_SC("setattributes"), class_setattributes, 3, _SC("y..")},
+	{_SC("rawin"),container_rawexists,2, _SC("y")},
+	{_SC("weakref"),obj_delegate_weakref,1, NULL },
+	{_SC("tostring"),default_delegate_tostring,1, _SC(".")},
+	{_SC("instance"),class_instance,1, _SC("y")},
+	{0,0}
+};
+
+static SQInteger instance_getclass(HSQUIRRELVM v)
+{
+	if(SQ_SUCCEEDED(sq_getclass(v,1)))
+		return 1;
+	return SQ_ERROR;
+}
+
+SQRegFunction SQSharedState::_instance_default_delegate_funcz[] = {
+	{_SC("getclass"), instance_getclass, 1, _SC("x")},
+	{_SC("rawin"),container_rawexists,2, _SC("x")},
+	{_SC("weakref"),obj_delegate_weakref,1, NULL },
+	{_SC("tostring"),default_delegate_tostring,1, _SC(".")},
+	{0,0}
+};
+
+static SQInteger weakref_ref(HSQUIRRELVM v)
+{
+	if(SQ_FAILED(sq_getweakrefval(v,1)))
+		return SQ_ERROR;
+	return 1;
+}
+
+SQRegFunction SQSharedState::_weakref_default_delegate_funcz[] = {
+	{_SC("ref"),weakref_ref,1, _SC("r")},
+	{_SC("weakref"),obj_delegate_weakref,1, NULL },
+	{_SC("tostring"),default_delegate_tostring,1, _SC(".")},
+	{0,0}
+};
+
+
diff -rupwN ../dnl3/SqPlus/_squirrel/sqclass.cpp SqPlus/_squirrel/sqclass.cpp
--- ../dnl3/SqPlus/_squirrel/sqclass.cpp	1969-12-31 19:00:00.000000000 -0500
+++ SqPlus/_squirrel/sqclass.cpp	2006-03-19 14:32:58.000000000 -0500
@@ -0,0 +1,192 @@
+/*
+	see copyright notice in squirrel.h
+*/
+#include "sqpcheader.h"
+#include "sqvm.h"
+#include "sqtable.h"
+#include "sqclass.h"
+#include "sqclosure.h"
+
+SQClass::SQClass(SQSharedState *ss,SQClass *base)
+{
+	_base = base;
+	_typetag = 0;
+	_hook = NULL;
+	_metamethods.resize(MT_LAST); //size it to max size
+	if(_base) {
+		_defaultvalues.copy(base->_defaultvalues);
+		_methods.copy(base->_methods);
+		_metamethods.copy(base->_metamethods);
+		__ObjAddRef(_base);
+	}
+	_members = base?base->_members->Clone() : SQTable::Create(ss,0);
+	__ObjAddRef(_members);
+	_locked = false;
+	INIT_CHAIN();
+	ADD_TO_CHAIN(&_sharedstate->_gc_chain, this);
+}
+
+void SQClass::Finalize() { 
+	_attributes = _null_;
+	_defaultvalues.resize(0);
+	_methods.resize(0);
+	_metamethods.resize(0);
+	__ObjRelease(_members);
+	if(_base) {
+		__ObjRelease(_base);
+	}
+}
+
+SQClass::~SQClass()
+{
+	REMOVE_FROM_CHAIN(&_sharedstate->_gc_chain, this);
+	Finalize();
+}
+
+bool SQClass::NewSlot(SQSharedState *ss,const SQObjectPtr &key,const SQObjectPtr &val,bool bstatic)
+{
+	SQObjectPtr temp;
+	if(_locked) 
+		return false; //the class already has an instance so cannot be modified
+	if(_members->Get(key,temp) && _isfield(temp)) //overrides the default value
+	{
+		_defaultvalues[_member_idx(temp)].val = val;
+		return true;
+	}
+	if(type(val) == OT_CLOSURE || type(val) == OT_NATIVECLOSURE || bstatic) {
+		SQInteger mmidx;
+		if((type(val) == OT_CLOSURE || type(val) == OT_NATIVECLOSURE) && 
+			(mmidx = ss->GetMetaMethodIdxByName(key)) != -1) {
+			_metamethods[mmidx] = val;
+		} 
+		else {
+			if(type(temp) == OT_NULL) {
+				SQClassMemeber m;
+				m.val = val;
+				_members->NewSlot(key,SQObjectPtr(_make_method_idx(_methods.size())));
+				_methods.push_back(m);
+			}
+			else {
+				_methods[_member_idx(temp)].val = val;
+			}
+		}
+		return true;
+	}
+	SQClassMemeber m;
+	m.val = val;
+	_members->NewSlot(key,SQObjectPtr(_make_field_idx(_defaultvalues.size())));
+	_defaultvalues.push_back(m);
+	return true;
+}
+
+SQInstance *SQClass::CreateInstance()
+{
+	if(!_locked) Lock();
+	return SQInstance::Create(_opt_ss(this),this);
+}
+
+SQInteger SQClass::Next(const SQObjectPtr &refpos, SQObjectPtr &outkey, SQObjectPtr &outval)
+{
+	SQObjectPtr oval;
+	SQInteger idx = _members->Next(false,refpos,outkey,oval);
+	if(idx != -1) {
+		if(_ismethod(oval)) {
+			outval = _methods[_member_idx(oval)].val;
+		}
+		else {
+			SQObjectPtr &o = _defaultvalues[_member_idx(oval)].val;
+			outval = _realval(o);
+		}
+	}
+	return idx;
+}
+
+bool SQClass::SetAttributes(const SQObjectPtr &key,const SQObjectPtr &val)
+{
+	SQObjectPtr idx;
+	if(_members->Get(key,idx)) {
+		if(_isfield(idx))
+			_defaultvalues[_member_idx(idx)].attrs = val;
+		else
+			_methods[_member_idx(idx)].attrs = val;
+		return true;
+	}
+	return false;
+}
+
+bool SQClass::GetAttributes(const SQObjectPtr &key,SQObjectPtr &outval)
+{
+	SQObjectPtr idx;
+	if(_members->Get(key,idx)) {
+		outval = (_isfield(idx)?_defaultvalues[_member_idx(idx)].attrs:_methods[_member_idx(idx)].attrs);
+		return true;
+	}
+	return false;
+}
+
+///////////////////////////////////////////////////////////////////////
+void SQInstance::Init(SQSharedState *ss)
+{
+	_userpointer = NULL;
+	_hook = NULL;
+	__ObjAddRef(_class);
+	_delegate = _class->_members;
+	INIT_CHAIN();
+	ADD_TO_CHAIN(&_sharedstate->_gc_chain, this);
+}
+
+SQInstance::SQInstance(SQSharedState *ss, SQClass *c, SQInteger memsize)
+{
+	_memsize = memsize;
+	_class = c;
+	_nvalues = _class->_defaultvalues.size();
+	for(SQUnsignedInteger n = 0; n < _nvalues; n++) {
+		new (&_values[n]) SQObjectPtr(_class->_defaultvalues[n].val);
+	}
+	Init(ss);
+}
+
+SQInstance::SQInstance(SQSharedState *ss, SQInstance *i, SQInteger memsize)
+{
+	_memsize = memsize;
+	_class = i->_class;
+	_nvalues = _class->_defaultvalues.size();
+	for(SQUnsignedInteger n = 0; n < _nvalues; n++) {
+		new (&_values[n]) SQObjectPtr(i->_values[n]);
+	}
+	Init(ss);
+}
+
+void SQInstance::Finalize() 
+{
+	__ObjRelease(_class);
+	for(SQUnsignedInteger i = 0; i < _nvalues; i++) {
+		_values[i] = _null_;
+	}
+}
+
+SQInstance::~SQInstance()
+{
+	REMOVE_FROM_CHAIN(&_sharedstate->_gc_chain, this);
+	Finalize();
+}
+
+bool SQInstance::GetMetaMethod(SQVM *v,SQMetaMethod mm,SQObjectPtr &res)
+{
+	if(type(_class->_metamethods[mm]) != OT_NULL) {
+		res = _class->_metamethods[mm];
+		return true;
+	}
+	return false;
+}
+
+bool SQInstance::InstanceOf(SQClass *trg)
+{
+	SQClass *parent = _class;
+	while(parent != NULL) {
+		if(parent == trg)
+			return true;
+		parent = parent->_base;
+	}
+	return false;
+}
diff -rupwN ../dnl3/SqPlus/_squirrel/sqclass.h SqPlus/_squirrel/sqclass.h
--- ../dnl3/SqPlus/_squirrel/sqclass.h	1969-12-31 19:00:00.000000000 -0500
+++ SqPlus/_squirrel/sqclass.h	2006-03-19 14:32:58.000000000 -0500
@@ -0,0 +1,142 @@
+/*	see copyright notice in squirrel.h */
+#ifndef _SQCLASS_H_
+#define _SQCLASS_H_
+
+struct SQInstance;
+
+struct SQClassMemeber {
+	SQClassMemeber(){}
+	SQClassMemeber(const SQClassMemeber &o) {
+		val = o.val;
+		attrs = o.attrs;
+	}
+	SQObjectPtr val;
+	SQObjectPtr attrs;
+};
+
+typedef sqvector<SQClassMemeber> SQClassMemeberVec;
+
+#define MEMBER_TYPE_METHOD 0x01000000
+#define MEMBER_TYPE_FIELD 0x02000000
+
+#define _ismethod(o) (_integer(o)&MEMBER_TYPE_METHOD)
+#define _isfield(o) (_integer(o)&MEMBER_TYPE_FIELD)
+#define _make_method_idx(i) ((SQInteger)(MEMBER_TYPE_METHOD|i))
+#define _make_field_idx(i) ((SQInteger)(MEMBER_TYPE_FIELD|i))
+#define _member_type(o) (_integer(o)&0xFF000000)
+#define _member_idx(o) (_integer(o)&0x00FFFFFF)
+
+struct SQClass : public CHAINABLE_OBJ
+{
+	SQClass(SQSharedState *ss,SQClass *base);
+public:
+	static SQClass* Create(SQSharedState *ss,SQClass *base) {
+		SQClass *newclass = (SQClass *)SQ_MALLOC(sizeof(SQClass));
+		new (newclass) SQClass(ss, base);
+		return newclass;
+	}
+	~SQClass();
+	bool NewSlot(SQSharedState *ss, const SQObjectPtr &key,const SQObjectPtr &val,bool bstatic);
+	bool Get(const SQObjectPtr &key,SQObjectPtr &val) {
+		if(_members->Get(key,val)) {
+			if(_isfield(val)) {
+				SQObjectPtr &o = _defaultvalues[_member_idx(val)].val;
+				val = _realval(o);
+			}
+			else {
+				val = _methods[_member_idx(val)].val;
+			}
+			return true;
+		}
+		return false;
+	}
+	bool SetAttributes(const SQObjectPtr &key,const SQObjectPtr &val);
+	bool GetAttributes(const SQObjectPtr &key,SQObjectPtr &outval);
+	void Lock() { _locked = true; if(_base) _base->Lock(); }
+	void Release() { 
+		if (_hook) { _hook(_typetag,0);}
+		sq_delete(this, SQClass);	
+	}
+	void Finalize();
+#ifndef NO_GARBAGE_COLLECTOR
+	void Mark(SQCollectable ** );
+#endif
+	SQInteger Next(const SQObjectPtr &refpos, SQObjectPtr &outkey, SQObjectPtr &outval);
+	SQInstance *CreateInstance();
+	SQTable *_members;
+	SQClass *_base;
+	SQClassMemeberVec _defaultvalues;
+	SQClassMemeberVec _methods;
+	SQObjectPtrVec _metamethods;
+	SQObjectPtr _attributes;
+	SQUserPointer _typetag;
+	SQRELEASEHOOK _hook;
+	bool _locked;
+};
+
+#define calcinstancesize(_theclass_) \
+	(sizeof(SQInstance)+(sizeof(SQObjectPtr)*(_theclass_->_defaultvalues.size()>0?_theclass_->_defaultvalues.size()-1:0)))
+struct SQInstance : public SQDelegable 
+{
+	void Init(SQSharedState *ss);
+	SQInstance(SQSharedState *ss, SQClass *c, SQInteger memsize);
+	SQInstance(SQSharedState *ss, SQInstance *c, SQInteger memsize);
+public:
+	static SQInstance* Create(SQSharedState *ss,SQClass *theclass) {
+		
+		SQInteger size = calcinstancesize(theclass);
+		SQInstance *newinst = (SQInstance *)SQ_MALLOC(size);
+		new (newinst) SQInstance(ss, theclass,size);
+		return newinst;
+	}
+	SQInstance *Clone(SQSharedState *ss)
+	{
+		SQInteger size = calcinstancesize(_class);
+		SQInstance *newinst = (SQInstance *)SQ_MALLOC(size);
+		new (newinst) SQInstance(ss, this,size);
+		return newinst;
+	}
+	~SQInstance();
+	bool Get(const SQObjectPtr &key,SQObjectPtr &val)  {
+		if(_class->_members->Get(key,val)) {
+			if(_isfield(val)) {
+				SQObjectPtr &o = _values[_member_idx(val)];
+				val = _realval(o);
+			}
+			else {
+				val = _class->_methods[_member_idx(val)].val;
+			}
+			return true;
+		}
+		return false;
+	}
+	bool Set(const SQObjectPtr &key,const SQObjectPtr &val) {
+		SQObjectPtr idx;
+		if(_class->_members->Get(key,idx) && _isfield(idx)) {
+            _values[_member_idx(idx)] = val;
+			return true;
+		}
+		return false;
+	}
+	void Release() { 
+		if (_hook) { _hook(_userpointer,0);}
+		SQInteger size = _memsize;
+		this->~SQInstance();
+		SQ_FREE(this, size);
+	}
+	void Finalize();
+#ifndef NO_GARBAGE_COLLECTOR 
+	void Mark(SQCollectable ** );
+#endif
+	bool InstanceOf(SQClass *trg);
+	bool GetMetaMethod(SQVM *v,SQMetaMethod mm,SQObjectPtr &res);
+
+	SQClass *_class;
+	SQUserPointer _userpointer;
+	SQRELEASEHOOK _hook;
+	SQUnsignedInteger _nvalues;
+	SQInteger _memsize;
+	SQObjectPtr _values[1];
+};
+
+#endif //_SQCLASS_H_
diff -rupwN ../dnl3/SqPlus/_squirrel/sqclosure.h SqPlus/_squirrel/sqclosure.h
--- ../dnl3/SqPlus/_squirrel/sqclosure.h	1969-12-31 19:00:00.000000000 -0500
+++ SqPlus/_squirrel/sqclosure.h	2006-03-19 14:32:58.000000000 -0500
@@ -0,0 +1,120 @@
+/*	see copyright notice in squirrel.h */
+#ifndef _SQCLOSURE_H_
+#define _SQCLOSURE_H_
+
+struct SQFunctionProto;
+
+struct SQClosure : public CHAINABLE_OBJ
+{
+private:
+	SQClosure(SQSharedState *ss,SQFunctionProto *func){_function=func; INIT_CHAIN();ADD_TO_CHAIN(&_ss(this)->_gc_chain,this);}
+public:
+	static SQClosure *Create(SQSharedState *ss,SQFunctionProto *func){
+		SQClosure *nc=(SQClosure*)SQ_MALLOC(sizeof(SQClosure));
+		new (nc) SQClosure(ss,func);
+		return nc;
+	}
+	void Release(){
+		sq_delete(this,SQClosure);
+	}
+	SQClosure *Clone()
+	{
+		SQClosure * ret = SQClosure::Create(_opt_ss(this),_funcproto(_function));
+		ret->_env = _env;
+		ret->_outervalues.copy(_outervalues);
+		return ret;
+	}
+	~SQClosure()
+	{
+		REMOVE_FROM_CHAIN(&_ss(this)->_gc_chain,this);
+	}
+	bool Save(SQVM *v,SQUserPointer up,SQWRITEFUNC write);
+	bool Load(SQVM *v,SQUserPointer up,SQREADFUNC read);
+#ifndef NO_GARBAGE_COLLECTOR
+	void Mark(SQCollectable **chain);
+	void Finalize(){_outervalues.resize(0); }
+#endif
+	SQObjectPtr _env;
+	SQObjectPtr _function;
+	SQObjectPtrVec _outervalues;
+};
+//////////////////////////////////////////////
+struct SQGenerator : public CHAINABLE_OBJ 
+{
+	enum SQGeneratorState{eRunning,eSuspended,eDead};
+private:
+	SQGenerator(SQSharedState *ss,SQClosure *closure){_closure=closure;_state=eRunning;_ci._generator=_null_;INIT_CHAIN();ADD_TO_CHAIN(&_ss(this)->_gc_chain,this);}
+public:
+	static SQGenerator *Create(SQSharedState *ss,SQClosure *closure){
+		SQGenerator *nc=(SQGenerator*)SQ_MALLOC(sizeof(SQGenerator));
+		new (nc) SQGenerator(ss,closure);
+		return nc;
+	}
+	~SQGenerator()
+	{
+		REMOVE_FROM_CHAIN(&_ss(this)->_gc_chain,this);
+	}
+    void Kill(){
+		_state=eDead;
+		_stack.resize(0);
+		_closure=_null_;}
+	void Release(){
+		sq_delete(this,SQGenerator);
+	}
+	bool Yield(SQVM *v);
+	bool Resume(SQVM *v,SQInteger target);
+#ifndef NO_GARBAGE_COLLECTOR
+	void Mark(SQCollectable **chain);
+	void Finalize(){_stack.resize(0);_closure=_null_;}
+#endif
+	SQObjectPtr _closure;
+	SQObjectPtrVec _stack;
+	SQObjectPtrVec _vargsstack;
+	SQVM::CallInfo _ci;
+	ExceptionsTraps _etraps;
+	SQGeneratorState _state;
+};
+
+struct SQNativeClosure : public CHAINABLE_OBJ
+{
+private:
+	SQNativeClosure(SQSharedState *ss,SQFUNCTION func){_function=func;INIT_CHAIN();ADD_TO_CHAIN(&_ss(this)->_gc_chain,this);	}
+public:
+	static SQNativeClosure *Create(SQSharedState *ss,SQFUNCTION func)
+	{
+		SQNativeClosure *nc=(SQNativeClosure*)SQ_MALLOC(sizeof(SQNativeClosure));
+		new (nc) SQNativeClosure(ss,func);
+		return nc;
+	}
+	SQNativeClosure *Clone()
+	{
+		SQNativeClosure * ret = SQNativeClosure::Create(_opt_ss(this),_function);
+		ret->_env = _env;
+		ret->_name = _name;
+		ret->_outervalues.copy(_outervalues);
+		ret->_typecheck = _typecheck;
+		ret->_nparamscheck = _nparamscheck;
+		return ret;
+	}
+	~SQNativeClosure()
+	{
+		REMOVE_FROM_CHAIN(&_ss(this)->_gc_chain,this);
+	}
+	void Release(){
+		sq_delete(this,SQNativeClosure);
+	}
+#ifndef NO_GARBAGE_COLLECTOR
+	void Mark(SQCollectable **chain);
+	void Finalize(){_outervalues.resize(0);}
+#endif
+	SQObjectPtr _env;
+	SQFUNCTION _function;
+	SQObjectPtr _name;
+	SQObjectPtrVec _outervalues;
+	SQIntVec _typecheck;
+	SQInteger _nparamscheck;
+};
+
+
+
+#endif //_SQCLOSURE_H_
diff -rupwN ../dnl3/SqPlus/_squirrel/sqcompiler.cpp SqPlus/_squirrel/sqcompiler.cpp
--- ../dnl3/SqPlus/_squirrel/sqcompiler.cpp	1969-12-31 19:00:00.000000000 -0500
+++ SqPlus/_squirrel/sqcompiler.cpp	2006-03-19 14:32:58.000000000 -0500
@@ -0,0 +1,1214 @@
+/*
+	see copyright notice in squirrel.h
+*/
+#include "sqpcheader.h"
+#include <stdarg.h>
+#include <setjmp.h>
+#include "sqopcodes.h"
+#include "sqstring.h"
+#include "sqfuncproto.h"
+#include "sqcompiler.h"
+#include "sqfuncstate.h"
+#include "sqlexer.h"
+#include "sqvm.h"
+
+#define DEREF_NO_DEREF	-1
+#define DEREF_FIELD		-2
+
+struct ExpState
+{
+	ExpState()
+	{
+		_deref = DEREF_NO_DEREF;
+		_freevar = false;
+		_class_or_delete = false;
+		_funcarg = false;
+	}
+	bool _class_or_delete;
+	bool _funcarg;
+	bool _freevar;
+	SQInteger _deref;
+};
+
+typedef sqvector<ExpState> ExpStateVec;
+
+#define _exst (_expstates.top())
+
+#define BEGIN_BREAKBLE_BLOCK()	SQInteger __nbreaks__=_fs->_unresolvedbreaks.size(); \
+							SQInteger __ncontinues__=_fs->_unresolvedcontinues.size(); \
+							_fs->_breaktargets.push_back(0);_fs->_continuetargets.push_back(0);
+
+#define END_BREAKBLE_BLOCK(continue_target) {__nbreaks__=_fs->_unresolvedbreaks.size()-__nbreaks__; \
+					__ncontinues__=_fs->_unresolvedcontinues.size()-__ncontinues__; \
+					if(__ncontinues__>0)ResolveContinues(_fs,__ncontinues__,continue_target); \
+					if(__nbreaks__>0)ResolveBreaks(_fs,__nbreaks__); \
+					_fs->_breaktargets.pop_back();_fs->_continuetargets.pop_back();}
+
+class SQCompiler
+{
+public:
+	SQCompiler(SQVM *v, SQLEXREADFUNC rg, SQUserPointer up, const SQChar* sourcename, bool raiseerror, bool lineinfo)
+	{
+		_vm=v;
+		_lex.Init(_ss(v), rg, up,ThrowError,this);
+		_sourcename = SQString::Create(_ss(v), sourcename);
+		_lineinfo = lineinfo;_raiseerror = raiseerror;
+		compilererror = NULL;
+	}
+	static void ThrowError(void *ud, const SQChar *s) {
+		SQCompiler *c = (SQCompiler *)ud;
+		c->Error(s);
+	}
+	void Error(const SQChar *s, ...)
+	{
+		static SQChar temp[256];
+		va_list vl;
+		va_start(vl, s);
+		scvsprintf(temp, s, vl);
+		va_end(vl);
+		compilererror = temp;
+		longjmp(_errorjmp,1);
+	}
+	void Lex(){	_token = _lex.Lex();}
+	void PushExpState(){ _expstates.push_back(ExpState()); }
+	bool IsDerefToken(SQInteger tok)
+	{
+		switch(tok){
+		case _SC('='): case _SC('('): case TK_NEWSLOT:
+		case TK_MODEQ: case TK_MULEQ: case TK_DIVEQ: case TK_MINUSEQ: case TK_PLUSEQ: case TK_PLUSPLUS: case TK_MINUSMINUS: return true;
+		}
+		return false;
+	}
+	ExpState PopExpState()
+	{
+		ExpState ret = _expstates.top();
+		_expstates.pop_back();
+		return ret;
+	}
+	SQObject Expect(SQInteger tok)
+	{
+		
+		if(_token != tok) {
+			if(_token == TK_CONSTRUCTOR && tok == TK_IDENTIFIER) {
+				//ret = SQString::Create(_ss(_vm),_SC("constructor"));
+				//do nothing
+			}
+			else {
+				const SQChar *etypename;
+				if(tok > 255) {
+					switch(tok)
+					{
+					case TK_IDENTIFIER:
+						etypename = _SC("IDENTIFIER");
+						break;
+					case TK_STRING_LITERAL:
+						etypename = _SC("STRING_LITERAL");
+						break;
+					case TK_INTEGER:
+						etypename = _SC("INTEGER");
+						break;
+					case TK_FLOAT:
+						etypename = _SC("FLOAT");
+						break;
+					default:
+						etypename = _lex.Tok2Str(tok);
+					}
+					Error(_SC("expected '%s'"), etypename);
+				}
+				Error(_SC("expected '%c'"), tok);
+			}
+		}
+		SQObjectPtr ret;
+		switch(tok)
+		{
+		case TK_IDENTIFIER:
+			ret = _fs->CreateString(_lex._svalue);
+			break;
+		case TK_STRING_LITERAL:
+			ret = _fs->CreateString(_lex._svalue,_lex._longstr.size()-1);
+			break;
+		case TK_INTEGER:
+			ret = SQObjectPtr(_lex._nvalue);
+			break;
+		case TK_FLOAT:
+			ret = SQObjectPtr(_lex._fvalue);
+			break;
+		}
+		Lex();
+		return ret;
+	}
+	bool IsEndOfStatement() { return ((_lex._prevtoken == _SC('\n')) || (_token == SQUIRREL_EOB) || (_token == _SC('}')) || (_token == _SC(';'))); }
+	void OptionalSemicolon()
+	{
+		if(_token == _SC(';')) { Lex(); return; }
+		if(!IsEndOfStatement()) {
+			Error(_SC("end of statement expected (; or lf)"));
+		}
+	}
+	void MoveIfCurrentTargetIsLocal() {
+		SQInteger trg = _fs->TopTarget();
+		if(_fs->IsLocal(trg)) {
+			trg = _fs->PopTarget(); //no pops the target and move it
+			_fs->AddInstruction(_OP_MOVE, _fs->PushTarget(), trg);
+		}
+	}
+	bool Compile(SQObjectPtr &o)
+	{
+		_debugline = 1;
+		_debugop = 0;
+
+		SQFuncState funcstate(_ss(_vm), NULL,ThrowError,this);
+		funcstate._name = SQString::Create(_ss(_vm), _SC("main"));
+		_fs = &funcstate;
+		_fs->AddParameter(_fs->CreateString(_SC("this")));
+		_fs->_sourcename = _sourcename;
+		SQInteger stacksize = _fs->GetStackSize();
+		if(setjmp(_errorjmp) == 0) {
+			Lex();
+			while(_token > 0){
+				Statement();
+				if(_lex._prevtoken != _SC('}')) OptionalSemicolon();
+			}
+			CleanStack(stacksize);
+			_fs->AddLineInfos(_lex._currentline, _lineinfo, true);
+			_fs->AddInstruction(_OP_RETURN, 0xFF);
+			_fs->SetStackSize(0);
+			o =_fs->BuildProto();
+#ifdef _DEBUG_DUMP
+			_fs->Dump(_funcproto(o));
+#endif
+		}
+		else {
+			if(_raiseerror && _ss(_vm)->_compilererrorhandler) {
+				_ss(_vm)->_compilererrorhandler(_vm, compilererror, type(_sourcename) == OT_STRING?_stringval(_sourcename):_SC("unknown"),
+					_lex._currentline, _lex._currentcolumn);
+			}
+			_vm->_lasterror = SQString::Create(_ss(_vm), compilererror, -1);
+			return false;
+		}
+		return true;
+	}
+	void Statements()
+	{
+		while(_token != _SC('}') && _token != TK_DEFAULT && _token != TK_CASE) {
+			Statement();
+			if(_lex._prevtoken != _SC('}') && _lex._prevtoken != _SC(';')) OptionalSemicolon();
+		}
+	}
+	void Statement()
+	{
+		_fs->AddLineInfos(_lex._currentline, _lineinfo);
+		switch(_token){
+		case _SC(';'):	Lex();					break;
+		case TK_IF:		IfStatement();			break;
+		case TK_WHILE:		WhileStatement();		break;
+		case TK_DO:		DoWhileStatement();		break;
+		case TK_FOR:		ForStatement();			break;
+		case TK_FOREACH:	ForEachStatement();		break;
+		case TK_SWITCH:	SwitchStatement();		break;
+		case TK_LOCAL:		LocalDeclStatement();	break;
+		case TK_RETURN:
+		case TK_YIELD: {
+			SQOpcode op;
+			if(_token == TK_RETURN) {
+				op = _OP_RETURN;
+				
+			}
+			else {
+				op = _OP_YIELD;
+				_fs->_bgenerator = true;
+			}
+			Lex();
+			if(!IsEndOfStatement()) {
+				SQInteger retexp = _fs->GetCurrentPos()+1;
+				CommaExpr();
+				if(op == _OP_RETURN && _fs->_traps > 0)
+					_fs->AddInstruction(_OP_POPTRAP, _fs->_traps, 0);
+				_fs->_returnexp = retexp;
+				_fs->AddInstruction(op, 1, _fs->PopTarget());
+			}
+			else{ 
+				if(op == _OP_RETURN && _fs->_traps > 0)
+					_fs->AddInstruction(_OP_POPTRAP, _fs->_traps ,0);
+				_fs->_returnexp = -1;
+				_fs->AddInstruction(op, 0xFF); 
+			}
+			break;}
+		case TK_BREAK:
+			if(_fs->_breaktargets.size() <= 0)Error(_SC("'break' has to be in a loop block"));
+			if(_fs->_breaktargets.top() > 0){
+				_fs->AddInstruction(_OP_POPTRAP, _fs->_breaktargets.top(), 0);
+			}
+			_fs->AddInstruction(_OP_JMP, 0, -1234);
+			_fs->_unresolvedbreaks.push_back(_fs->GetCurrentPos());
+			Lex();
+			break;
+		case TK_CONTINUE:
+			if(_fs->_continuetargets.size() <= 0)Error(_SC("'continue' has to be in a loop block"));
+			if(_fs->_continuetargets.top() > 0) {
+				_fs->AddInstruction(_OP_POPTRAP, _fs->_continuetargets.top(), 0);
+			}
+			_fs->AddInstruction(_OP_JMP, 0, -1234);
+			_fs->_unresolvedcontinues.push_back(_fs->GetCurrentPos());
+			Lex();
+			break;
+		case TK_FUNCTION:
+			FunctionStatement();
+			break;
+		case TK_CLASS:
+			ClassStatement();
+			break;
+		case _SC('{'):{
+				SQInteger stacksize = _fs->GetStackSize();
+				Lex();
+				Statements();
+				Expect(_SC('}'));
+				_fs->SetStackSize(stacksize);
+			}
+			break;
+		case TK_TRY:
+			TryCatchStatement();
+			break;
+		case TK_THROW:
+			Lex();
+			CommaExpr();
+			_fs->AddInstruction(_OP_THROW, _fs->PopTarget());
+			break;
+		default:
+			CommaExpr();
+			_fs->PopTarget();
+			break;
+		}
+		_fs->SnoozeOpt();
+	}
+	void EmitDerefOp(SQOpcode op)
+	{
+		SQInteger val = _fs->PopTarget();
+		SQInteger key = _fs->PopTarget();
+		SQInteger src = _fs->PopTarget();
+        _fs->AddInstruction(op,_fs->PushTarget(),src,key,val);
+	}
+	void Emit2ArgsOP(SQOpcode op, SQInteger p3 = 0)
+	{
+		SQInteger p2 = _fs->PopTarget(); //src in OP_GET
+		SQInteger p1 = _fs->PopTarget(); //key in OP_GET
+		_fs->AddInstruction(op,_fs->PushTarget(), p1, p2, p3);
+	}
+	void EmitCompoundArith(SQInteger tok,bool deref)
+	{
+		SQInteger oper;
+		switch(tok){
+		case TK_MINUSEQ: oper = '-'; break;
+		case TK_PLUSEQ: oper = '+'; break;
+		case TK_MULEQ: oper = '*'; break;
+		case TK_DIVEQ: oper = '/'; break;
+		case TK_MODEQ: oper = '%'; break;
+		default: oper = 0; //shut up compiler
+			assert(0); break;
+		};
+		if(deref) {
+			SQInteger val = _fs->PopTarget();
+			SQInteger key = _fs->PopTarget();
+			SQInteger src = _fs->PopTarget();
+			//mixes dest obj and source val in the arg1(hack?)
+			_fs->AddInstruction(_OP_COMPARITH,_fs->PushTarget(),(src<<16)|val,key,oper);
+		}
+		else {
+			Emit2ArgsOP(_OP_COMPARITHL, oper);
+		}
+	}
+	void CommaExpr()
+	{
+		for(Expression();_token == ',';_fs->PopTarget(), Lex(), CommaExpr());
+	}
+	ExpState Expression(bool funcarg = false)
+	{
+		PushExpState();
+		_exst._class_or_delete = false;
+		_exst._funcarg = funcarg;
+		LogicalOrExp();
+		switch(_token)  {
+		case _SC('='):
+		case TK_NEWSLOT:
+		case TK_MINUSEQ:
+		case TK_PLUSEQ:
+		case TK_MULEQ:
+		case TK_DIVEQ:
+		case TK_MODEQ:
+		{
+				SQInteger op = _token;
+				SQInteger ds = _exst._deref;
+				bool freevar = _exst._freevar;
+				if(ds == DEREF_NO_DEREF) Error(_SC("can't assign expression"));
+				Lex(); Expression();
+
+				switch(op){
+				case TK_NEWSLOT:
+					if(freevar) Error(_SC("free variables cannot be modified"));
+					if(ds == DEREF_FIELD)
+						EmitDerefOp(_OP_NEWSLOT);
+					else //if _derefstate != DEREF_NO_DEREF && DEREF_FIELD so is the index of a local
+						Error(_SC("can't 'create' a local slot"));
+					break;
+				case _SC('='): //ASSIGN
+					if(freevar) Error(_SC("free variables cannot be modified"));
+					if(ds == DEREF_FIELD)
+						EmitDerefOp(_OP_SET);
+					else {//if _derefstate != DEREF_NO_DEREF && DEREF_FIELD so is the index of a local
+						SQInteger p2 = _fs->PopTarget(); //src in OP_GET
+						SQInteger p1 = _fs->TopTarget(); //key in OP_GET
+						_fs->AddInstruction(_OP_MOVE, p1, p2);
+					}
+					break;
+				case TK_MINUSEQ:
+				case TK_PLUSEQ:
+				case TK_MULEQ:
+				case TK_DIVEQ:
+				case TK_MODEQ:
+					EmitCompoundArith(op,ds == DEREF_FIELD);
+					break;
+				}
+			}
+			break;
+		case _SC('?'): {
+			Lex();
+			_fs->AddInstruction(_OP_JZ, _fs->PopTarget());
+			SQInteger jzpos = _fs->GetCurrentPos();
+			SQInteger trg = _fs->PushTarget();
+			Expression();
+			SQInteger first_exp = _fs->PopTarget();
+			if(trg != first_exp) _fs->AddInstruction(_OP_MOVE, trg, first_exp);
+			SQInteger endfirstexp = _fs->GetCurrentPos();
+			_fs->AddInstruction(_OP_JMP, 0, 0);
+			Expect(_SC(':'));
+			SQInteger jmppos = _fs->GetCurrentPos();
+			Expression();
+			SQInteger second_exp = _fs->PopTarget();
+			if(trg != second_exp) _fs->AddInstruction(_OP_MOVE, trg, second_exp);
+			_fs->SetIntructionParam(jmppos, 1, _fs->GetCurrentPos() - jmppos);
+			_fs->SetIntructionParam(jzpos, 1, endfirstexp - jzpos + 1);
+			_fs->SnoozeOpt();
+			}
+			break;
+		}
+		return PopExpState();
+	}
+	void BIN_EXP(SQOpcode op, void (SQCompiler::*f)(void),SQInteger op3 = 0)
+	{
+		Lex(); (this->*f)();
+		SQInteger op1 = _fs->PopTarget();SQInteger op2 = _fs->PopTarget();
+		_fs->AddInstruction(op, _fs->PushTarget(), op1, op2, op3);
+	}
+	void LogicalOrExp()
+	{
+		LogicalAndExp();
+		for(;;) if(_token == TK_OR) {
+			SQInteger first_exp = _fs->PopTarget();
+			SQInteger trg = _fs->PushTarget();
+			_fs->AddInstruction(_OP_OR, trg, 0, first_exp, 0);
+			SQInteger jpos = _fs->GetCurrentPos();
+			if(trg != first_exp) _fs->AddInstruction(_OP_MOVE, trg, first_exp);
+			Lex(); LogicalOrExp();
+			_fs->SnoozeOpt();
+			SQInteger second_exp = _fs->PopTarget();
+			if(trg != second_exp) _fs->AddInstruction(_OP_MOVE, trg, second_exp);
+			_fs->SnoozeOpt();
+			_fs->SetIntructionParam(jpos, 1, (_fs->GetCurrentPos() - jpos));
+			break;
+		}else return;
+	}
+	void LogicalAndExp()
+	{
+		BitwiseOrExp();
+		for(;;) switch(_token) {
+		case TK_AND: {
+			SQInteger first_exp = _fs->PopTarget();
+			SQInteger trg = _fs->PushTarget();
+			_fs->AddInstruction(_OP_AND, trg, 0, first_exp, 0);
+			SQInteger jpos = _fs->GetCurrentPos();
+			if(trg != first_exp) _fs->AddInstruction(_OP_MOVE, trg, first_exp);
+			Lex(); LogicalAndExp();
+			_fs->SnoozeOpt();
+			SQInteger second_exp = _fs->PopTarget();
+			if(trg != second_exp) _fs->AddInstruction(_OP_MOVE, trg, second_exp);
+			_fs->SnoozeOpt();
+			_fs->SetIntructionParam(jpos, 1, (_fs->GetCurrentPos() - jpos));
+			break;
+			}
+		case TK_IN: BIN_EXP(_OP_EXISTS, &SQCompiler::BitwiseOrExp); break;
+		case TK_INSTANCEOF: BIN_EXP(_OP_INSTANCEOF, &SQCompiler::BitwiseOrExp); break;
+		default:
+			return;
+		}
+	}
+	void BitwiseOrExp()
+	{
+		BitwiseXorExp();
+		for(;;) if(_token == _SC('|'))
+		{BIN_EXP(_OP_BITW, &SQCompiler::BitwiseXorExp,BW_OR);
+		}else return;
+	}
+	void BitwiseXorExp()
+	{
+		BitwiseAndExp();
+		for(;;) if(_token == _SC('^'))
+		{BIN_EXP(_OP_BITW, &SQCompiler::BitwiseAndExp,BW_XOR);
+		}else return;
+	}
+	void BitwiseAndExp()
+	{
+		CompExp();
+		for(;;) if(_token == _SC('&'))
+		{BIN_EXP(_OP_BITW, &SQCompiler::CompExp,BW_AND);
+		}else return;
+	}
+	void CompExp()
+	{
+		ShiftExp();
+		for(;;) switch(_token) {
+		case TK_EQ: BIN_EXP(_OP_EQ, &SQCompiler::ShiftExp); break;
+		case _SC('>'): BIN_EXP(_OP_CMP, &SQCompiler::ShiftExp,CMP_G); break;
+		case _SC('<'): BIN_EXP(_OP_CMP, &SQCompiler::ShiftExp,CMP_L); break;
+		case TK_GE: BIN_EXP(_OP_CMP, &SQCompiler::ShiftExp,CMP_GE); break;
+		case TK_LE: BIN_EXP(_OP_CMP, &SQCompiler::ShiftExp,CMP_LE); break;
+		case TK_NE: BIN_EXP(_OP_NE, &SQCompiler::ShiftExp); break;
+		default: return;	
+		}
+	}
+	void ShiftExp()
+	{
+		PlusExp();
+		for(;;) switch(_token) {
+		case TK_USHIFTR: BIN_EXP(_OP_BITW, &SQCompiler::PlusExp,BW_USHIFTR); break;
+		case TK_SHIFTL: BIN_EXP(_OP_BITW, &SQCompiler::PlusExp,BW_SHIFTL); break;
+		case TK_SHIFTR: BIN_EXP(_OP_BITW, &SQCompiler::PlusExp,BW_SHIFTR); break;
+		default: return;	
+		}
+	}
+	void PlusExp()
+	{
+		MultExp();
+		for(;;) switch(_token) {
+		case _SC('+'): case _SC('-'):
+			BIN_EXP(_OP_ARITH, &SQCompiler::MultExp,_token); break;
+		default: return;
+		}
+	}
+	
+	void MultExp()
+	{
+		PrefixedExpr();
+		for(;;) switch(_token) {
+		case _SC('*'): case _SC('/'): case _SC('%'):
+			BIN_EXP(_OP_ARITH, &SQCompiler::PrefixedExpr,_token); break;
+		default: return;
+		}
+	}
+	//if 'pos' != -1 the previous variable is a local variable
+	void PrefixedExpr()
+	{
+		SQInteger pos = Factor();
+		for(;;) {
+			switch(_token) {
+			case _SC('.'): {
+				pos = -1;
+				Lex(); 
+				if(_token == TK_PARENT) {
+					Lex();
+					if(!NeedGet())
+						Error(_SC("parent cannot be set"));
+					SQInteger src = _fs->PopTarget();
+					_fs->AddInstruction(_OP_GETPARENT, _fs->PushTarget(), src);
+				}
+				else {
+					_fs->AddInstruction(_OP_LOAD, _fs->PushTarget(), _fs->GetConstant(Expect(TK_IDENTIFIER)));
+					if(NeedGet()) Emit2ArgsOP(_OP_GET);
+				}
+				_exst._deref = DEREF_FIELD;
+				_exst._freevar = false;
+				}
+				break;
+			case _SC('['):
+				if(_lex._prevtoken == _SC('\n')) Error(_SC("cannot brake deref/or comma needed after [exp]=exp slot declaration"));
+				Lex(); Expression(); Expect(_SC(']')); 
+				pos = -1;
+				if(NeedGet()) Emit2ArgsOP(_OP_GET);
+				_exst._deref = DEREF_FIELD;
+				_exst._freevar = false;
+				break;
+			case TK_MINUSMINUS:
+			case TK_PLUSPLUS:
+			if(_exst._deref != DEREF_NO_DEREF && !IsEndOfStatement()) { 
+				SQInteger tok = _token; Lex();
+				if(pos < 0)
+					Emit2ArgsOP(_OP_PINC,tok == TK_MINUSMINUS?-1:1);
+				else {//if _derefstate != DEREF_NO_DEREF && DEREF_FIELD so is the index of a local
+					SQInteger src = _fs->PopTarget();
+					_fs->AddInstruction(_OP_PINCL, _fs->PushTarget(), src, 0, tok == TK_MINUSMINUS?-1:1);
+				}
+				
+			}
+			return;
+			break;	
+			case _SC('('): 
+				{
+				if(_exst._deref != DEREF_NO_DEREF) {
+					if(pos<0) {
+						SQInteger key = _fs->PopTarget(); //key
+						SQInteger table = _fs->PopTarget(); //table etc...
+						SQInteger closure = _fs->PushTarget();
+						SQInteger ttarget = _fs->PushTarget();
+						_fs->AddInstruction(_OP_PREPCALL, closure, key, table, ttarget);
+					}
+					else{
+						_fs->AddInstruction(_OP_MOVE, _fs->PushTarget(), 0);
+					}
+				}
+				else
+					_fs->AddInstruction(_OP_MOVE, _fs->PushTarget(), 0);
+				_exst._deref = DEREF_NO_DEREF;
+				Lex();
+				FunctionCallArgs();
+				 }
+				break;
+			default: return;
+			}
+		}
+	}
+	SQInteger Factor()
+	{
+		switch(_token)
+		{
+		case TK_STRING_LITERAL: {
+				//SQObjectPtr id(SQString::Create(_ss(_vm), _lex._svalue,_lex._longstr.size()-1));
+				_fs->AddInstruction(_OP_LOAD, _fs->PushTarget(), _fs->GetConstant(_fs->CreateString(_lex._svalue,_lex._longstr.size()-1)));
+				Lex(); 
+			}
+			break;
+		case TK_VARGC: Lex(); _fs->AddInstruction(_OP_VARGC, _fs->PushTarget()); break;
+		case TK_VARGV: { Lex();
+			Expect(_SC('['));
+			Expression();
+			Expect(_SC(']'));
+			SQInteger src = _fs->PopTarget();
+			_fs->AddInstruction(_OP_GETVARGV, _fs->PushTarget(), src);
+					   }
+			break;
+		case TK_IDENTIFIER:
+		case TK_CONSTRUCTOR:
+		case TK_THIS:{
+			_exst._freevar = false;
+			SQObject id;
+				switch(_token) {
+					case TK_IDENTIFIER: id = _fs->CreateString(_lex._svalue); break;
+					case TK_THIS: id = _fs->CreateString(_SC("this")); break;
+					case TK_CONSTRUCTOR: id = _fs->CreateString(_SC("constructor")); break;
+				}
+				SQInteger pos = -1;
+				Lex();
+				if((pos = _fs->GetLocalVariable(id)) == -1) {
+					//checks if is a free variable
+					if((pos = _fs->GetOuterVariable(id)) != -1) {
+						_exst._deref = _fs->PushTarget();
+						_fs->AddInstruction(_OP_LOADFREEVAR, _exst._deref ,pos);	
+						_exst._freevar = true;
+					} else {
+						_fs->PushTarget(0);
+						_fs->AddInstruction(_OP_LOAD, _fs->PushTarget(), _fs->GetConstant(id));
+						if(NeedGet()) Emit2ArgsOP(_OP_GET);
+						_exst._deref = DEREF_FIELD;
+					}
+				}
+				else{
+					_fs->PushTarget(pos);
+					_exst._deref = pos;
+				}
+				return _exst._deref;
+			}
+			break;
+		case TK_PARENT: Lex();_fs->AddInstruction(_OP_GETPARENT, _fs->PushTarget(), 0); break;
+		case TK_DOUBLE_COLON:  // "::"
+			_fs->AddInstruction(_OP_LOADROOTTABLE, _fs->PushTarget());
+			_exst._deref = DEREF_FIELD;
+			_token = _SC('.'); //hack
+			return -1;
+			break;
+		case TK_NULL: 
+			_fs->AddInstruction(_OP_LOADNULLS, _fs->PushTarget(),1);
+			Lex();
+			break;
+		case TK_INTEGER: {
+			if((_lex._nvalue & (~0x7FFFFFFF)) == 0) { //does it fit in 32 bits?
+				_fs->AddInstruction(_OP_LOADINT, _fs->PushTarget(),_lex._nvalue);
+			}
+			else {
+				_fs->AddInstruction(_OP_LOAD, _fs->PushTarget(), _fs->GetNumericConstant(_lex._nvalue));
+			}
+			Lex();
+						 }
+			break;
+		case TK_FLOAT: 
+			_fs->AddInstruction(_OP_LOAD, _fs->PushTarget(), _fs->GetNumericConstant(_lex._fvalue));
+			Lex();
+			break;
+		case TK_TRUE: case TK_FALSE:
+			_fs->AddInstruction(_OP_LOADBOOL, _fs->PushTarget(),_token == TK_TRUE?1:0);
+			Lex();
+			break;
+		case _SC('['): {
+				_fs->AddInstruction(_OP_NEWARRAY, _fs->PushTarget());
+				SQInteger apos = _fs->GetCurrentPos(),key = 0;
+				Lex();
+				while(_token != _SC(']')) {
+                    Expression(); 
+					if(_token == _SC(',')) Lex();
+					SQInteger val = _fs->PopTarget();
+					SQInteger array = _fs->TopTarget();
+					_fs->AddInstruction(_OP_APPENDARRAY, array, val);
+					key++;
+				}
+				_fs->SetIntructionParam(apos, 1, key);
+				Lex();
+			}
+			break;
+		case _SC('{'):{
+			_fs->AddInstruction(_OP_NEWTABLE, _fs->PushTarget());
+			Lex();ParseTableOrClass(_SC(','));
+				 }
+			break;
+		case TK_FUNCTION: FunctionExp(_token);break;
+		case TK_CLASS: Lex(); ClassExp();break;
+		case _SC('-'): UnaryOP(_OP_NEG); break;
+		case _SC('!'): UnaryOP(_OP_NOT); break;
+		case _SC('~'): UnaryOP(_OP_BWNOT); break;
+		case TK_TYPEOF : UnaryOP(_OP_TYPEOF); break;
+		case TK_RESUME : UnaryOP(_OP_RESUME); break;
+		case TK_CLONE : UnaryOP(_OP_CLONE); break;
+		case TK_MINUSMINUS : 
+		case TK_PLUSPLUS :PrefixIncDec(_token); break;
+		case TK_DELETE : DeleteExpr(); break;
+		case TK_DELEGATE : DelegateExpr(); break;
+		case _SC('('): Lex(); CommaExpr(); Expect(_SC(')'));
+			break;
+		default: Error(_SC("expression expected"));
+		}
+		return -1;
+	}
+	void UnaryOP(SQOpcode op)
+	{
+		Lex(); PrefixedExpr();
+		SQInteger src = _fs->PopTarget();
+		_fs->AddInstruction(op, _fs->PushTarget(), src);
+	}
+	bool NeedGet()
+	{
+		switch(_token) {
+		case _SC('='): case _SC('('): case TK_NEWSLOT: case TK_PLUSPLUS: case TK_MINUSMINUS:
+		case TK_PLUSEQ: case TK_MINUSEQ: case TK_MULEQ: case TK_DIVEQ: case TK_MODEQ:
+			return false;
+		}
+		return (!_exst._class_or_delete) || (_exst._class_or_delete && (_token == _SC('.') || _token == _SC('[')));
+	}
+	
+	void FunctionCallArgs()
+	{
+		SQInteger nargs = 1;//this
+		 while(_token != _SC(')')) {
+			 Expression(true);
+			 MoveIfCurrentTargetIsLocal();
+			 nargs++; 
+			 if(_token == _SC(',')){ 
+				 Lex(); 
+				 if(_token == ')') Error(_SC("expression expected, found ')'"));
+			 }
+		 }
+		 Lex();
+		 for(SQInteger i = 0; i < (nargs - 1); i++) _fs->PopTarget();
+		 SQInteger stackbase = _fs->PopTarget();
+		 SQInteger closure = _fs->PopTarget();
+         _fs->AddInstruction(_OP_CALL, _fs->PushTarget(), closure, stackbase, nargs);
+	}
+	void ParseTableOrClass(SQInteger separator,SQInteger terminator = '}')
+	{
+		SQInteger tpos = _fs->GetCurrentPos(),nkeys = 0;
+		
+		while(_token != terminator) {
+			bool hasattrs = false;
+			bool isstatic = false;
+			//check if is an attribute
+			if(separator == ';') {
+				if(_token == TK_ATTR_OPEN) {
+					_fs->AddInstruction(_OP_NEWTABLE, _fs->PushTarget()); Lex();
+					ParseTableOrClass(',',TK_ATTR_CLOSE);
+					hasattrs = true;
+				}
+				if(_token == TK_STATIC) {
+					isstatic = true;
+					Lex();
+				}
+			}
+			switch(_token) {
+				case TK_FUNCTION:
+				case TK_CONSTRUCTOR:{
+					SQInteger tk = _token;
+					Lex();
+					SQObject id = tk == TK_FUNCTION ? Expect(TK_IDENTIFIER) : _fs->CreateString(_SC("constructor"));
+					Expect(_SC('('));
+					_fs->AddInstruction(_OP_LOAD, _fs->PushTarget(), _fs->GetConstant(id));
+					CreateFunction(id);
+					_fs->AddInstruction(_OP_CLOSURE, _fs->PushTarget(), _fs->_functions.size() - 1, 0);
+								  }
+								  break;
+				case _SC('['):
+					Lex(); CommaExpr(); Expect(_SC(']'));
+					Expect(_SC('=')); Expression();
+					break;
+				default :
+					_fs->AddInstruction(_OP_LOAD, _fs->PushTarget(), _fs->GetConstant(Expect(TK_IDENTIFIER)));
+					Expect(_SC('=')); Expression();
+			}
+
+			if(_token == separator) Lex();//optional comma/semicolon
+			nkeys++;
+			SQInteger val = _fs->PopTarget();
+			SQInteger key = _fs->PopTarget();
+			SQInteger attrs = hasattrs ? _fs->PopTarget():-1;
+			assert(hasattrs && attrs == key-1 || !hasattrs);
+			unsigned char flags = (hasattrs?NEW_SLOT_ATTRIBUTES_FLAG:0)|(isstatic?NEW_SLOT_STATIC_FLAG:0);
+			SQInteger table = _fs->TopTarget(); //<<BECAUSE OF THIS NO COMMON EMIT FUNC IS POSSIBLE
+			_fs->AddInstruction(_OP_NEWSLOTA, flags, table, key, val);
+			//_fs->PopTarget();
+		}
+		if(separator == _SC(',')) //hack recognizes a table from the separator
+			_fs->SetIntructionParam(tpos, 1, nkeys);
+		Lex();
+	}
+	void LocalDeclStatement()
+	{
+		SQObject varname;
+		do {
+			Lex(); varname = Expect(TK_IDENTIFIER);
+			if(_token == _SC('=')) {
+				Lex(); Expression();
+				SQInteger src = _fs->PopTarget();
+				SQInteger dest = _fs->PushTarget();
+				if(dest != src) _fs->AddInstruction(_OP_MOVE, dest, src);
+			}
+			else{
+				_fs->AddInstruction(_OP_LOADNULLS, _fs->PushTarget(),1);
+			}
+			_fs->PopTarget();
+			_fs->PushLocalVariable(varname);
+		
+		} while(_token == _SC(','));
+	}
+	void IfStatement()
+	{
+		SQInteger jmppos;
+		bool haselse = false;
+		Lex(); Expect(_SC('(')); CommaExpr(); Expect(_SC(')'));
+		_fs->AddInstruction(_OP_JZ, _fs->PopTarget());
+		SQInteger jnepos = _fs->GetCurrentPos();
+		SQInteger stacksize = _fs->GetStackSize();
+		
+		Statement();
+		//
+		if(_token != _SC('}') && _token != TK_ELSE) OptionalSemicolon();
+		
+		CleanStack(stacksize);
+		SQInteger endifblock = _fs->GetCurrentPos();
+		if(_token == TK_ELSE){
+			haselse = true;
+			stacksize = _fs->GetStackSize();
+			_fs->AddInstruction(_OP_JMP);
+			jmppos = _fs->GetCurrentPos();
+			Lex();
+			Statement(); OptionalSemicolon();
+			CleanStack(stacksize);
+			_fs->SetIntructionParam(jmppos, 1, _fs->GetCurrentPos() - jmppos);
+		}
+		_fs->SetIntructionParam(jnepos, 1, endifblock - jnepos + (haselse?1:0));
+	}
+	void WhileStatement()
+	{
+		SQInteger jzpos, jmppos;
+		SQInteger stacksize = _fs->GetStackSize();
+		jmppos = _fs->GetCurrentPos();
+		Lex(); Expect(_SC('(')); CommaExpr(); Expect(_SC(')'));
+		
+		BEGIN_BREAKBLE_BLOCK();
+		_fs->AddInstruction(_OP_JZ, _fs->PopTarget());
+		jzpos = _fs->GetCurrentPos();
+		stacksize = _fs->GetStackSize();
+		
+		Statement();
+		
+		CleanStack(stacksize);
+		_fs->AddInstruction(_OP_JMP, 0, jmppos - _fs->GetCurrentPos() - 1);
+		_fs->SetIntructionParam(jzpos, 1, _fs->GetCurrentPos() - jzpos);
+		
+		END_BREAKBLE_BLOCK(jmppos);
+	}
+	void DoWhileStatement()
+	{
+		Lex();
+		SQInteger jzpos = _fs->GetCurrentPos();
+		SQInteger stacksize = _fs->GetStackSize();
+		BEGIN_BREAKBLE_BLOCK()
+		Statement();
+		CleanStack(stacksize);
+		Expect(TK_WHILE);
+		SQInteger continuetrg = _fs->GetCurrentPos();
+		Expect(_SC('(')); CommaExpr(); Expect(_SC(')'));
+		_fs->AddInstruction(_OP_JNZ, _fs->PopTarget(), jzpos - _fs->GetCurrentPos() - 1);
+		END_BREAKBLE_BLOCK(continuetrg);
+	}
+	void ForStatement()
+	{
+		Lex();
+		SQInteger stacksize = _fs->GetStackSize();
+		Expect(_SC('('));
+		if(_token == TK_LOCAL) LocalDeclStatement();
+		else if(_token != _SC(';')){
+			CommaExpr();
+			_fs->PopTarget();
+		}
+		Expect(_SC(';'));
+		_fs->SnoozeOpt();
+		SQInteger jmppos = _fs->GetCurrentPos();
+		SQInteger jzpos = -1;
+		if(_token != _SC(';')) { CommaExpr(); _fs->AddInstruction(_OP_JZ, _fs->PopTarget()); jzpos = _fs->GetCurrentPos(); }
+		Expect(_SC(';'));
+		_fs->SnoozeOpt();
+		SQInteger expstart = _fs->GetCurrentPos() + 1;
+		if(_token != _SC(')')) {
+			CommaExpr();
+			_fs->PopTarget();
+		}
+		Expect(_SC(')'));
+		_fs->SnoozeOpt();
+		SQInteger expend = _fs->GetCurrentPos();
+		SQInteger expsize = (expend - expstart) + 1;
+		SQInstructionVec exp;
+		if(expsize > 0) {
+			for(SQInteger i = 0; i < expsize; i++)
+				exp.push_back(_fs->GetInstruction(expstart + i));
+			_fs->PopInstructions(expsize);
+		}
+		BEGIN_BREAKBLE_BLOCK()
+		Statement();
+		SQInteger continuetrg = _fs->GetCurrentPos();
+		if(expsize > 0) {
+			for(SQInteger i = 0; i < expsize; i++)
+				_fs->AddInstruction(exp[i]);
+		}
+		_fs->AddInstruction(_OP_JMP, 0, jmppos - _fs->GetCurrentPos() - 1, 0);
+		if(jzpos>  0) _fs->SetIntructionParam(jzpos, 1, _fs->GetCurrentPos() - jzpos);
+		CleanStack(stacksize);
+		
+		END_BREAKBLE_BLOCK(continuetrg);
+	}
+	void ForEachStatement()
+	{
+		SQObject idxname, valname;
+		Lex(); Expect(_SC('(')); valname = Expect(TK_IDENTIFIER);
+		if(_token == _SC(',')) {
+			idxname = valname;
+			Lex(); valname = Expect(TK_IDENTIFIER);
+		}
+		else{
+			idxname = _fs->CreateString(_SC("@INDEX@"));
+		}
+		Expect(TK_IN);
+		
+		//save the stack size
+		SQInteger stacksize = _fs->GetStackSize();
+		//put the table in the stack(evaluate the table expression)
+		Expression(); Expect(_SC(')'));
+		SQInteger container = _fs->TopTarget();
+		//push the index local var
+		SQInteger indexpos = _fs->PushLocalVariable(idxname);
+		_fs->AddInstruction(_OP_LOADNULLS, indexpos,1);
+		//push the value local var
+		SQInteger valuepos = _fs->PushLocalVariable(valname);
+		_fs->AddInstruction(_OP_LOADNULLS, valuepos,1);
+		//push reference index
+		SQInteger itrpos = _fs->PushLocalVariable(_fs->CreateString(_SC("@ITERATOR@"))); //use invalid id to make it inaccessible
+		_fs->AddInstruction(_OP_LOADNULLS, itrpos,1);
+		SQInteger jmppos = _fs->GetCurrentPos();
+		_fs->AddInstruction(_OP_FOREACH, container, 0, indexpos);
+		SQInteger foreachpos = _fs->GetCurrentPos();
+		//generate the statement code
+		BEGIN_BREAKBLE_BLOCK()
+		Statement();
+		_fs->AddInstruction(_OP_JMP, 0, jmppos - _fs->GetCurrentPos() - 1);
+		_fs->SetIntructionParam(foreachpos, 1, _fs->GetCurrentPos() - foreachpos);
+		//restore the local variable stack(remove index,val and ref idx)
+		CleanStack(stacksize);
+		END_BREAKBLE_BLOCK(foreachpos - 1);
+	}
+	void SwitchStatement()
+	{
+		Lex(); Expect(_SC('(')); CommaExpr(); Expect(_SC(')'));
+		Expect(_SC('{'));
+		SQInteger expr = _fs->TopTarget();
+		bool bfirst = true;
+		SQInteger tonextcondjmp = -1;
+		SQInteger skipcondjmp = -1;
+		SQInteger __nbreaks__ = _fs->_unresolvedbreaks.size();
+		_fs->_breaktargets.push_back(0);
+		while(_token == TK_CASE) {
+			//_fs->AddLineInfos(_lex._currentline, _lineinfo); think about this one
+			if(!bfirst) {
+				_fs->AddInstruction(_OP_JMP, 0, 0);
+				skipcondjmp = _fs->GetCurrentPos();
+				_fs->SetIntructionParam(tonextcondjmp, 1, _fs->GetCurrentPos() - tonextcondjmp);
+			}
+			//condition
+			Lex(); Expression(); Expect(_SC(':'));
+			SQInteger trg = _fs->PopTarget();
+			_fs->AddInstruction(_OP_EQ, trg, trg, expr);
+			_fs->AddInstruction(_OP_JZ, trg, 0);
+			//end condition
+			if(skipcondjmp != -1) {
+				_fs->SetIntructionParam(skipcondjmp, 1, (_fs->GetCurrentPos() - skipcondjmp));
+			}
+			tonextcondjmp = _fs->GetCurrentPos();
+			SQInteger stacksize = _fs->GetStackSize();
+			Statements();
+			_fs->SetStackSize(stacksize);
+			bfirst = false;
+		}
+		if(tonextcondjmp != -1)
+			_fs->SetIntructionParam(tonextcondjmp, 1, _fs->GetCurrentPos() - tonextcondjmp);
+		if(_token == TK_DEFAULT) {
+		//	_fs->AddLineInfos(_lex._currentline, _lineinfo);
+			Lex(); Expect(_SC(':'));
+			SQInteger stacksize = _fs->GetStackSize();
+			Statements();
+			_fs->SetStackSize(stacksize);
+		}
+		Expect(_SC('}'));
+		_fs->PopTarget();
+		__nbreaks__ = _fs->_unresolvedbreaks.size() - __nbreaks__;
+		if(__nbreaks__ > 0)ResolveBreaks(_fs, __nbreaks__);
+		_fs->_breaktargets.pop_back();
+		
+	}
+	void FunctionStatement()
+	{
+		SQObject id;
+		Lex(); id = Expect(TK_IDENTIFIER);
+		_fs->PushTarget(0);
+		_fs->AddInstruction(_OP_LOAD, _fs->PushTarget(), _fs->GetConstant(id));
+		if(_token == TK_DOUBLE_COLON) Emit2ArgsOP(_OP_GET);
+		
+		while(_token == TK_DOUBLE_COLON) {
+			Lex();
+			id = Expect(TK_IDENTIFIER);
+			_fs->AddInstruction(_OP_LOAD, _fs->PushTarget(), _fs->GetConstant(id));
+			if(_token == TK_DOUBLE_COLON) Emit2ArgsOP(_OP_GET);
+		}
+		Expect(_SC('('));
+		CreateFunction(id);
+		_fs->AddInstruction(_OP_CLOSURE, _fs->PushTarget(), _fs->_functions.size() - 1, 0);
+		EmitDerefOp(_OP_NEWSLOT);
+		_fs->PopTarget();
+	}
+	void ClassStatement()
+	{
+		ExpState es;
+		Lex(); PushExpState();
+		_exst._class_or_delete = true;
+		_exst._funcarg = false;
+		PrefixedExpr();
+		es = PopExpState();
+		if(es._deref == DEREF_NO_DEREF) Error(_SC("invalid class name"));
+		if(es._deref == DEREF_FIELD) {
+			ClassExp();
+			EmitDerefOp(_OP_NEWSLOT);
+			_fs->PopTarget();
+		}
+		else Error(_SC("cannot create a class in a local with the syntax(class <local>)"));
+	}
+	void TryCatchStatement()
+	{
+		SQObject exid;
+		Lex();
+		_fs->AddInstruction(_OP_PUSHTRAP,0,0);
+		_fs->_traps++;
+		if(_fs->_breaktargets.size()) _fs->_breaktargets.top()++;
+		if(_fs->_continuetargets.size()) _fs->_continuetargets.top()++;
+		SQInteger trappos = _fs->GetCurrentPos();
+		Statement();
+		_fs->_traps--;
+		_fs->AddInstruction(_OP_POPTRAP, 1, 0);
+		if(_fs->_breaktargets.size()) _fs->_breaktargets.top()--;
+		if(_fs->_continuetargets.size()) _fs->_continuetargets.top()--;
+		_fs->AddInstruction(_OP_JMP, 0, 0);
+		SQInteger jmppos = _fs->GetCurrentPos();
+		_fs->SetIntructionParam(trappos, 1, (_fs->GetCurrentPos() - trappos));
+		Expect(TK_CATCH); Expect(_SC('(')); exid = Expect(TK_IDENTIFIER); Expect(_SC(')'));
+		SQInteger stacksize = _fs->GetStackSize();
+		SQInteger ex_target = _fs->PushLocalVariable(exid);
+		_fs->SetIntructionParam(trappos, 0, ex_target);
+		Statement();
+		_fs->SetIntructionParams(jmppos, 0, (_fs->GetCurrentPos() - jmppos), 0);
+		CleanStack(stacksize);
+	}
+	void FunctionExp(SQInteger ftype)
+	{
+		Lex(); Expect(_SC('('));
+		CreateFunction(_null_);
+		_fs->AddInstruction(_OP_CLOSURE, _fs->PushTarget(), _fs->_functions.size() - 1, ftype == TK_FUNCTION?0:1);
+	}
+	void ClassExp()
+	{
+		SQInteger base = -1;
+		SQInteger attrs = -1;
+		if(_token == TK_EXTENDS) {
+			Lex(); Expression();
+			base = _fs->TopTarget();
+		}
+		if(_token == TK_ATTR_OPEN) {
+			Lex();
+			_fs->AddInstruction(_OP_NEWTABLE, _fs->PushTarget());
+			ParseTableOrClass(_SC(','),TK_ATTR_CLOSE);
+			attrs = _fs->TopTarget();
+		}
+		Expect(_SC('{'));
+		if(attrs != -1) _fs->PopTarget();
+		if(base != -1) _fs->PopTarget();
+		_fs->AddInstruction(_OP_CLASS, _fs->PushTarget(), base, attrs);
+		ParseTableOrClass(_SC(';'));
+	}
+	void DelegateExpr()
+	{
+		Lex(); CommaExpr();
+		Expect(_SC(':'));
+		CommaExpr();
+		SQInteger table = _fs->PopTarget(), delegate = _fs->PopTarget();
+		_fs->AddInstruction(_OP_DELEGATE, _fs->PushTarget(), table, delegate);
+	}
+	void DeleteExpr()
+	{
+		ExpState es;
+		Lex(); PushExpState();
+		_exst._class_or_delete = true;
+		_exst._funcarg = false;
+		PrefixedExpr();
+		es = PopExpState();
+		if(es._deref == DEREF_NO_DEREF) Error(_SC("can't delete an expression"));
+		if(es._deref == DEREF_FIELD) Emit2ArgsOP(_OP_DELETE);
+		else Error(_SC("cannot delete a local"));
+	}
+	void PrefixIncDec(SQInteger token)
+	{
+		ExpState es;
+		Lex(); PushExpState();
+		_exst._class_or_delete = true;
+		_exst._funcarg = false;
+		PrefixedExpr();
+		es = PopExpState();
+		if(es._deref == DEREF_FIELD) Emit2ArgsOP(_OP_INC,token == TK_MINUSMINUS?-1:1);
+		else {
+			SQInteger src = _fs->PopTarget();
+			_fs->AddInstruction(_OP_INCL, _fs->PushTarget(), src, 0, token == TK_MINUSMINUS?-1:1);
+		}
+	}
+	void CreateFunction(SQObject &name)
+	{
+		
+		SQFuncState *funcstate = _fs->PushChildState(_ss(_vm));
+		funcstate->_name = name;
+		SQObject paramname;
+		funcstate->AddParameter(_fs->CreateString(_SC("this")));
+		funcstate->_sourcename = _sourcename;
+		while(_token!=_SC(')')) {
+			if(_token == TK_VARPARAMS) {
+				funcstate->_varparams = true;
+				Lex();
+				if(_token != _SC(')')) Error(_SC("expected ')'"));
+				break;
+			}
+			else {
+				paramname = Expect(TK_IDENTIFIER);
+				funcstate->AddParameter(paramname);
+				if(_token == _SC(',')) Lex();
+				else if(_token != _SC(')')) Error(_SC("expected ')' or ','"));
+			}
+		}
+		Expect(_SC(')'));
+		//outer values
+		if(_token == _SC(':')) {
+			Lex(); Expect(_SC('('));
+			while(_token != _SC(')')) {
+				paramname = Expect(TK_IDENTIFIER);
+				//outers are treated as implicit local variables
+				funcstate->AddOuterValue(paramname);
+				if(_token == _SC(',')) Lex();
+				else if(_token != _SC(')')) Error(_SC("expected ')' or ','"));
+			}
+			Lex();
+		}
+		
+		SQFuncState *currchunk = _fs;
+		_fs = funcstate;
+		Statement();
+		funcstate->AddLineInfos(_lex._prevtoken == _SC('\n')?_lex._lasttokenline:_lex._currentline, _lineinfo, true);
+        funcstate->AddInstruction(_OP_RETURN, -1);
+		funcstate->SetStackSize(0);
+		//_fs->->_stacksize = _fs->_stacksize;
+		SQFunctionProto *func = funcstate->BuildProto();
+#ifdef _DEBUG_DUMP
+		funcstate->Dump(func);
+#endif
+		_fs = currchunk;
+		_fs->_functions.push_back(func);
+		_fs->PopChildState();
+	}
+	void CleanStack(SQInteger stacksize)
+	{
+		if(_fs->GetStackSize() != stacksize)
+			_fs->SetStackSize(stacksize);
+	}
+	void ResolveBreaks(SQFuncState *funcstate, SQInteger ntoresolve)
+	{
+		while(ntoresolve > 0) {
+			SQInteger pos = funcstate->_unresolvedbreaks.back();
+			funcstate->_unresolvedbreaks.pop_back();
+			//set the jmp instruction
+			funcstate->SetIntructionParams(pos, 0, funcstate->GetCurrentPos() - pos, 0);
+			ntoresolve--;
+		}
+	}
+	void ResolveContinues(SQFuncState *funcstate, SQInteger ntoresolve, SQInteger targetpos)
+	{
+		while(ntoresolve > 0) {
+			SQInteger pos = funcstate->_unresolvedcontinues.back();
+			funcstate->_unresolvedcontinues.pop_back();
+			//set the jmp instruction
+			funcstate->SetIntructionParams(pos, 0, targetpos - pos, 0);
+			ntoresolve--;
+		}
+	}
+private:
+	SQInteger _token;
+	SQFuncState *_fs;
+	SQObjectPtr _sourcename;
+	SQLexer _lex;
+	bool _lineinfo;
+	bool _raiseerror;
+	SQInteger _debugline;
+	SQInteger _debugop;
+	ExpStateVec _expstates;
+	SQChar *compilererror;
+	jmp_buf _errorjmp;
+	SQVM *_vm;
+};
+
+bool Compile(SQVM *vm,SQLEXREADFUNC rg, SQUserPointer up, const SQChar *sourcename, SQObjectPtr &out, bool raiseerror, bool lineinfo)
+{
+	SQCompiler p(vm, rg, up, sourcename, raiseerror, lineinfo);
+	return p.Compile(out);
+}
diff -rupwN ../dnl3/SqPlus/_squirrel/sqcompiler.h SqPlus/_squirrel/sqcompiler.h
--- ../dnl3/SqPlus/_squirrel/sqcompiler.h	1969-12-31 19:00:00.000000000 -0500
+++ SqPlus/_squirrel/sqcompiler.h	2006-03-19 14:32:58.000000000 -0500
@@ -0,0 +1,75 @@
+/*	see copyright notice in squirrel.h */
+#ifndef _SQCOMPILER_H_
+#define _SQCOMPILER_H_
+
+struct SQVM;
+
+#define	TK_IDENTIFIER	258
+#define	TK_STRING_LITERAL	259
+#define	TK_INTEGER	260
+#define	TK_FLOAT	261
+#define	TK_DELEGATE	262
+#define	TK_DELETE	263
+#define	TK_EQ	264
+#define	TK_NE	265
+#define	TK_LE	266
+#define	TK_GE	267
+#define	TK_SWITCH	268
+#define	TK_ARROW	269
+#define	TK_AND	270
+#define	TK_OR	271
+#define	TK_IF	272
+#define	TK_ELSE	273
+#define	TK_WHILE	274
+#define	TK_BREAK	275
+#define	TK_FOR	276
+#define	TK_DO	277
+#define	TK_NULL	278
+#define	TK_FOREACH	279
+#define	TK_IN	280
+#define	TK_NEWSLOT	281
+#define	TK_MODULO	282
+#define	TK_LOCAL	283
+#define	TK_CLONE	284
+#define	TK_FUNCTION	285
+#define	TK_RETURN	286
+#define	TK_TYPEOF	287
+#define	TK_UMINUS	288
+#define	TK_PLUSEQ	289
+#define	TK_MINUSEQ	290
+#define	TK_CONTINUE	291
+#define TK_YIELD 292
+#define TK_TRY 293
+#define TK_CATCH 294
+#define TK_THROW 295
+#define TK_SHIFTL 296
+#define TK_SHIFTR 297
+#define TK_RESUME 298
+#define TK_DOUBLE_COLON 299
+#define TK_CASE 300
+#define TK_DEFAULT 301
+#define TK_THIS 302
+#define TK_PLUSPLUS 303
+#define TK_MINUSMINUS 304
+#define TK_PARENT 305
+#define TK_USHIFTR 306
+#define TK_CLASS 307
+#define TK_EXTENDS 308
+#define TK_CONSTRUCTOR 310
+#define TK_INSTANCEOF 311
+#define TK_VARPARAMS 312
+#define TK_VARGC 313
+#define TK_VARGV 314
+#define TK_TRUE 315
+#define TK_FALSE 316
+#define TK_MULEQ 317
+#define TK_DIVEQ 318
+#define TK_MODEQ 319
+#define TK_ATTR_OPEN 320
+#define TK_ATTR_CLOSE 321
+#define TK_STATIC 322
+
+
+typedef void(*CompilerErrorFunc)(void *ud, const SQChar *s);
+bool Compile(SQVM *vm, SQLEXREADFUNC rg, SQUserPointer up, const SQChar *sourcename, SQObjectPtr &out, bool raiseerror, bool lineinfo);
+#endif //_SQCOMPILER_H_
diff -rupwN ../dnl3/SqPlus/_squirrel/sqdebug.cpp SqPlus/_squirrel/sqdebug.cpp
--- ../dnl3/SqPlus/_squirrel/sqdebug.cpp	1969-12-31 19:00:00.000000000 -0500
+++ SqPlus/_squirrel/sqdebug.cpp	2006-03-19 14:32:58.000000000 -0500
@@ -0,0 +1,99 @@
+/*
+	see copyright notice in squirrel.h
+*/
+#include "sqpcheader.h"
+#include <stdarg.h>
+#include "sqvm.h"
+#include "sqfuncproto.h"
+#include "sqclosure.h"
+#include "sqstring.h"
+
+SQRESULT sq_stackinfos(HSQUIRRELVM v, SQInteger level, SQStackInfos *si)
+{
+	SQInteger cssize = v->_callsstack.size();
+	if (cssize > level) {
+		memset(si, 0, sizeof(SQStackInfos));
+		SQVM::CallInfo &ci = v->_callsstack[cssize-level-1];
+		switch (type(ci._closure)) {
+		case OT_CLOSURE:{
+			SQFunctionProto *func = _funcproto(_closure(ci._closure)->_function);
+			if (type(func->_name) == OT_STRING)
+				si->funcname = _stringval(func->_name);
+			if (type(func->_sourcename) == OT_STRING)
+				si->source = _stringval(func->_sourcename);
+			si->line = func->GetLine(ci._ip);
+						}
+			break;
+		case OT_NATIVECLOSURE:
+			si->source = _SC("NATIVE");
+			si->funcname = _SC("unknown");
+			if(type(_nativeclosure(ci._closure)->_name) == OT_STRING)
+				si->funcname = _stringval(_nativeclosure(ci._closure)->_name);
+			si->line = -1;
+			break;
+		default: break; //shutup compiler
+		}
+		return SQ_OK;
+	}
+	return SQ_ERROR;
+}
+
+void SQVM::Raise_Error(const SQChar *s, ...)
+{
+	va_list vl;
+	va_start(vl, s);
+	scvsprintf(_sp(rsl((SQInteger)scstrlen(s)+(NUMBER_MAX_CHAR*2))), s, vl);
+	va_end(vl);
+	_lasterror = SQString::Create(_ss(this),_spval,-1);
+}
+
+void SQVM::Raise_Error(SQObjectPtr &desc)
+{
+	_lasterror = desc;
+}
+
+SQString *SQVM::PrintObjVal(const SQObject &o)
+{
+	switch(type(o)) {
+	case OT_STRING: return _string(o);
+	case OT_INTEGER:
+		scsprintf(_sp(rsl(NUMBER_MAX_CHAR+1)), _SC("%d"), _integer(o));
+		return SQString::Create(_ss(this), _spval);
+		break;
+	case OT_FLOAT:
+		scsprintf(_sp(rsl(NUMBER_MAX_CHAR+1)), _SC("%.14g"), _float(o));
+		return SQString::Create(_ss(this), _spval);
+		break;
+	default:
+		return SQString::Create(_ss(this), GetTypeName(o));
+	}
+}
+
+void SQVM::Raise_IdxError(SQObject &o)
+{
+	SQObjectPtr oval = PrintObjVal(o);
+	Raise_Error(_SC("the index '%.50s' does not exist"), _stringval(oval));
+}
+
+void SQVM::Raise_CompareError(const SQObject &o1, const SQObject &o2)
+{
+	SQObjectPtr oval1 = PrintObjVal(o1), oval2 = PrintObjVal(o2);
+	Raise_Error(_SC("comparsion between '%.50s' and '%.50s'"), _stringval(oval1), _stringval(oval2));
+}
+
+
+void SQVM::Raise_ParamTypeError(SQInteger nparam,SQInteger typemask,SQInteger type)
+{
+	SQObjectPtr exptypes = SQString::Create(_ss(this), _SC(""), -1);
+	SQInteger found = 0;	
+	for(SQInteger i=0; i<16; i++)
+	{
+		SQInteger mask = 0x00000001 << i;
+		if(typemask & (mask)) {
+			if(found>0) StringCat(exptypes,SQString::Create(_ss(this), _SC("|"), -1), exptypes);
+			found ++;
+			StringCat(exptypes,SQString::Create(_ss(this), IdType2Name((SQObjectType)mask), -1), exptypes);
+		}
+	}
+	Raise_Error(_SC("parameter %d has an invalid type '%s' ; expected: '%s'"), nparam, IdType2Name((SQObjectType)type), _stringval(exptypes));
+}
diff -rupwN ../dnl3/SqPlus/_squirrel/sqfuncproto.h SqPlus/_squirrel/sqfuncproto.h
--- ../dnl3/SqPlus/_squirrel/sqfuncproto.h	1969-12-31 19:00:00.000000000 -0500
+++ SqPlus/_squirrel/sqfuncproto.h	2005-09-25 17:56:20.000000000 -0400
@@ -0,0 +1,88 @@
+/*	see copyright notice in squirrel.h */
+#ifndef _SQFUNCTION_H_
+#define _SQFUNCTION_H_
+
+#include "sqopcodes.h"
+
+enum SQOuterType {
+	otLOCAL = 0,
+	otSYMBOL = 1,
+	otOUTER = 2
+};
+
+struct SQOuterVar
+{
+	
+	SQOuterVar(){}
+	SQOuterVar(const SQObjectPtr &name,const SQObjectPtr &src,SQOuterType t)
+	{
+		_name = name;
+		_src=src;
+		_type=t;
+	}
+	SQOuterVar(const SQOuterVar &ov)
+	{
+		_type=ov._type;
+		_src=ov._src;
+		_name=ov._name;
+	}
+	SQOuterType _type;
+	SQObjectPtr _name;
+	SQObjectPtr _src;
+};
+
+struct SQLocalVarInfo
+{
+	SQLocalVarInfo():_start_op(0),_end_op(0){}
+	SQLocalVarInfo(const SQLocalVarInfo &lvi)
+	{
+		_name=lvi._name;
+		_start_op=lvi._start_op;
+		_end_op=lvi._end_op;
+		_pos=lvi._pos;
+	}
+	SQObjectPtr _name;
+	SQUnsignedInteger _start_op;
+	SQUnsignedInteger _end_op;
+	SQUnsignedInteger _pos;
+};
+
+struct SQLineInfo { SQInteger _line;SQInteger _op; };
+
+typedef sqvector<SQOuterVar> SQOuterVarVec;
+typedef sqvector<SQLocalVarInfo> SQLocalVarInfoVec;
+typedef sqvector<SQLineInfo> SQLineInfoVec;
+
+struct SQFunctionProto : public SQRefCounted
+{
+private:
+	SQFunctionProto(){
+	_stacksize=0;
+	_bgenerator=false;}
+public:
+	static SQFunctionProto *Create()
+	{
+		SQFunctionProto *f;
+		sq_new(f,SQFunctionProto);
+		return f;
+	}
+	void Release(){ sq_delete(this,SQFunctionProto);}
+	const SQChar* GetLocal(SQVM *v,SQUnsignedInteger stackbase,SQUnsignedInteger nseq,SQUnsignedInteger nop);
+	SQInteger GetLine(SQInstruction *curr);
+	bool Save(SQVM *v,SQUserPointer up,SQWRITEFUNC write);
+	bool Load(SQVM *v,SQUserPointer up,SQREADFUNC read);
+	SQObjectPtrVec _literals;
+	SQObjectPtrVec _functions;
+	SQObjectPtrVec _parameters;
+	SQOuterVarVec _outervalues;
+	SQInstructionVec _instructions;
+	SQObjectPtr _sourcename;
+	SQObjectPtr _name;
+	SQLocalVarInfoVec _localvarinfos;
+	SQLineInfoVec _lineinfos;
+    SQInteger _stacksize;
+	bool _bgenerator;
+	bool _varparams;
+};
+
+#endif //_SQFUNCTION_H_
diff -rupwN ../dnl3/SqPlus/_squirrel/sqfuncstate.cpp SqPlus/_squirrel/sqfuncstate.cpp
--- ../dnl3/SqPlus/_squirrel/sqfuncstate.cpp	1969-12-31 19:00:00.000000000 -0500
+++ SqPlus/_squirrel/sqfuncstate.cpp	2006-03-19 14:32:58.000000000 -0500
@@ -0,0 +1,544 @@
+/*
+	see copyright notice in squirrel.h
+*/
+#include "sqpcheader.h"
+#include "sqcompiler.h"
+#include "sqfuncproto.h"
+#include "sqstring.h"
+#include "sqtable.h"
+#include "sqopcodes.h"
+#include "sqfuncstate.h"
+
+#ifdef _DEBUG_DUMP
+SQInstructionDesc g_InstrDesc[]={
+	{_SC("_OP_LINE")},
+	{_SC("_OP_LOAD")},
+	{_SC("_OP_LOADINT")},
+	{_SC("_OP_DLOAD")},
+	{_SC("_OP_TAILCALL")},
+	{_SC("_OP_CALL")},
+	{_SC("_OP_PREPCALL")},
+	{_SC("_OP_PREPCALLK")},
+	{_SC("_OP_GETK")},
+	{_SC("_OP_MOVE")},
+	{_SC("_OP_NEWSLOT")},
+	{_SC("_OP_DELETE")},
+	{_SC("_OP_SET")},
+	{_SC("_OP_GET")},
+	{_SC("_OP_EQ")},
+	{_SC("_OP_NE")},
+	{_SC("_OP_ARITH")},
+	{_SC("_OP_BITW")},
+	{_SC("_OP_RETURN")},
+	{_SC("_OP_LOADNULLS")},
+	{_SC("_OP_LOADROOTTABLE")},
+	{_SC("_OP_LOADBOOL")},
+	{_SC("_OP_DMOVE")},
+	{_SC("_OP_JMP")},
+	{_SC("_OP_JNZ")},
+	{_SC("_OP_JZ")},
+	{_SC("_OP_LOADFREEVAR")},
+	{_SC("_OP_VARGC")},
+	{_SC("_OP_GETVARGV")},
+	{_SC("_OP_NEWTABLE")},
+	{_SC("_OP_NEWARRAY")},
+	{_SC("_OP_APPENDARRAY")},
+	{_SC("_OP_GETPARENT")},
+	{_SC("_OP_COMPARITH")},
+	{_SC("_OP_COMPARITHL")},
+	{_SC("_OP_INC")},
+	{_SC("_OP_INCL")},
+	{_SC("_OP_PINC")},
+	{_SC("_OP_PINCL")},
+	{_SC("_OP_CMP")},
+	{_SC("_OP_EXISTS")},
+	{_SC("_OP_INSTANCEOF")},
+	{_SC("_OP_AND")},
+	{_SC("_OP_OR")},
+	{_SC("_OP_NEG")},
+	{_SC("_OP_NOT")},
+	{_SC("_OP_BWNOT")},
+	{_SC("_OP_CLOSURE")},
+	{_SC("_OP_YIELD")},
+	{_SC("_OP_RESUME")},
+	{_SC("_OP_FOREACH")},
+	{_SC("_OP_DELEGATE")},
+	{_SC("_OP_CLONE")},
+	{_SC("_OP_TYPEOF")},
+	{_SC("_OP_PUSHTRAP")},
+	{_SC("_OP_POPTRAP")},
+	{_SC("_OP_THROW")},
+	{_SC("_OP_CLASS")},
+	{_SC("_OP_NEWSLOTA")}
+};
+#endif
+void DumpLiteral(SQObjectPtr &o)
+{
+	switch(type(o)){
+		case OT_STRING:	scprintf(_SC("\"%s\""),_stringval(o));break;
+		case OT_FLOAT: scprintf(_SC("{%f}"),_float(o));break;
+		case OT_INTEGER: scprintf(_SC("{%d}"),_integer(o));break;
+		default: assert(0); break; //shut up compiler
+	}
+}
+
+SQFuncState::SQFuncState(SQSharedState *ss,SQFuncState *parent,CompilerErrorFunc efunc,void *ed)
+{
+		_nliterals = 0;
+		_literals = SQTable::Create(ss,0);
+		_strings =  SQTable::Create(ss,0);
+		_sharedstate = ss;
+		_lastline = 0;
+		_optimization = true;
+		_parent = parent;
+		_stacksize = 0;
+		_traps = 0;
+		_returnexp = 0;
+		_varparams = false;
+		_errfunc = efunc;
+		_errtarget = ed;
+		_bgenerator = false;
+
+}
+
+void SQFuncState::Error(const SQChar *err)
+{
+	_errfunc(_errtarget,err);
+}
+
+#ifdef _DEBUG_DUMP
+void SQFuncState::Dump(SQFunctionProto *func)
+{
+	SQUnsignedInteger n=0,i;
+	scprintf(_SC("SQInstruction sizeof %d\n"),sizeof(SQInstruction));
+	scprintf(_SC("SQObject sizeof %d\n"),sizeof(SQObject));
+	scprintf(_SC("--------------------------------------------------------------------\n"));
+	scprintf(_SC("*****FUNCTION [%s]\n"),type(func->_name)==OT_STRING?_stringval(func->_name):_SC("unknown"));
+	scprintf(_SC("-----LITERALS\n"));
+	SQObjectPtr refidx,key,val;
+	SQInteger idx;
+	SQObjectPtrVec templiterals;
+	templiterals.resize(_nliterals);
+	while((idx=_table(_literals)->Next(false,refidx,key,val))!=-1) {
+		refidx=idx;
+		templiterals[_integer(val)]=key;
+	}
+	for(i=0;i<templiterals.size();i++){
+		scprintf(_SC("[%d] "),n);
+		DumpLiteral(templiterals[i]);
+		scprintf(_SC("\n"));
+		n++;
+	}
+	scprintf(_SC("-----PARAMS\n"));
+	if(_varparams)
+		scprintf(_SC("<<VARPARAMS>>\n"));
+	n=0;
+	for(i=0;i<_parameters.size();i++){
+		scprintf(_SC("[%d] "),n);
+		DumpLiteral(_parameters[i]);
+		scprintf(_SC("\n"));
+		n++;
+	}
+	scprintf(_SC("-----LOCALS\n"));
+	for(i=0;i<func->_localvarinfos.size();i++){
+		SQLocalVarInfo lvi=func->_localvarinfos[i];
+		scprintf(_SC("[%d] %s \t%d %d\n"),lvi._pos,_stringval(lvi._name),lvi._start_op,lvi._end_op);
+		n++;
+	}
+	scprintf(_SC("-----LINE INFO\n"));
+	for(i=0;i<_lineinfos.size();i++){
+		SQLineInfo li=_lineinfos[i];
+		scprintf(_SC("op [%d] line [%d] \n"),li._op,li._line);
+		n++;
+	}
+	scprintf(_SC("-----dump\n"));
+	n=0;
+	for(i=0;i<_instructions.size();i++){
+		SQInstruction &inst=_instructions[i];
+		if(inst.op==_OP_LOAD || inst.op==_OP_DLOAD || inst.op==_OP_PREPCALLK || inst.op==_OP_GETK ){
+			
+			SQInteger lidx = inst._arg1;
+			scprintf(_SC("[%03d] %15s %d "),n,g_InstrDesc[inst.op].name,inst._arg0);
+			if(lidx >= 0xFFFFFFFF)
+				scprintf(_SC("null"));
+			else {
+				SQInteger refidx;
+				SQObjectPtr val,key,refo;
+				while(((refidx=_table(_literals)->Next(false,refo,key,val))!= -1) && (_integer(val) != lidx)) {
+					refo = refidx;	
+				}
+				DumpLiteral(key);
+			}
+			if(inst.op != _OP_DLOAD) {
+				scprintf(_SC(" %d %d \n"),inst._arg2,inst._arg3);
+			}
+			else {
+				scprintf(_SC(" %d "),inst._arg2);
+				lidx = inst._arg3;
+				if(lidx >= 0xFFFFFFFF)
+					scprintf(_SC("null"));
+				else {
+					SQInteger refidx;
+					SQObjectPtr val,key,refo;
+					while(((refidx=_table(_literals)->Next(false,refo,key,val))!= -1) && (_integer(val) != lidx)) {
+						refo = refidx;	
+				}
+				DumpLiteral(key);
+				scprintf(_SC("\n"));
+			}
+			}
+		}
+		else if(inst.op==_OP_ARITH){
+			scprintf(_SC("[%03d] %15s %d %d %d %c\n"),n,g_InstrDesc[inst.op].name,inst._arg0,inst._arg1,inst._arg2,inst._arg3);
+		}
+		else 
+			scprintf(_SC("[%03d] %15s %d %d %d %d\n"),n,g_InstrDesc[inst.op].name,inst._arg0,inst._arg1,inst._arg2,inst._arg3);
+		n++;
+	}
+	scprintf(_SC("-----\n"));
+	scprintf(_SC("stack size[%d]\n"),func->_stacksize);
+	scprintf(_SC("--------------------------------------------------------------------\n\n"));
+}
+#endif
+
+SQInteger SQFuncState::GetNumericConstant(const SQInteger cons)
+{
+	return GetConstant(SQObjectPtr(cons));
+}
+
+SQInteger SQFuncState::GetNumericConstant(const SQFloat cons)
+{
+	return GetConstant(SQObjectPtr(cons));
+}
+
+SQInteger SQFuncState::GetConstant(const SQObject &cons)
+{
+	SQObjectPtr val;
+	if(!_table(_literals)->Get(cons,val))
+	{
+		val = _nliterals;
+		_table(_literals)->NewSlot(cons,val);
+		_nliterals++;
+		if(_nliterals > MAX_LITERALS) {
+			val.Null();
+			Error(_SC("internal compiler error: too many literals"));
+		}
+	}
+	return _integer(val);
+}
+
+void SQFuncState::SetIntructionParams(SQInteger pos,SQInteger arg0,SQInteger arg1,SQInteger arg2,SQInteger arg3)
+{
+	_instructions[pos]._arg0=(unsigned char)*((SQUnsignedInteger *)&arg0);
+	_instructions[pos]._arg1=(SQInt32)*((SQUnsignedInteger *)&arg1);
+	_instructions[pos]._arg2=(unsigned char)*((SQUnsignedInteger *)&arg2);
+	_instructions[pos]._arg3=(unsigned char)*((SQUnsignedInteger *)&arg3);
+}
+
+void SQFuncState::SetIntructionParam(SQInteger pos,SQInteger arg,SQInteger val)
+{
+	switch(arg){
+		case 0:_instructions[pos]._arg0=(unsigned char)*((SQUnsignedInteger *)&val);break;
+		case 1:case 4:_instructions[pos]._arg1=(SQInt32)*((SQUnsignedInteger *)&val);break;
+		case 2:_instructions[pos]._arg2=(unsigned char)*((SQUnsignedInteger *)&val);break;
+		case 3:_instructions[pos]._arg3=(unsigned char)*((SQUnsignedInteger *)&val);break;
+	};
+}
+
+SQInteger SQFuncState::AllocStackPos()
+{
+	SQInteger npos=_vlocals.size();
+	_vlocals.push_back(SQLocalVarInfo());
+	if(_vlocals.size()>((SQUnsignedInteger)_stacksize)) {
+		if(_stacksize>MAX_FUNC_STACKSIZE) Error(_SC("internal compiler error: too many locals"));
+		_stacksize=_vlocals.size();
+	}
+	return npos;
+}
+
+SQInteger SQFuncState::PushTarget(SQInteger n)
+{
+	if(n!=-1){
+		_targetstack.push_back(n);
+		return n;
+	}
+	n=AllocStackPos();
+	_targetstack.push_back(n);
+	return n;
+}
+
+SQInteger SQFuncState::GetUpTarget(SQInteger n){
+	return _targetstack[((_targetstack.size()-1)-n)];
+}
+
+SQInteger SQFuncState::TopTarget(){
+	return _targetstack.back();
+}
+SQInteger SQFuncState::PopTarget()
+{
+	SQInteger npos=_targetstack.back();
+	SQLocalVarInfo t=_vlocals[_targetstack.back()];
+	if(type(t._name)==OT_NULL){
+		_vlocals.pop_back();
+	}
+	_targetstack.pop_back();
+	return npos;
+}
+
+SQInteger SQFuncState::GetStackSize()
+{
+	return _vlocals.size();
+}
+
+void SQFuncState::SetStackSize(SQInteger n)
+{
+	SQInteger size=_vlocals.size();
+	while(size>n){
+		size--;
+		SQLocalVarInfo lvi=_vlocals.back();
+		if(type(lvi._name)!=OT_NULL){
+			lvi._end_op=GetCurrentPos();
+			_localvarinfos.push_back(lvi);
+		}
+		_vlocals.pop_back();
+	}
+}
+
+bool SQFuncState::IsLocal(SQUnsignedInteger stkpos)
+{
+	if(stkpos>=_vlocals.size())return false;
+	else if(type(_vlocals[stkpos]._name)!=OT_NULL)return true;
+	return false;
+}
+
+SQInteger SQFuncState::PushLocalVariable(const SQObject &name)
+{
+	SQInteger pos=_vlocals.size();
+	SQLocalVarInfo lvi;
+	lvi._name=name;
+	lvi._start_op=GetCurrentPos()+1;
+	lvi._pos=_vlocals.size();
+	_vlocals.push_back(lvi);
+	if(_vlocals.size()>((SQUnsignedInteger)_stacksize))_stacksize=_vlocals.size();
+	
+	return pos;
+}
+
+SQInteger SQFuncState::GetLocalVariable(const SQObject &name)
+{
+	SQInteger locals=_vlocals.size();
+	while(locals>=1){
+		if(type(_vlocals[locals-1]._name)==OT_STRING && _string(_vlocals[locals-1]._name)==_string(name)){
+			return locals-1;
+		}
+		locals--;
+	}
+	return -1;
+}
+
+SQInteger SQFuncState::GetOuterVariable(const SQObject &name)
+{
+	SQInteger outers = _outervalues.size();
+	for(SQInteger i = 0; i<outers; i++) {
+		if(_string(_outervalues[i]._name) == _string(name))
+			return i;
+	}
+	return -1;
+}
+
+void SQFuncState::AddOuterValue(const SQObject &name)
+{
+	SQInteger pos=-1;
+	if(_parent) { 
+		pos = _parent->GetLocalVariable(name);
+		if(pos == -1) {
+			pos = _parent->GetOuterVariable(name);
+			if(pos != -1) {
+				_outervalues.push_back(SQOuterVar(name,SQObjectPtr(SQInteger(pos)),otOUTER)); //local
+				return;
+			}
+		}
+		else {
+			_outervalues.push_back(SQOuterVar(name,SQObjectPtr(SQInteger(pos)),otLOCAL)); //local
+			return;
+		}
+	}	
+	_outervalues.push_back(SQOuterVar(name,name,otSYMBOL)); //global
+}
+
+void SQFuncState::AddParameter(const SQObject &name)
+{
+	PushLocalVariable(name);
+	_parameters.push_back(name);
+}
+
+void SQFuncState::AddLineInfos(SQInteger line,bool lineop,bool force)
+{
+	if(_lastline!=line || force){
+		SQLineInfo li;
+		li._line=line;li._op=(GetCurrentPos()+1);
+		if(lineop)AddInstruction(_OP_LINE,0,line);
+		_lineinfos.push_back(li);
+		_lastline=line;
+	}
+}
+
+void SQFuncState::AddInstruction(SQInstruction &i)
+{
+	SQInteger size = _instructions.size();
+	if(size > 0 && _optimization){ //simple optimizer
+		SQInstruction &pi = _instructions[size-1];//previous instruction
+		switch(i.op) {
+		case _OP_RETURN:
+			if( _parent && i._arg0 != MAX_FUNC_STACKSIZE && pi.op == _OP_CALL && _returnexp < size-1) {
+				pi.op = _OP_TAILCALL;
+			}
+		break;
+		case _OP_GET:
+			if( pi.op == _OP_LOAD && pi._arg0 == i._arg2 && (!IsLocal(pi._arg0))){
+				pi._arg1 = pi._arg1;
+				pi._arg2 = (unsigned char)i._arg1;
+				pi.op = _OP_GETK;
+				pi._arg0 = i._arg0;
+				
+				return;
+			}
+		break;
+		case _OP_PREPCALL:
+			if( pi.op == _OP_LOAD  && pi._arg0 == i._arg1 && (!IsLocal(pi._arg0))){
+				pi.op = _OP_PREPCALLK;
+				pi._arg0 = i._arg0;
+				pi._arg1 = pi._arg1;
+				pi._arg2 = i._arg2;
+				pi._arg3 = i._arg3;
+				return;
+			}
+			break;
+		case _OP_APPENDARRAY:
+			if(pi.op == _OP_LOAD && pi._arg0 == i._arg1 && (!IsLocal(pi._arg0))){
+				pi.op = _OP_APPENDARRAY;
+				pi._arg0 = i._arg0;
+				pi._arg1 = pi._arg1;
+				pi._arg2 = MAX_FUNC_STACKSIZE;
+				pi._arg3 = MAX_FUNC_STACKSIZE;
+				return;
+			}
+			break;
+		case _OP_MOVE: 
+			if((pi.op == _OP_GET || pi.op == _OP_ARITH || pi.op == _OP_BITW) && (pi._arg0 == i._arg1))
+			{
+				pi._arg0 = i._arg0;
+				_optimization = false;
+				return;
+			}
+
+			if(pi.op == _OP_MOVE)
+			{
+				pi.op = _OP_DMOVE;
+				pi._arg2 = i._arg0;
+				pi._arg3 = (unsigned char)i._arg1;
+				return;
+			}
+			break;
+		case _OP_LOAD:
+			if(pi.op == _OP_LOAD && i._arg1 < 256) {
+				pi.op = _OP_DLOAD;
+				pi._arg2 = i._arg0;
+				pi._arg3 = (unsigned char)i._arg1;
+				return;
+			}
+			break;
+		case _OP_EQ:case _OP_NE:
+			if(pi.op == _OP_LOAD && pi._arg0 == i._arg1 && (!IsLocal(pi._arg0) ))
+			{
+				pi.op = i.op;
+				pi._arg0 = i._arg0;
+				pi._arg1 = pi._arg1;
+				pi._arg2 = i._arg2;
+				pi._arg3 = MAX_FUNC_STACKSIZE;
+				return;
+			}
+			break;
+		case _OP_LOADNULLS:
+			if((pi.op == _OP_LOADNULLS && pi._arg0+pi._arg1 == i._arg0)) {
+				
+				pi._arg1 = pi._arg1 + 1;
+				pi.op = _OP_LOADNULLS;
+				return;
+			}
+            break;
+		case _OP_LINE:
+			if(pi.op == _OP_LINE) {
+				_instructions.pop_back();
+				_lineinfos.pop_back();
+			}
+			break;
+		}
+	}
+	_optimization = true;
+	_instructions.push_back(i);
+}
+
+SQObject SQFuncState::CreateString(const SQChar *s,SQInteger len)
+{
+	SQObjectPtr ns(SQString::Create(_sharedstate,s,len));
+	_table(_strings)->NewSlot(ns,(SQInteger)1);
+	return ns;
+}
+
+SQFunctionProto *SQFuncState::BuildProto()
+{
+	SQFunctionProto *f=SQFunctionProto::Create();
+	f->_literals.resize(_nliterals);
+	SQObjectPtr refidx,key,val;
+	SQInteger idx;
+
+	f->_stacksize = _stacksize;
+	f->_sourcename = _sourcename;
+	f->_bgenerator = _bgenerator;
+	f->_name = _name;
+
+	while((idx=_table(_literals)->Next(false,refidx,key,val))!=-1) {
+		f->_literals[_integer(val)]=key;
+		refidx=idx;
+	}
+
+	f->_functions.resize(_functions.size());
+	f->_functions.copy(_functions);
+	f->_parameters.resize(_parameters.size());
+	f->_parameters.copy(_parameters);
+	f->_outervalues.resize(_outervalues.size());
+	f->_outervalues.copy(_outervalues);
+	f->_instructions.resize(_instructions.size());
+	f->_instructions.copy(_instructions);
+	f->_localvarinfos.resize(_localvarinfos.size());
+	f->_localvarinfos.copy(_localvarinfos);
+	f->_lineinfos.resize(_lineinfos.size());
+	f->_lineinfos.copy(_lineinfos);
+	f->_varparams = _varparams;
+
+	return f;
+}
+
+SQFuncState *SQFuncState::PushChildState(SQSharedState *ss)
+{
+	SQFuncState *child = (SQFuncState *)sq_malloc(sizeof(SQFuncState));
+	new (child) SQFuncState(ss,this,_errfunc,_errtarget);
+	_childstates.push_back(child);
+	return child;
+}
+
+void SQFuncState::PopChildState()
+{
+	SQFuncState *child = _childstates.back();
+	sq_delete(child,SQFuncState);
+	_childstates.pop_back();
+}
+
+SQFuncState::~SQFuncState()
+{
+	while(_childstates.size() > 0)
+	{
+		PopChildState();
+	}
+}
diff -rupwN ../dnl3/SqPlus/_squirrel/sqfuncstate.h SqPlus/_squirrel/sqfuncstate.h
--- ../dnl3/SqPlus/_squirrel/sqfuncstate.h	1969-12-31 19:00:00.000000000 -0500
+++ SqPlus/_squirrel/sqfuncstate.h	2006-03-19 14:32:58.000000000 -0500
@@ -0,0 +1,80 @@
+/*	see copyright notice in squirrel.h */
+#ifndef _SQFUNCSTATE_H_
+#define _SQFUNCSTATE_H_
+///////////////////////////////////
+#include "squtils.h"
+
+struct SQFuncState
+{
+	SQFuncState(SQSharedState *ss,SQFuncState *parent,CompilerErrorFunc efunc,void *ed);
+	~SQFuncState();
+#ifdef _DEBUG_DUMP
+	void Dump(SQFunctionProto *func);
+#endif
+	void Error(const SQChar *err);
+	SQFuncState *PushChildState(SQSharedState *ss);
+	void PopChildState();
+	void AddInstruction(SQOpcode _op,SQInteger arg0=0,SQInteger arg1=0,SQInteger arg2=0,SQInteger arg3=0){SQInstruction i(_op,arg0,arg1,arg2,arg3);AddInstruction(i);}
+	void AddInstruction(SQInstruction &i);
+	void SetIntructionParams(SQInteger pos,SQInteger arg0,SQInteger arg1,SQInteger arg2=0,SQInteger arg3=0);
+	void SetIntructionParam(SQInteger pos,SQInteger arg,SQInteger val);
+	SQInstruction &GetInstruction(SQInteger pos){return _instructions[pos];}
+	void PopInstructions(SQInteger size){for(SQInteger i=0;i<size;i++)_instructions.pop_back();}
+	void SetStackSize(SQInteger n);
+	void SnoozeOpt(){_optimization=false;}
+	SQInteger GetCurrentPos(){return _instructions.size()-1;}
+	SQInteger GetNumericConstant(const SQInteger cons);
+	SQInteger GetNumericConstant(const SQFloat cons);
+	SQInteger PushLocalVariable(const SQObject &name);
+	void AddParameter(const SQObject &name);
+	void AddOuterValue(const SQObject &name);
+	SQInteger GetLocalVariable(const SQObject &name);
+	SQInteger GetOuterVariable(const SQObject &name);
+	SQInteger GenerateCode();
+	SQInteger GetStackSize();
+	SQInteger CalcStackFrameSize();
+	void AddLineInfos(SQInteger line,bool lineop,bool force=false);
+	SQFunctionProto *BuildProto();
+	SQInteger AllocStackPos();
+	SQInteger PushTarget(SQInteger n=-1);
+	SQInteger PopTarget();
+	SQInteger TopTarget();
+	SQInteger GetUpTarget(SQInteger n);
+	bool IsLocal(SQUnsignedInteger stkpos);
+	SQObject CreateString(const SQChar *s,SQInteger len = -1);
+	SQInteger _returnexp;
+	SQLocalVarInfoVec _vlocals;
+	SQIntVec _targetstack;
+	SQInteger _stacksize;
+	bool _varparams;
+	bool _bgenerator;
+	SQIntVec _unresolvedbreaks;
+	SQIntVec _unresolvedcontinues;
+	SQObjectPtrVec _functions;
+	SQObjectPtrVec _parameters;
+	SQOuterVarVec _outervalues;
+	SQInstructionVec _instructions;
+	SQLocalVarInfoVec _localvarinfos;
+	SQObjectPtr _literals;
+	SQObjectPtr _strings;
+	SQObjectPtr _name;
+	SQObjectPtr _sourcename;
+	SQInteger _nliterals;
+	SQLineInfoVec _lineinfos;
+	SQFuncState *_parent;
+	SQIntVec _breaktargets;
+	SQIntVec _continuetargets;
+	SQInteger _lastline;
+	SQInteger _traps; //contains number of nested exception traps
+	bool _optimization;
+	SQSharedState *_sharedstate;
+	sqvector<SQFuncState*> _childstates;
+	SQInteger GetConstant(const SQObject &cons);
+private:
+	CompilerErrorFunc _errfunc;
+	void *_errtarget;
+};
+
+
+#endif //_SQFUNCSTATE_H_
+
diff -rupwN ../dnl3/SqPlus/_squirrel/sqlexer.cpp SqPlus/_squirrel/sqlexer.cpp
--- ../dnl3/SqPlus/_squirrel/sqlexer.cpp	1969-12-31 19:00:00.000000000 -0500
+++ SqPlus/_squirrel/sqlexer.cpp	2006-03-19 14:32:58.000000000 -0500
@@ -0,0 +1,446 @@
+/*
+	see copyright notice in squirrel.h
+*/
+#include "sqpcheader.h"
+#include <ctype.h>
+#include <stdlib.h>
+#include "sqtable.h"
+#include "sqstring.h"
+#include "sqcompiler.h"
+#include "sqlexer.h"
+
+#define CUR_CHAR (_currdata)
+#define RETURN_TOKEN(t) { _prevtoken = _curtoken; _curtoken = t; return t;}
+#define IS_EOB() (CUR_CHAR <= SQUIRREL_EOB)
+#define NEXT() {Next();_currentcolumn++;}
+#define INIT_TEMP_STRING() { _longstr.resize(0);}
+#define APPEND_CHAR(c) { _longstr.push_back(c);}
+#define TERMINATE_BUFFER() {_longstr.push_back(_SC('\0'));}
+#define ADD_KEYWORD(key,id) _keywords->NewSlot( SQString::Create(ss, _SC(#key)) ,SQInteger(id))
+
+SQLexer::SQLexer(){}
+SQLexer::~SQLexer()
+{
+	_keywords->Release();
+}
+
+void SQLexer::Init(SQSharedState *ss, SQLEXREADFUNC rg, SQUserPointer up,CompilerErrorFunc efunc,void *ed)
+{
+	_errfunc = efunc;
+	_errtarget = ed;
+	_sharedstate = ss;
+	_keywords = SQTable::Create(ss, 26);
+	ADD_KEYWORD(while, TK_WHILE);
+	ADD_KEYWORD(do, TK_DO);
+	ADD_KEYWORD(if, TK_IF);
+	ADD_KEYWORD(else, TK_ELSE);
+	ADD_KEYWORD(break, TK_BREAK);
+	ADD_KEYWORD(continue, TK_CONTINUE);
+	ADD_KEYWORD(return, TK_RETURN);
+	ADD_KEYWORD(null, TK_NULL);
+	ADD_KEYWORD(function, TK_FUNCTION);
+	ADD_KEYWORD(local, TK_LOCAL);
+	ADD_KEYWORD(for, TK_FOR);
+	ADD_KEYWORD(foreach, TK_FOREACH);
+	ADD_KEYWORD(in, TK_IN);
+	ADD_KEYWORD(typeof, TK_TYPEOF);
+	ADD_KEYWORD(delegate, TK_DELEGATE);
+	ADD_KEYWORD(delete, TK_DELETE);
+	ADD_KEYWORD(try, TK_TRY);
+	ADD_KEYWORD(catch, TK_CATCH);
+	ADD_KEYWORD(throw, TK_THROW);
+	ADD_KEYWORD(clone, TK_CLONE);
+	ADD_KEYWORD(yield, TK_YIELD);
+	ADD_KEYWORD(resume, TK_RESUME);
+	ADD_KEYWORD(switch, TK_SWITCH);
+	ADD_KEYWORD(case, TK_CASE);
+	ADD_KEYWORD(default, TK_DEFAULT);
+	ADD_KEYWORD(this, TK_THIS);
+	ADD_KEYWORD(parent,TK_PARENT);
+	ADD_KEYWORD(class,TK_CLASS);
+	ADD_KEYWORD(extends,TK_EXTENDS);
+	ADD_KEYWORD(constructor,TK_CONSTRUCTOR);
+	ADD_KEYWORD(instanceof,TK_INSTANCEOF);
+	ADD_KEYWORD(vargc,TK_VARGC);
+	ADD_KEYWORD(vargv,TK_VARGV);
+	ADD_KEYWORD(true,TK_TRUE);
+	ADD_KEYWORD(false,TK_FALSE);
+	ADD_KEYWORD(static,TK_STATIC);
+
+	_readf = rg;
+	_up = up;
+	_lasttokenline = _currentline = 1;
+	_currentcolumn = 0;
+	_prevtoken = -1;
+	Next();
+}
+
+void SQLexer::Error(const SQChar *err)
+{
+	_errfunc(_errtarget,err);
+}
+
+void SQLexer::Next()
+{
+	SQInteger t = _readf(_up);
+	if(t > MAX_CHAR) Error(_SC("Invalid character"));
+	if(t != 0) {
+		_currdata = (LexChar)t;
+		return;
+	}
+	_currdata = SQUIRREL_EOB;
+}
+
+const SQChar *SQLexer::Tok2Str(SQInteger tok)
+{
+	SQObjectPtr itr, key, val;
+	SQInteger nitr;
+	while((nitr = _keywords->Next(false,itr, key, val)) != -1) {
+		itr = (SQInteger)nitr;
+		if(((SQInteger)_integer(val)) == tok)
+			return _stringval(key);
+	}
+	return NULL;
+}
+
+void SQLexer::LexBlockComment()
+{
+	bool done = false;
+	while(!done) {
+		switch(CUR_CHAR) {
+			case _SC('*'): { NEXT(); if(CUR_CHAR == _SC('/')) { done = true; NEXT(); }}; continue;
+			case _SC('\n'): _currentline++; NEXT(); continue;
+			case SQUIRREL_EOB: Error(_SC("missing \"*/\" in comment"));
+			default: NEXT();
+		}
+	}
+}
+
+SQInteger SQLexer::Lex()
+{
+	_lasttokenline = _currentline;
+	while(CUR_CHAR != SQUIRREL_EOB) {
+		switch(CUR_CHAR){
+		case _SC('\t'): case _SC('\r'): case _SC(' '): NEXT(); continue;
+		case _SC('\n'):
+			_currentline++;
+			_prevtoken=_curtoken;
+			_curtoken=_SC('\n');
+			NEXT();
+			_currentcolumn=1;
+			continue;
+		case _SC('/'):
+			NEXT();
+			switch(CUR_CHAR){
+			case _SC('*'):
+				NEXT();
+				LexBlockComment();
+				continue;	
+			case _SC('/'):
+				do { NEXT(); } while (CUR_CHAR != _SC('\n') && (!IS_EOB()));
+				continue;
+			case _SC('='):
+				NEXT();
+				RETURN_TOKEN(TK_DIVEQ);
+				continue;
+			case _SC('>'):
+				NEXT();
+				RETURN_TOKEN(TK_ATTR_CLOSE);
+				continue;
+			default:
+				RETURN_TOKEN('/');
+			}
+		case _SC('='):
+			NEXT();
+			if (CUR_CHAR != _SC('=')){ RETURN_TOKEN('=') }
+			else { NEXT(); RETURN_TOKEN(TK_EQ); }
+		case _SC('<'):
+			NEXT();
+			if ( CUR_CHAR == _SC('=') ) { NEXT(); RETURN_TOKEN(TK_LE) }
+			else if ( CUR_CHAR == _SC('-') ) { NEXT(); RETURN_TOKEN(TK_NEWSLOT); }
+			else if ( CUR_CHAR == _SC('<') ) { NEXT(); RETURN_TOKEN(TK_SHIFTL); }
+			else if ( CUR_CHAR == _SC('/') ) { NEXT(); RETURN_TOKEN(TK_ATTR_OPEN); }
+			//else if ( CUR_CHAR == _SC('[') ) { NEXT(); ReadMultilineString(); RETURN_TOKEN(TK_STRING_LITERAL); }
+			else { RETURN_TOKEN('<') }
+		case _SC('>'):
+			NEXT();
+			if (CUR_CHAR == _SC('=')){ NEXT(); RETURN_TOKEN(TK_GE);}
+			else if(CUR_CHAR == _SC('>')){ 
+				NEXT(); 
+				if(CUR_CHAR == _SC('>')){
+					NEXT();
+					RETURN_TOKEN(TK_USHIFTR);
+				}
+				RETURN_TOKEN(TK_SHIFTR);
+			}
+			else { RETURN_TOKEN('>') }
+		case _SC('!'):
+			NEXT();
+			if (CUR_CHAR != _SC('=')){ RETURN_TOKEN('!')}
+			else { NEXT(); RETURN_TOKEN(TK_NE); }
+		case _SC('@'): {
+			SQInteger stype;
+			NEXT(); 
+			if(CUR_CHAR != _SC('"'))
+				Error(_SC("string expected"));
+			if((stype=ReadString('"',true))!=-1) {
+				RETURN_TOKEN(stype);
+			}
+			Error(_SC("error parsing the string"));
+					   }
+		case _SC('"'):
+		case _SC('\''): {
+			SQInteger stype;
+			if((stype=ReadString(CUR_CHAR,false))!=-1){
+				RETURN_TOKEN(stype);
+			}
+			Error(_SC("error parsing the string"));
+			}
+		case _SC('{'): case _SC('}'): case _SC('('): case _SC(')'): case _SC('['): case _SC(']'):
+		case _SC(';'): case _SC(','): case _SC('?'): case _SC('^'): case _SC('~'):
+			{SQInteger ret = CUR_CHAR;
+			NEXT(); RETURN_TOKEN(ret); }
+		case _SC('.'):
+			NEXT();
+			if (CUR_CHAR != _SC('.')){ RETURN_TOKEN('.') }
+			NEXT();
+			if (CUR_CHAR != _SC('.')){ Error(_SC("invalid token '..'")); }
+			NEXT();
+			RETURN_TOKEN(TK_VARPARAMS);
+		case _SC('&'):
+			NEXT();
+			if (CUR_CHAR != _SC('&')){ RETURN_TOKEN('&') }
+			else { NEXT(); RETURN_TOKEN(TK_AND); }
+		case _SC('|'):
+			NEXT();
+			if (CUR_CHAR != _SC('|')){ RETURN_TOKEN('|') }
+			else { NEXT(); RETURN_TOKEN(TK_OR); }
+		case _SC(':'):
+			NEXT();
+			if (CUR_CHAR != _SC(':')){ RETURN_TOKEN(':') }
+			else { NEXT(); RETURN_TOKEN(TK_DOUBLE_COLON); }
+		case _SC('*'):
+			NEXT();
+			if (CUR_CHAR == _SC('=')){ NEXT(); RETURN_TOKEN(TK_MULEQ);}
+			else RETURN_TOKEN('*');
+		case _SC('%'):
+			NEXT();
+			if (CUR_CHAR == _SC('=')){ NEXT(); RETURN_TOKEN(TK_MODEQ);}
+			else RETURN_TOKEN('%');
+		case _SC('-'):
+			NEXT();
+			if (CUR_CHAR == _SC('=')){ NEXT(); RETURN_TOKEN(TK_MINUSEQ);}
+			else if  (CUR_CHAR == _SC('-')){ NEXT(); RETURN_TOKEN(TK_MINUSMINUS);}
+			else RETURN_TOKEN('-');
+		case _SC('+'):
+			NEXT();
+			if (CUR_CHAR == _SC('=')){ NEXT(); RETURN_TOKEN(TK_PLUSEQ);}
+			else if (CUR_CHAR == _SC('+')){ NEXT(); RETURN_TOKEN(TK_PLUSPLUS);}
+			else RETURN_TOKEN('+');
+		case SQUIRREL_EOB:
+			return 0;
+		default:{
+				if (scisdigit(CUR_CHAR)) {
+					SQInteger ret = ReadNumber();
+					RETURN_TOKEN(ret);
+				}
+				else if (scisalpha(CUR_CHAR) || CUR_CHAR == _SC('_')) {
+					SQInteger t = ReadID();
+					RETURN_TOKEN(t);
+				}
+				else {
+					SQInteger c = CUR_CHAR;
+					if (sciscntrl((int)c)) Error(_SC("unexpected character(control)"));
+					NEXT();
+					RETURN_TOKEN(c);  
+				}
+				RETURN_TOKEN(0);
+			}
+		}
+	}
+	return 0;    
+}
+	
+SQInteger SQLexer::GetIDType(SQChar *s)
+{
+	SQObjectPtr t;
+	if(_keywords->Get(SQString::Create(_sharedstate, s), t)) {
+		return SQInteger(_integer(t));
+	}
+	return TK_IDENTIFIER;
+}
+
+
+SQInteger SQLexer::ReadString(SQInteger ndelim,bool verbatim)
+{
+	INIT_TEMP_STRING();
+	NEXT();
+	if(IS_EOB()) return -1;
+	for(;;) {
+		while(CUR_CHAR != ndelim) {
+			switch(CUR_CHAR) {
+			case SQUIRREL_EOB:
+				Error(_SC("unfinished string"));
+				return -1;
+			case _SC('\n'): 
+				if(!verbatim) Error(_SC("newline in a constant")); 
+				APPEND_CHAR(CUR_CHAR); NEXT(); 
+				_currentline++;
+				break;
+			case _SC('\\'):
+				if(verbatim) {
+					APPEND_CHAR('\\'); NEXT(); 
+				}
+				else {
+					NEXT();
+					switch(CUR_CHAR) {
+					case _SC('x'): NEXT(); {
+						if(!isxdigit(CUR_CHAR)) Error(_SC("hexadecimal number expected")); 
+						const SQInteger maxdigits = 4;
+						SQChar temp[maxdigits+1];
+						SQInteger n = 0;
+						while(isxdigit(CUR_CHAR) && n < maxdigits) {
+							temp[n] = CUR_CHAR;
+							n++;
+							NEXT();
+						}
+						temp[n] = 0;
+						SQChar *sTemp;
+						APPEND_CHAR((SQChar)scstrtoul(temp,&sTemp,16));
+					}
+				    break;
+					case _SC('t'): APPEND_CHAR(_SC('\t')); NEXT(); break;
+					case _SC('a'): APPEND_CHAR(_SC('\a')); NEXT(); break;
+					case _SC('b'): APPEND_CHAR(_SC('\b')); NEXT(); break;
+					case _SC('n'): APPEND_CHAR(_SC('\n')); NEXT(); break;
+					case _SC('r'): APPEND_CHAR(_SC('\r')); NEXT(); break;
+					case _SC('v'): APPEND_CHAR(_SC('\v')); NEXT(); break;
+					case _SC('f'): APPEND_CHAR(_SC('\f')); NEXT(); break;
+					case _SC('0'): APPEND_CHAR(_SC('\0')); NEXT(); break;
+					case _SC('\\'): APPEND_CHAR(_SC('\\')); NEXT(); break;
+					case _SC('"'): APPEND_CHAR(_SC('"')); NEXT(); break;
+					case _SC('\''): APPEND_CHAR(_SC('\'')); NEXT(); break;
+					default:
+						Error(_SC("unrecognised escaper char"));
+					break;
+					}
+				}
+				break;
+			default:
+				APPEND_CHAR(CUR_CHAR);
+				NEXT();
+			}
+		}
+		NEXT();
+		if(verbatim && CUR_CHAR == '"') { //double quotation
+			APPEND_CHAR(CUR_CHAR);
+			NEXT();
+		}
+		else {
+			break;
+		}
+	}
+	TERMINATE_BUFFER();
+	SQInteger len = _longstr.size()-1;
+	if(ndelim == _SC('\'')) {
+		if(len == 0) Error(_SC("empty constant"));
+		if(len > 1) Error(_SC("constant too long"));
+		_nvalue = _longstr[0];
+		return TK_INTEGER;
+	}
+	_svalue = &_longstr[0];
+	return TK_STRING_LITERAL;
+}
+
+void LexHexadecimal(const SQChar *s,SQUnsignedInteger *res)
+{
+	*res = 0;
+	while(*s != 0)
+	{
+		if(scisdigit(*s)) *res = (*res)*16+((*s++)-'0');
+		else if(scisxdigit(*s)) *res = (*res)*16+(toupper(*s++)-'A'+10);
+		else { assert(0); }
+	}
+}
+
+void LexInteger(const SQChar *s,SQUnsignedInteger *res)
+{
+	*res = 0;
+	while(*s != 0)
+	{
+		*res = (*res)*10+((*s++)-'0');
+	}
+}
+
+SQInteger isexponent(SQInteger c) { return c == 'e' || c=='E'; }
+#define MAX_HEX_DIGITS (sizeof(SQInteger)*2)
+SQInteger SQLexer::ReadNumber()
+{
+#define TINT 1
+#define TFLOAT 2
+#define THEX 3
+#define TSCIENTIFIC 4
+	SQInteger type = TINT, firstchar = CUR_CHAR;
+	SQChar *sTemp;
+	INIT_TEMP_STRING();
+	NEXT();
+	if(firstchar == _SC('0') && toupper(CUR_CHAR) == _SC('X')) {
+		NEXT();
+		type = THEX;
+		while(isxdigit(CUR_CHAR)) {
+			APPEND_CHAR(CUR_CHAR);
+			NEXT();
+		}
+		if(_longstr.size() > MAX_HEX_DIGITS) Error(_SC("too many digits for an Hex number"));
+	}
+	else {
+		APPEND_CHAR((int)firstchar);
+		while (CUR_CHAR == _SC('.') || scisdigit(CUR_CHAR) || isexponent(CUR_CHAR)) {
+            if(CUR_CHAR == _SC('.')) type = TFLOAT;
+			if(isexponent(CUR_CHAR)) {
+				if(type != TFLOAT) Error(_SC("invalid numeric format"));
+				type = TSCIENTIFIC;
+				APPEND_CHAR(CUR_CHAR);
+				NEXT();
+				if(CUR_CHAR == '+' || CUR_CHAR == '-'){
+					APPEND_CHAR(CUR_CHAR);
+					NEXT();
+				}
+				if(!scisdigit(CUR_CHAR)) Error(_SC("exponent expected"));
+			}
+			
+			APPEND_CHAR(CUR_CHAR);
+			NEXT();
+		}
+	}
+	TERMINATE_BUFFER();
+	switch(type) {
+	case TSCIENTIFIC:
+	case TFLOAT:
+		_fvalue = (SQFloat)scstrtod(&_longstr[0],&sTemp);
+		return TK_FLOAT;
+	case TINT:
+		LexInteger(&_longstr[0],(SQUnsignedInteger *)&_nvalue);
+		return TK_INTEGER;
+	case THEX:
+		LexHexadecimal(&_longstr[0],(SQUnsignedInteger *)&_nvalue);
+		return TK_INTEGER;
+	}
+	return 0;
+}
+
+SQInteger SQLexer::ReadID()
+{
+	SQInteger res;
+	INIT_TEMP_STRING();
+	do {
+		APPEND_CHAR(CUR_CHAR);
+		NEXT();
+	} while(scisalnum(CUR_CHAR) || CUR_CHAR == _SC('_'));
+	TERMINATE_BUFFER();
+	res = GetIDType(&_longstr[0]);
+	if(res == TK_IDENTIFIER || res == TK_CONSTRUCTOR) {
+		_svalue = &_longstr[0];
+	}
+	return res;
+}
diff -rupwN ../dnl3/SqPlus/_squirrel/sqlexer.h SqPlus/_squirrel/sqlexer.h
--- ../dnl3/SqPlus/_squirrel/sqlexer.h	1969-12-31 19:00:00.000000000 -0500
+++ SqPlus/_squirrel/sqlexer.h	2006-03-19 14:32:58.000000000 -0500
@@ -0,0 +1,45 @@
+/*	see copyright notice in squirrel.h */
+#ifndef _SQLEXER_H_
+#define _SQLEXER_H_
+
+#ifdef _UNICODE
+typedef SQChar LexChar;
+#else
+typedef	unsigned char LexChar;
+#endif
+
+struct SQLexer
+{
+	SQLexer();
+	~SQLexer();
+	void Init(SQSharedState *ss,SQLEXREADFUNC rg,SQUserPointer up,CompilerErrorFunc efunc,void *ed);
+	void Error(const SQChar *err);
+	SQInteger Lex();
+	const SQChar *Tok2Str(SQInteger tok);
+private:
+	SQInteger GetIDType(SQChar *s);
+	SQInteger ReadString(SQInteger ndelim,bool verbatim);
+	SQInteger ReadNumber();
+	void LexBlockComment();
+	SQInteger ReadID();
+	void Next();
+	SQInteger _curtoken;
+	SQTable *_keywords;
+public:
+	SQInteger _prevtoken;
+	SQInteger _currentline;
+	SQInteger _lasttokenline;
+	SQInteger _currentcolumn;
+	const SQChar *_svalue;
+	SQInteger _nvalue;
+	SQFloat _fvalue;
+	SQLEXREADFUNC _readf;
+	SQUserPointer _up;
+	LexChar _currdata;
+	SQSharedState *_sharedstate;
+	sqvector<SQChar> _longstr;
+	CompilerErrorFunc _errfunc;
+	void *_errtarget;
+};
+
+#endif
diff -rupwN ../dnl3/SqPlus/_squirrel/sqmem.cpp SqPlus/_squirrel/sqmem.cpp
--- ../dnl3/SqPlus/_squirrel/sqmem.cpp	1969-12-31 19:00:00.000000000 -0500
+++ SqPlus/_squirrel/sqmem.cpp	2005-09-25 17:56:20.000000000 -0400
@@ -0,0 +1,9 @@
+/*
+	see copyright notice in squirrel.h
+*/
+#include "sqpcheader.h"
+void *sq_vm_malloc(SQUnsignedInteger size){	return malloc(size); }
+
+void *sq_vm_realloc(void *p, SQUnsignedInteger oldsize, SQUnsignedInteger size){ return realloc(p, size); }
+
+void sq_vm_free(void *p, SQUnsignedInteger size){	free(p); }
diff -rupwN ../dnl3/SqPlus/_squirrel/sqobject.cpp SqPlus/_squirrel/sqobject.cpp
--- ../dnl3/SqPlus/_squirrel/sqobject.cpp	1969-12-31 19:00:00.000000000 -0500
+++ SqPlus/_squirrel/sqobject.cpp	2006-03-19 14:32:58.000000000 -0500
@@ -0,0 +1,515 @@
+/*
+	see copyright notice in squirrel.h
+*/
+#include "sqpcheader.h"
+#include "sqvm.h"
+#include "sqstring.h"
+#include "sqarray.h"
+#include "sqtable.h"
+#include "squserdata.h"
+#include "sqfuncproto.h"
+#include "sqclass.h"
+#include "sqclosure.h"
+
+SQString *SQString::Create(SQSharedState *ss,const SQChar *s,SQInteger len)
+{
+	SQString *str=ADD_STRING(ss,s,len);
+	str->_sharedstate=ss;
+	return str;
+}
+
+void SQString::Release()
+{
+	REMOVE_STRING(_sharedstate,this);
+}
+
+SQInteger SQString::Next(const SQObjectPtr &refpos, SQObjectPtr &outkey, SQObjectPtr &outval)
+{
+	SQInteger idx = (SQInteger)TranslateIndex(refpos);
+	while(idx < _len){
+		outkey = (SQInteger)idx;
+		outval = SQInteger(_val[idx]);
+		//return idx for the next iteration
+		return ++idx;
+	}
+	//nothing to iterate anymore
+	return -1;
+}
+
+SQUnsignedInteger TranslateIndex(const SQObjectPtr &idx)
+{
+	switch(type(idx)){
+		case OT_NULL:
+			return 0;
+		case OT_INTEGER:
+			return (SQUnsignedInteger)_integer(idx);
+		default: assert(0); break;
+	}
+	return 0;
+}
+
+SQWeakRef *SQRefCounted::GetWeakRef(SQObjectType type)
+{
+	if(!_weakref) {
+		sq_new(_weakref,SQWeakRef);
+		_weakref->_obj._type = type;
+		_weakref->_obj._unVal.pRefCounted = this;
+	}
+	return _weakref;
+}
+
+SQRefCounted::~SQRefCounted()
+{
+	if(_weakref) {
+		_weakref->_obj._type = OT_NULL;
+		_weakref->_obj._unVal.pRefCounted = NULL;
+	}
+}
+
+void SQWeakRef::Release() { 
+	if(ISREFCOUNTED(_obj._type)) { 
+		_obj._unVal.pRefCounted->_weakref = NULL;
+	} 
+	sq_delete(this,SQWeakRef);
+}
+
+bool SQDelegable::GetMetaMethod(SQVM *v,SQMetaMethod mm,SQObjectPtr &res) {
+	if(_delegate) {
+		return _delegate->Get((*_ss(v)->_metamethods)[mm],res);
+	}
+	return false;
+}
+
+bool SQDelegable::SetDelegate(SQTable *mt)
+{
+	SQTable *temp = mt;
+	while (temp) {
+		if (temp->_delegate == this) return false; //cycle detected
+		temp = temp->_delegate;
+	}
+	if (mt)	__ObjAddRef(mt);
+	__ObjRelease(_delegate);
+	_delegate = mt;
+	return true;
+}
+
+bool SQGenerator::Yield(SQVM *v)
+{
+	if(_state==eSuspended) { v->Raise_Error(_SC("internal vm error, yielding dead generator"));  return false;}
+	if(_state==eDead) { v->Raise_Error(_SC("internal vm error, yielding a dead generator")); return false; }
+	SQInteger size = v->_top-v->_stackbase;
+	_ci=*v->ci;
+	_stack.resize(size);
+	for(SQInteger n =0; n<size; n++) {
+		_stack._vals[n] = v->_stack[v->_stackbase+n];
+		v->_stack[v->_stackbase+n] = _null_;
+	}
+	SQInteger nvargs = v->ci->_vargs.size;
+	SQInteger vargsbase = v->ci->_vargs.base;
+	for(SQInteger j = nvargs - 1; j >= 0; j--) {
+		_vargsstack.push_back(v->_vargsstack[vargsbase+j]);
+	}
+	_ci._generator=_null_;
+	for(SQInteger i=0;i<_ci._etraps;i++) {
+		_etraps.push_back(v->_etraps.top());
+		v->_etraps.pop_back();
+	}
+	_state=eSuspended;
+	return true;
+}
+
+bool SQGenerator::Resume(SQVM *v,SQInteger target)
+{
+	SQInteger size=_stack.size();
+	if(_state==eDead){ v->Raise_Error(_SC("resuming dead generator")); return false; }
+	if(_state==eRunning){ v->Raise_Error(_SC("resuming active generator")); return false; }
+	SQInteger prevtop=v->_top-v->_stackbase;
+	PUSH_CALLINFO(v,_ci);
+	SQInteger oldstackbase=v->_stackbase;
+	v->_stackbase=v->_top;
+	v->ci->_target=target;
+	v->ci->_generator=SQObjectPtr(this);
+	v->ci->_vargs.size = _vargsstack.size();
+	
+	for(SQInteger i=0;i<_ci._etraps;i++) {
+		v->_etraps.push_back(_etraps.top());
+		_etraps.pop_back();
+	}
+	for(SQInteger n =0; n<size; n++) {
+		v->_stack[v->_stackbase+n] = _stack._vals[n];
+		_stack._vals[0] = _null_;
+	}
+	while(_vargsstack.size()) {
+		v->_vargsstack.push_back(_vargsstack.back());
+		_vargsstack.pop_back();
+	}
+	v->ci->_vargs.base = v->_vargsstack.size() - v->ci->_vargs.size;
+	v->_top=v->_stackbase+size;
+	v->ci->_prevtop=prevtop;
+	v->ci->_prevstkbase=v->_stackbase-oldstackbase;
+	_state=eRunning;
+	return true;
+}
+
+void SQArray::Extend(const SQArray *a){
+	SQInteger xlen;
+	if((xlen=a->Size()))
+		for(SQInteger i=0;i<xlen;i++)
+			Append(a->_values[i]);
+}
+
+const SQChar* SQFunctionProto::GetLocal(SQVM *vm,SQUnsignedInteger stackbase,SQUnsignedInteger nseq,SQUnsignedInteger nop)
+{
+	SQUnsignedInteger nvars=_localvarinfos.size();
+	const SQChar *res=NULL; 
+	if(nvars>=nseq){
+ 		for(SQUnsignedInteger i=0;i<nvars;i++){
+			if(_localvarinfos[i]._start_op<=nop && _localvarinfos[i]._end_op>=nop)
+			{
+				if(nseq==0){
+					vm->Push(vm->_stack[stackbase+_localvarinfos[i]._pos]);
+					res=_stringval(_localvarinfos[i]._name);
+					break;
+				}
+				nseq--;
+			}
+		}
+	}
+	return res;
+}
+
+SQInteger SQFunctionProto::GetLine(SQInstruction *curr)
+{
+	SQInteger op = (SQInteger)(curr-_instructions._vals);
+	SQInteger line=_lineinfos[0]._line;
+	for(SQUnsignedInteger i=1;i<_lineinfos.size();i++){
+		if(_lineinfos[i]._op>=op)
+			return line;
+		line=_lineinfos[i]._line;
+	}
+	return line;
+}
+
+//#define _ERROR_TRAP() error_trap:
+#define _CHECK_IO(exp)  { if(!exp)return false; }
+bool SafeWrite(HSQUIRRELVM v,SQWRITEFUNC write,SQUserPointer up,SQUserPointer dest,SQInteger size)
+{
+	if(write(up,dest,size) != size) {
+		v->Raise_Error(_SC("io error (write function failure)"));
+		return false;
+	}
+	return true;
+}
+
+bool SafeRead(HSQUIRRELVM v,SQWRITEFUNC read,SQUserPointer up,SQUserPointer dest,SQInteger size)
+{
+	if(size && read(up,dest,size) != size) {
+		v->Raise_Error(_SC("io error, read function failure, the origin stream could be corrupted/trucated"));
+		return false;
+	}
+	return true;
+}
+
+bool WriteTag(HSQUIRRELVM v,SQWRITEFUNC write,SQUserPointer up,SQInteger tag)
+{
+	return SafeWrite(v,write,up,&tag,sizeof(tag));
+}
+
+bool CheckTag(HSQUIRRELVM v,SQWRITEFUNC read,SQUserPointer up,SQInteger tag)
+{
+	SQInteger t;
+	_CHECK_IO(SafeRead(v,read,up,&t,sizeof(t)));
+	if(t != tag){
+		v->Raise_Error(_SC("invalid or corrupted closure stream"));
+		return false;
+	}
+	return true;
+}
+
+bool WriteObject(HSQUIRRELVM v,SQUserPointer up,SQWRITEFUNC write,SQObjectPtr &o)
+{
+	_CHECK_IO(SafeWrite(v,write,up,&type(o),sizeof(SQObjectType)));
+	switch(type(o)){
+	case OT_STRING:
+		_CHECK_IO(SafeWrite(v,write,up,&_string(o)->_len,sizeof(SQInteger)));
+		_CHECK_IO(SafeWrite(v,write,up,_stringval(o),rsl(_string(o)->_len)));
+		break;
+	case OT_INTEGER:
+		_CHECK_IO(SafeWrite(v,write,up,&_integer(o),sizeof(SQInteger)));break;
+	case OT_FLOAT:
+		_CHECK_IO(SafeWrite(v,write,up,&_float(o),sizeof(SQFloat)));break;
+	case OT_NULL:
+		break;
+	default:
+		v->Raise_Error(_SC("cannot serialize a %s"),GetTypeName(o));
+		return false;
+	}
+	return true;
+}
+
+bool ReadObject(HSQUIRRELVM v,SQUserPointer up,SQREADFUNC read,SQObjectPtr &o)
+{
+	SQObjectType t;
+	_CHECK_IO(SafeRead(v,read,up,&t,sizeof(SQObjectType)));
+	switch(t){
+	case OT_STRING:{
+		SQInteger len;
+		_CHECK_IO(SafeRead(v,read,up,&len,sizeof(SQInteger)));
+		_CHECK_IO(SafeRead(v,read,up,_ss(v)->GetScratchPad(rsl(len)),rsl(len)));
+		o=SQString::Create(_ss(v),_ss(v)->GetScratchPad(-1),len);
+				   }
+		break;
+	case OT_INTEGER:{
+		SQInteger i;
+		_CHECK_IO(SafeRead(v,read,up,&i,sizeof(SQInteger))); o = i; break;
+					}
+	case OT_FLOAT:{
+		SQFloat f;
+		_CHECK_IO(SafeRead(v,read,up,&f,sizeof(SQFloat))); o = f; break;
+				  }
+	case OT_NULL:
+		o=_null_;
+		break;
+	default:
+		v->Raise_Error(_SC("cannot serialize a %s"),IdType2Name(t));
+		return false;
+	}
+	return true;
+}
+
+bool SQClosure::Save(SQVM *v,SQUserPointer up,SQWRITEFUNC write)
+{
+	_CHECK_IO(WriteTag(v,write,up,SQ_CLOSURESTREAM_HEAD));
+	_CHECK_IO(WriteTag(v,write,up,sizeof(SQChar)));
+	_CHECK_IO(_funcproto(_function)->Save(v,up,write));
+	_CHECK_IO(WriteTag(v,write,up,SQ_CLOSURESTREAM_TAIL));
+	return true;
+}
+
+bool SQClosure::Load(SQVM *v,SQUserPointer up,SQREADFUNC read)
+{
+	_CHECK_IO(CheckTag(v,read,up,SQ_CLOSURESTREAM_HEAD));
+	_CHECK_IO(CheckTag(v,read,up,sizeof(SQChar)));
+	_CHECK_IO(_funcproto(_function)->Load(v,up,read));
+	_CHECK_IO(CheckTag(v,read,up,SQ_CLOSURESTREAM_TAIL));
+	return true;
+}
+
+bool SQFunctionProto::Save(SQVM *v,SQUserPointer up,SQWRITEFUNC write)
+{
+	SQInteger i,nsize=_literals.size();
+	_CHECK_IO(WriteTag(v,write,up,SQ_CLOSURESTREAM_PART));
+	_CHECK_IO(WriteObject(v,up,write,_sourcename));
+	_CHECK_IO(WriteObject(v,up,write,_name));
+	_CHECK_IO(WriteTag(v,write,up,SQ_CLOSURESTREAM_PART));
+	_CHECK_IO(SafeWrite(v,write,up,&nsize,sizeof(nsize)));
+	for(i=0;i<nsize;i++){
+		_CHECK_IO(WriteObject(v,up,write,_literals[i]));
+	}
+	_CHECK_IO(WriteTag(v,write,up,SQ_CLOSURESTREAM_PART));
+	nsize=_parameters.size();
+	_CHECK_IO(SafeWrite(v,write,up,&nsize,sizeof(nsize)));
+	for(i=0;i<nsize;i++){
+		_CHECK_IO(WriteObject(v,up,write,_parameters[i]));
+	}
+	_CHECK_IO(WriteTag(v,write,up,SQ_CLOSURESTREAM_PART));
+	nsize=_outervalues.size();
+	_CHECK_IO(SafeWrite(v,write,up,&nsize,sizeof(nsize)));
+	for(i=0;i<nsize;i++){
+		_CHECK_IO(SafeWrite(v,write,up,&_outervalues[i]._type,sizeof(SQUnsignedInteger)));
+		_CHECK_IO(WriteObject(v,up,write,_outervalues[i]._src));
+		_CHECK_IO(WriteObject(v,up,write,_outervalues[i]._name));
+	}
+	_CHECK_IO(WriteTag(v,write,up,SQ_CLOSURESTREAM_PART));
+	nsize=_localvarinfos.size();
+	_CHECK_IO(SafeWrite(v,write,up,&nsize,sizeof(nsize)));
+	for(i=0;i<nsize;i++){
+		SQLocalVarInfo &lvi=_localvarinfos[i];
+		_CHECK_IO(WriteObject(v,up,write,lvi._name));
+		_CHECK_IO(SafeWrite(v,write,up,&lvi._pos,sizeof(SQUnsignedInteger)));
+		_CHECK_IO(SafeWrite(v,write,up,&lvi._start_op,sizeof(SQUnsignedInteger)));
+		_CHECK_IO(SafeWrite(v,write,up,&lvi._end_op,sizeof(SQUnsignedInteger)));
+	}
+	_CHECK_IO(WriteTag(v,write,up,SQ_CLOSURESTREAM_PART));
+	nsize=_lineinfos.size();
+	_CHECK_IO(SafeWrite(v,write,up,&nsize,sizeof(nsize)));
+	_CHECK_IO(SafeWrite(v,write,up,&_lineinfos[0],sizeof(SQLineInfo)*nsize));
+	_CHECK_IO(WriteTag(v,write,up,SQ_CLOSURESTREAM_PART));
+	nsize=_instructions.size();
+	_CHECK_IO(SafeWrite(v,write,up,&nsize,sizeof(nsize)));
+	_CHECK_IO(SafeWrite(v,write,up,&_instructions[0],sizeof(SQInstruction)*nsize));
+	_CHECK_IO(WriteTag(v,write,up,SQ_CLOSURESTREAM_PART));
+	nsize=_functions.size();
+	_CHECK_IO(SafeWrite(v,write,up,&nsize,sizeof(nsize)));
+	for(i=0;i<nsize;i++){
+		_CHECK_IO(_funcproto(_functions[i])->Save(v,up,write));
+	}
+	_CHECK_IO(SafeWrite(v,write,up,&_stacksize,sizeof(_stacksize)));
+	_CHECK_IO(SafeWrite(v,write,up,&_bgenerator,sizeof(_bgenerator)));
+	_CHECK_IO(SafeWrite(v,write,up,&_varparams,sizeof(_varparams)));
+	return true;
+}
+
+bool SQFunctionProto::Load(SQVM *v,SQUserPointer up,SQREADFUNC read)
+{
+	SQInteger i, nsize = _literals.size();
+	SQObjectPtr o;
+	_CHECK_IO(CheckTag(v,read,up,SQ_CLOSURESTREAM_PART));
+	_CHECK_IO(ReadObject(v, up, read, _sourcename));
+	_CHECK_IO(ReadObject(v, up, read, _name));
+	_CHECK_IO(CheckTag(v,read,up,SQ_CLOSURESTREAM_PART));
+	_CHECK_IO(SafeRead(v,read,up, &nsize, sizeof(nsize)));
+	for(i = 0;i < nsize; i++){
+		_CHECK_IO(ReadObject(v, up, read, o));
+		_literals.push_back(o);
+	}
+	_CHECK_IO(CheckTag(v,read,up,SQ_CLOSURESTREAM_PART));
+	_CHECK_IO(SafeRead(v,read,up, &nsize, sizeof(nsize)));
+	for(i = 0; i < nsize; i++){
+		_CHECK_IO(ReadObject(v, up, read, o));
+		_parameters.push_back(o);
+	}
+	_CHECK_IO(CheckTag(v,read,up,SQ_CLOSURESTREAM_PART));
+	_CHECK_IO(SafeRead(v,read,up,&nsize,sizeof(nsize)));
+	for(i = 0; i < nsize; i++){
+		SQUnsignedInteger type;
+		SQObjectPtr name;
+		_CHECK_IO(SafeRead(v,read,up, &type, sizeof(SQUnsignedInteger)));
+		_CHECK_IO(ReadObject(v, up, read, o));
+		_CHECK_IO(ReadObject(v, up, read, name));
+		_outervalues.push_back(SQOuterVar(name,o, (SQOuterType)type));
+	}
+	_CHECK_IO(CheckTag(v,read,up,SQ_CLOSURESTREAM_PART));
+	_CHECK_IO(SafeRead(v,read,up,&nsize, sizeof(nsize)));
+	for(i = 0; i < nsize; i++){
+		SQLocalVarInfo lvi;
+		_CHECK_IO(ReadObject(v, up, read, lvi._name));
+		_CHECK_IO(SafeRead(v,read,up, &lvi._pos, sizeof(SQUnsignedInteger)));
+		_CHECK_IO(SafeRead(v,read,up, &lvi._start_op, sizeof(SQUnsignedInteger)));
+		_CHECK_IO(SafeRead(v,read,up, &lvi._end_op, sizeof(SQUnsignedInteger)));
+		_localvarinfos.push_back(lvi);
+	}
+	_CHECK_IO(CheckTag(v,read,up,SQ_CLOSURESTREAM_PART));
+	_CHECK_IO(SafeRead(v,read,up, &nsize,sizeof(nsize)));
+	_lineinfos.resize(nsize);
+	_CHECK_IO(SafeRead(v,read,up, &_lineinfos[0], sizeof(SQLineInfo)*nsize));
+	_CHECK_IO(CheckTag(v,read,up,SQ_CLOSURESTREAM_PART));
+	_CHECK_IO(SafeRead(v,read,up, &nsize, sizeof(nsize)));
+	_instructions.resize(nsize);
+	_CHECK_IO(SafeRead(v,read,up, &_instructions[0], sizeof(SQInstruction)*nsize));
+	_CHECK_IO(CheckTag(v,read,up,SQ_CLOSURESTREAM_PART));
+	_CHECK_IO(SafeRead(v,read,up, &nsize, sizeof(nsize)));
+	for(i = 0; i < nsize; i++){
+		o = SQFunctionProto::Create();
+		_CHECK_IO(_funcproto(o)->Load(v, up, read));
+		_functions.push_back(o);
+	}
+	_CHECK_IO(SafeRead(v,read,up, &_stacksize, sizeof(_stacksize)));
+	_CHECK_IO(SafeRead(v,read,up, &_bgenerator, sizeof(_bgenerator)));
+	_CHECK_IO(SafeRead(v,read,up, &_varparams, sizeof(_varparams)));
+	return true;
+}
+
+#ifndef NO_GARBAGE_COLLECTOR
+
+#define START_MARK() 	if(!(_uiRef&MARK_FLAG)){ \
+		_uiRef|=MARK_FLAG;
+
+#define END_MARK() RemoveFromChain(&_sharedstate->_gc_chain, this); \
+		AddToChain(chain, this); }
+
+void SQVM::Mark(SQCollectable **chain)
+{
+	START_MARK()
+		SQSharedState::MarkObject(_lasterror,chain);
+		SQSharedState::MarkObject(_errorhandler,chain);
+		SQSharedState::MarkObject(_debughook,chain);
+		SQSharedState::MarkObject(_roottable, chain);
+		SQSharedState::MarkObject(temp_reg, chain);
+		for(SQUnsignedInteger i = 0; i < _stack.size(); i++) SQSharedState::MarkObject(_stack[i], chain);
+		for(SQUnsignedInteger j = 0; j < _vargsstack.size(); j++) SQSharedState::MarkObject(_vargsstack[j], chain);
+	END_MARK()
+}
+
+void SQArray::Mark(SQCollectable **chain)
+{
+	START_MARK()
+		SQInteger len = _values.size();
+		for(SQInteger i = 0;i < len; i++) SQSharedState::MarkObject(_values[i], chain);
+	END_MARK()
+}
+void SQTable::Mark(SQCollectable **chain)
+{
+	START_MARK()
+		if(_delegate) _delegate->Mark(chain);
+		SQInteger len = _numofnodes;
+		for(SQInteger i = 0; i < len; i++){
+			SQSharedState::MarkObject(_nodes[i].key, chain);
+			SQSharedState::MarkObject(_nodes[i].val, chain);
+		}
+	END_MARK()
+}
+
+void SQClass::Mark(SQCollectable **chain)
+{
+	START_MARK()
+		_members->Mark(chain);
+		if(_base) _base->Mark(chain);
+		SQSharedState::MarkObject(_attributes, chain);
+		for(SQUnsignedInteger i =0; i< _defaultvalues.size(); i++) {
+			SQSharedState::MarkObject(_defaultvalues[i].val, chain);
+			SQSharedState::MarkObject(_defaultvalues[i].attrs, chain);
+		}
+		for(SQUnsignedInteger j =0; j< _methods.size(); j++) {
+			SQSharedState::MarkObject(_methods[j].val, chain);
+			SQSharedState::MarkObject(_methods[j].attrs, chain);
+		}
+		for(SQUnsignedInteger k =0; k< _metamethods.size(); k++) {
+			SQSharedState::MarkObject(_metamethods[k], chain);
+		}
+	END_MARK()
+}
+
+void SQInstance::Mark(SQCollectable **chain)
+{
+	START_MARK()
+		_class->Mark(chain);
+		for(SQUnsignedInteger i =0; i< _nvalues; i++) {
+			SQSharedState::MarkObject(_values[i], chain);
+		}
+	END_MARK()
+}
+
+void SQGenerator::Mark(SQCollectable **chain)
+{
+	START_MARK()
+		for(SQUnsignedInteger i = 0; i < _stack.size(); i++) SQSharedState::MarkObject(_stack[i], chain);
+		for(SQUnsignedInteger j = 0; j < _vargsstack.size(); j++) SQSharedState::MarkObject(_vargsstack[j], chain);
+		SQSharedState::MarkObject(_closure, chain);
+	END_MARK()
+}
+
+void SQClosure::Mark(SQCollectable **chain)
+{
+	START_MARK()
+		for(SQUnsignedInteger i = 0; i < _outervalues.size(); i++) SQSharedState::MarkObject(_outervalues[i], chain);
+	END_MARK()
+}
+
+void SQNativeClosure::Mark(SQCollectable **chain)
+{
+	START_MARK()
+		for(SQUnsignedInteger i = 0; i < _outervalues.size(); i++) SQSharedState::MarkObject(_outervalues[i], chain);
+	END_MARK()
+}
+
+void SQUserData::Mark(SQCollectable **chain){
+	START_MARK()
+		if(_delegate) _delegate->Mark(chain);
+	END_MARK()
+}
+
+void SQCollectable::UnMark() { _uiRef&=~MARK_FLAG; }
+
+#endif
+
diff -rupwN ../dnl3/SqPlus/_squirrel/sqobject.h SqPlus/_squirrel/sqobject.h
--- ../dnl3/SqPlus/_squirrel/sqobject.h	1969-12-31 19:00:00.000000000 -0500
+++ SqPlus/_squirrel/sqobject.h	2006-03-19 14:32:58.000000000 -0500
@@ -0,0 +1,331 @@
+/*	see copyright notice in squirrel.h */
+#ifndef _SQOBJECT_H_
+#define _SQOBJECT_H_
+
+#include "squtils.h"
+
+#define SQ_CLOSURESTREAM_HEAD (('S'<<24)|('Q'<<16)|('I'<<8)|('R'))
+#define SQ_CLOSURESTREAM_PART (('P'<<24)|('A'<<16)|('R'<<8)|('T'))
+#define SQ_CLOSURESTREAM_TAIL (('T'<<24)|('A'<<16)|('I'<<8)|('L'))
+
+struct SQSharedState;
+
+enum SQMetaMethod{
+	MT_ADD=0,
+	MT_SUB=1,
+	MT_MUL=2,
+	MT_DIV=3,
+	MT_UNM=4,
+	MT_MODULO=5,
+	MT_SET=6,
+	MT_GET=7,
+	MT_TYPEOF=8,
+	MT_NEXTI=9,
+	MT_CMP=10,
+	MT_CALL=11,
+	MT_CLONED=12,
+	MT_NEWSLOT=13,
+	MT_DELSLOT=14,
+	MT_TOSTRING=15,
+	MT_NEWMEMBER=16,
+	MT_INHERITED=17,
+	MT_LAST = 18
+};
+
+#define MM_ADD		_SC("_add")
+#define MM_SUB		_SC("_sub")
+#define MM_MUL		_SC("_mul")
+#define MM_DIV		_SC("_div")
+#define MM_UNM		_SC("_unm")
+#define MM_MODULO	_SC("_modulo")
+#define MM_SET		_SC("_set")
+#define MM_GET		_SC("_get")
+#define MM_TYPEOF	_SC("_typeof")
+#define MM_NEXTI	_SC("_nexti")
+#define MM_CMP		_SC("_cmp")
+#define MM_CALL		_SC("_call")
+#define MM_CLONED	_SC("_cloned")
+#define MM_NEWSLOT	_SC("_newslot")
+#define MM_DELSLOT	_SC("_delslot")
+#define MM_TOSTRING	_SC("_tostring")
+#define MM_NEWMEMBER _SC("_newmember")
+#define MM_INHERITED _SC("_inherited")
+
+#define MINPOWER2 4
+
+struct SQRefCounted
+{
+	SQRefCounted() { _uiRef = 0; _weakref = NULL; }
+	virtual ~SQRefCounted();
+	SQWeakRef *GetWeakRef(SQObjectType type);
+	SQUnsignedInteger _uiRef;
+	struct SQWeakRef *_weakref;
+	virtual void Release()=0;
+};
+
+struct SQWeakRef : SQRefCounted
+{
+	void Release();
+	SQObject _obj;
+};
+
+#define _realval(o) (type((o)) != OT_WEAKREF?(SQObject)o:_weakref(o)->_obj)
+
+struct SQObjectPtr;
+
+#define __AddRef(type,unval) if(ISREFCOUNTED(type))	\
+		{ \
+			unval.pRefCounted->_uiRef++; \
+		}  
+
+#define __Release(type,unval) if(ISREFCOUNTED(type) && ((--unval.pRefCounted->_uiRef)<=0))	\
+		{	\
+			unval.pRefCounted->Release();	\
+		}
+
+#define __ObjRelease(obj) { \
+	if((obj)) {	\
+		(obj)->_uiRef--; \
+		if((obj)->_uiRef == 0) \
+			(obj)->Release(); \
+		(obj) = NULL;	\
+	} \
+}
+
+#define __ObjAddRef(obj) { \
+	(obj)->_uiRef++; \
+}
+
+#define type(obj) ((obj)._type)
+#define is_delegable(t) (type(t)&SQOBJECT_DELEGABLE)
+#define raw_type(obj) _RAW_TYPE((obj)._type)
+
+#define _integer(obj) ((obj)._unVal.nInteger)
+#define _float(obj) ((obj)._unVal.fFloat)
+#define _string(obj) ((obj)._unVal.pString)
+#define _table(obj) ((obj)._unVal.pTable)
+#define _array(obj) ((obj)._unVal.pArray)
+#define _closure(obj) ((obj)._unVal.pClosure)
+#define _generator(obj) ((obj)._unVal.pGenerator)
+#define _nativeclosure(obj) ((obj)._unVal.pNativeClosure)
+#define _userdata(obj) ((obj)._unVal.pUserData)
+#define _userpointer(obj) ((obj)._unVal.pUserPointer)
+#define _thread(obj) ((obj)._unVal.pThread)
+#define _funcproto(obj) ((obj)._unVal.pFunctionProto)
+#define _class(obj) ((obj)._unVal.pClass)
+#define _instance(obj) ((obj)._unVal.pInstance)
+#define _delegable(obj) ((SQDelegable *)(obj)._unVal.pDelegable)
+#define _weakref(obj) ((obj)._unVal.pWeakRef)
+#define _refcounted(obj) ((obj)._unVal.pRefCounted)
+#define _rawval(obj) ((obj)._unVal.pRefCounted)
+
+#define _stringval(obj) (obj)._unVal.pString->_val
+#define _userdataval(obj) (obj)._unVal.pUserData->_val
+
+#define tofloat(num) ((type(num)==OT_INTEGER)?(SQFloat)_integer(num):_float(num))
+#define tointeger(num) ((type(num)==OT_FLOAT)?(SQInteger)_float(num):_integer(num))
+/////////////////////////////////////////////////////////////////////////////////////
+/////////////////////////////////////////////////////////////////////////////////////
+struct SQObjectPtr : public SQObject
+{
+	SQObjectPtr()
+	{
+		_type=OT_NULL;
+		_unVal.pUserPointer=NULL;
+	}
+	SQObjectPtr(const SQObjectPtr &o)
+	{
+		_type=o._type;
+		_unVal=o._unVal;
+		__AddRef(_type,_unVal);
+	}
+	SQObjectPtr(const SQObject &o)
+	{
+		_type=o._type;
+		_unVal=o._unVal;
+		__AddRef(_type,_unVal);
+	}
+	SQObjectPtr(SQTable *pTable)
+	{
+		_type=OT_TABLE;
+		_unVal.pTable=pTable;
+		assert(_unVal.pTable);
+		__AddRef(_type,_unVal);
+	}
+	SQObjectPtr(SQClass *pClass)
+	{
+		_type=OT_CLASS;
+		_unVal.pClass=pClass;
+		assert(_unVal.pClass);
+		__AddRef(_type,_unVal);
+	}
+	SQObjectPtr(SQInstance *pInstance)
+	{
+		_type=OT_INSTANCE;
+		_unVal.pInstance=pInstance;
+		assert(_unVal.pInstance);
+		__AddRef(_type,_unVal);
+	}
+	SQObjectPtr(SQArray *pArray)
+	{
+		_type=OT_ARRAY;
+		_unVal.pArray=pArray;
+		assert(_unVal.pArray);
+		__AddRef(_type,_unVal);
+	}
+	SQObjectPtr(SQClosure *pClosure)
+	{
+		_type=OT_CLOSURE;
+		_unVal.pClosure=pClosure;
+		assert(_unVal.pClosure);
+		__AddRef(_type,_unVal);
+	}
+	SQObjectPtr(SQGenerator *pGenerator)
+	{
+		_type=OT_GENERATOR;
+		_unVal.pGenerator=pGenerator;
+		assert(_unVal.pGenerator);
+		__AddRef(_type,_unVal);
+	}
+	SQObjectPtr(SQNativeClosure *pNativeClosure)
+	{
+		_type=OT_NATIVECLOSURE;
+		_unVal.pNativeClosure=pNativeClosure;
+		assert(_unVal.pNativeClosure);
+		__AddRef(_type,_unVal);
+	}
+	SQObjectPtr(SQString *pString)
+	{
+		_type=OT_STRING;
+		_unVal.pString=pString;
+		assert(_unVal.pString);
+		__AddRef(_type,_unVal);
+	}
+	SQObjectPtr(SQUserData *pUserData)
+	{
+		_type=OT_USERDATA;
+		_unVal.pUserData=pUserData;
+		assert(_unVal.pUserData);
+		__AddRef(_type,_unVal);
+	}
+	SQObjectPtr(SQVM *pThread)
+	{
+		_type=OT_THREAD;
+		_unVal.pThread=pThread;
+		assert(_unVal.pThread);
+		__AddRef(_type,_unVal);
+	}
+	SQObjectPtr(SQWeakRef *pWeakRef)
+	{
+		_type=OT_WEAKREF;
+		_unVal.pWeakRef=pWeakRef;
+		assert(_unVal.pWeakRef);
+		__AddRef(_type,_unVal);
+	}
+	SQObjectPtr(SQFunctionProto *pFunctionProto)
+	{
+		_type=OT_FUNCPROTO;
+		_unVal.pFunctionProto=pFunctionProto;
+		assert(_unVal.pFunctionProto);
+		__AddRef(_type,_unVal);
+	}
+	SQObjectPtr(SQInteger nInteger)
+	{
+		_unVal.pUserPointer=NULL;
+		_type=OT_INTEGER;
+		_unVal.nInteger=nInteger;
+	}
+	SQObjectPtr(SQFloat fFloat)
+	{
+		_unVal.pUserPointer=NULL;
+		_type=OT_FLOAT;
+		_unVal.fFloat=fFloat;
+	}
+	SQObjectPtr(bool bBool)
+	{
+		_unVal.pUserPointer=NULL;
+		_type = OT_BOOL;
+		_unVal.nInteger = bBool?1:0;
+	}
+	SQObjectPtr(SQUserPointer pUserPointer)
+	{
+		_type=OT_USERPOINTER;
+		_unVal.pUserPointer=pUserPointer;
+	}
+	~SQObjectPtr()
+	{
+		__Release(_type,_unVal);
+	}
+	inline void Null()
+	{
+		__Release(_type,_unVal);
+		_type=OT_NULL;
+		_unVal.pUserPointer=NULL;
+	}
+	inline SQObjectPtr& operator=(const SQObjectPtr& obj)
+	{ 
+		SQObjectType tOldType;
+		SQObjectValue unOldVal;
+		tOldType=_type;
+		unOldVal=_unVal;
+		_unVal = obj._unVal;
+		_type = obj._type;
+		__AddRef(_type,_unVal);
+		__Release(tOldType,unOldVal);
+		return *this;
+	}
+	inline SQObjectPtr& operator=(const SQObject& obj)
+	{ 
+		SQObjectType tOldType;
+		SQObjectValue unOldVal;
+		tOldType=_type;
+		unOldVal=_unVal;
+		_unVal = obj._unVal;
+		_type = obj._type;
+		__AddRef(_type,_unVal);
+		__Release(tOldType,unOldVal);
+		return *this;
+	}
+	private:
+		SQObjectPtr(const SQChar *){} //safety
+};
+/////////////////////////////////////////////////////////////////////////////////////
+#ifndef NO_GARBAGE_COLLECTOR
+#define MARK_FLAG 0x80000000
+struct SQCollectable : public SQRefCounted {
+	SQCollectable *_next;
+	SQCollectable *_prev;
+	SQSharedState *_sharedstate;
+	virtual void Release()=0;
+	virtual void Mark(SQCollectable **chain)=0;
+	void UnMark();
+	virtual void Finalize()=0;
+	static void AddToChain(SQCollectable **chain,SQCollectable *c);
+	static void RemoveFromChain(SQCollectable **chain,SQCollectable *c);
+};
+
+
+#define ADD_TO_CHAIN(chain,obj) AddToChain(chain,obj)
+#define REMOVE_FROM_CHAIN(chain,obj) {if(!(_uiRef&MARK_FLAG))RemoveFromChain(chain,obj);}
+#define CHAINABLE_OBJ SQCollectable
+#define INIT_CHAIN() {_next=NULL;_prev=NULL;_sharedstate=ss;}
+#else
+
+#define ADD_TO_CHAIN(chain,obj) ((void)0)
+#define REMOVE_FROM_CHAIN(chain,obj) ((void)0)
+#define CHAINABLE_OBJ SQRefCounted
+#define INIT_CHAIN() ((void)0)
+#endif
+
+struct SQDelegable : public CHAINABLE_OBJ {
+	bool SetDelegate(SQTable *m);
+	virtual bool GetMetaMethod(SQVM *v,SQMetaMethod mm,SQObjectPtr &res);
+	SQTable *_delegate;
+};
+
+SQUnsignedInteger TranslateIndex(const SQObjectPtr &idx);
+typedef sqvector<SQObjectPtr> SQObjectPtrVec;
+typedef sqvector<SQInteger> SQIntVec;
+
+
+#endif //_SQOBJECT_H_
diff -rupwN ../dnl3/SqPlus/_squirrel/sqopcodes.h SqPlus/_squirrel/sqopcodes.h
--- ../dnl3/SqPlus/_squirrel/sqopcodes.h	1969-12-31 19:00:00.000000000 -0500
+++ SqPlus/_squirrel/sqopcodes.h	2006-03-19 14:32:58.000000000 -0500
@@ -0,0 +1,113 @@
+/*	see copyright notice in squirrel.h */
+#ifndef _SQOPCODES_H_
+#define _SQOPCODES_H_
+
+#define MAX_FUNC_STACKSIZE 0xFF
+#define MAX_LITERALS ((SQInteger)0x7FFFFFFF)
+
+enum BitWiseOP {
+	BW_AND = 0,
+	BW_OR = 2,	//like ADD
+	BW_XOR = 3,
+	BW_SHIFTL = 4,
+	BW_SHIFTR = 5,
+	BW_USHIFTR = 6
+};
+
+enum CmpOP {
+	CMP_G = 0,
+	CMP_GE = 2,	//like ADD
+	CMP_L = 3,
+	CMP_LE = 4
+};
+enum SQOpcode
+{
+	_OP_LINE=				0x00,	
+	_OP_LOAD=				0x01,
+	_OP_LOADINT=			0x02,
+	_OP_DLOAD=				0x03,
+	_OP_TAILCALL=			0x04,	
+	_OP_CALL=				0x05,	
+	_OP_PREPCALL=			0x06,	
+	_OP_PREPCALLK=			0x07,	
+	_OP_GETK=				0x08,	
+	_OP_MOVE=				0x09,	
+	_OP_NEWSLOT=			0x0A,	
+	_OP_DELETE=				0x0B,	
+	_OP_SET=				0x0C,	
+	_OP_GET=				0x0D,
+	_OP_EQ=					0x0E,
+	_OP_NE=					0x0F,
+	_OP_ARITH=				0x10,
+	_OP_BITW=				0x11,
+	_OP_RETURN=				0x12,	
+	_OP_LOADNULLS=			0x13,	
+	_OP_LOADROOTTABLE=		0x14,
+	_OP_LOADBOOL=			0x15,
+	_OP_DMOVE=				0x16,	
+	_OP_JMP=				0x17,	
+	_OP_JNZ=				0x18,	
+	_OP_JZ=					0x19,	
+	_OP_LOADFREEVAR=		0x1A,	
+	_OP_VARGC=				0x1B,	
+	_OP_GETVARGV=			0x1C,	
+	_OP_NEWTABLE=			0x1D,	
+	_OP_NEWARRAY=			0x1E,	
+	_OP_APPENDARRAY=		0x1F,	
+	_OP_GETPARENT=			0x20,	
+	_OP_COMPARITH=			0x21,	
+	_OP_COMPARITHL=			0x22,	
+	_OP_INC=				0x23,	
+	_OP_INCL=				0x24,	
+	_OP_PINC=				0x25,	
+	_OP_PINCL=				0x26,	
+	_OP_CMP=				0x27,
+	_OP_EXISTS=				0x28,	
+	_OP_INSTANCEOF=			0x29,
+	_OP_AND=				0x2A,
+	_OP_OR=					0x2B,
+	_OP_NEG=				0x2C,
+	_OP_NOT=				0x2D,
+	_OP_BWNOT=				0x2E,	
+	_OP_CLOSURE=			0x2F,	
+	_OP_YIELD=				0x30,	
+	_OP_RESUME=				0x31,
+	_OP_FOREACH=			0x32,
+	_OP_DELEGATE=			0x33,
+	_OP_CLONE=				0x34,
+	_OP_TYPEOF=				0x35,
+	_OP_PUSHTRAP=			0x36,
+	_OP_POPTRAP=			0x37,
+	_OP_THROW=				0x38,
+	_OP_CLASS=				0x39,
+	_OP_NEWSLOTA=			0x3A
+};							  
+
+struct SQInstructionDesc {	  
+	const SQChar *name;		  
+};							  
+
+struct SQInstruction 
+{
+	SQInstruction(){};
+	SQInstruction(SQOpcode _op,SQInteger a0=0,SQInteger a1=0,SQInteger a2=0,SQInteger a3=0)
+	{	op = _op;
+		_arg0 = (unsigned char)a0;_arg1 = (SQInt32)a1;
+		_arg2 = (unsigned char)a2;_arg3 = (unsigned char)a3;
+	}
+    
+	
+	SQInt32 _arg1;
+	unsigned char op;
+	unsigned char _arg0;
+	unsigned char _arg2;
+	unsigned char _arg3;
+};
+
+#include "squtils.h"
+typedef sqvector<SQInstruction> SQInstructionVec;
+
+#define NEW_SLOT_ATTRIBUTES_FLAG	0x01
+#define NEW_SLOT_STATIC_FLAG		0x02
+
+#endif // _SQOPCODES_H_
diff -rupwN ../dnl3/SqPlus/_squirrel/sqpcheader.h SqPlus/_squirrel/sqpcheader.h
--- ../dnl3/SqPlus/_squirrel/sqpcheader.h	1969-12-31 19:00:00.000000000 -0500
+++ SqPlus/_squirrel/sqpcheader.h	2005-09-25 17:56:20.000000000 -0400
@@ -0,0 +1,19 @@
+/*	see copyright notice in squirrel.h */
+#ifndef _SQPCHEADER_H_
+#define _SQPCHEADER_H_
+
+#if defined(_MSC_VER) && defined(_DEBUG)
+#include <crtdbg.h>
+#endif 
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <assert.h>
+#include <new>
+//squirrel stuff
+#include <squirrel.h>
+#include "sqobject.h"
+#include "sqstate.h"
+
+#endif //_SQPCHEADER_H_
diff -rupwN ../dnl3/SqPlus/_squirrel/sqstate.cpp SqPlus/_squirrel/sqstate.cpp
--- ../dnl3/SqPlus/_squirrel/sqstate.cpp	1969-12-31 19:00:00.000000000 -0500
+++ SqPlus/_squirrel/sqstate.cpp	2006-03-19 14:32:58.000000000 -0500
@@ -0,0 +1,562 @@
+/*
+	see copyright notice in squirrel.h
+*/
+#include "sqpcheader.h"
+#include "sqopcodes.h"
+#include "sqvm.h"
+#include "sqfuncproto.h"
+#include "sqclosure.h"
+#include "sqstring.h"
+#include "sqtable.h"
+#include "sqarray.h"
+#include "squserdata.h"
+#include "sqclass.h"
+
+SQObjectPtr _null_;
+SQObjectPtr _true_(true);
+SQObjectPtr _false_(false);
+SQObjectPtr _one_((SQInteger)1);
+SQObjectPtr _minusone_((SQInteger)-1);
+
+SQSharedState::SQSharedState()
+{
+	_compilererrorhandler = NULL;
+	_printfunc = NULL;
+	_debuginfo = false;
+	_notifyallexceptions = false;
+}
+
+#define newsysstring(s) {	\
+	_systemstrings->push_back(SQString::Create(this,s));	\
+	}
+
+#define newmetamethod(s) {	\
+	_metamethods->push_back(SQString::Create(this,s));	\
+	_table(_metamethodsmap)->NewSlot(_metamethods->back(),(SQInteger)(_metamethods->size()-1)); \
+	}
+
+bool CompileTypemask(SQIntVec &res,const SQChar *typemask)
+{
+	SQInteger i = 0;
+	
+	SQInteger mask = 0;
+	while(typemask[i] != 0) {
+		
+		switch(typemask[i]){
+				case 'o': mask |= _RT_NULL; break;
+				case 'i': mask |= _RT_INTEGER; break;
+				case 'f': mask |= _RT_FLOAT; break;
+				case 'n': mask |= (_RT_FLOAT | _RT_INTEGER); break;
+				case 's': mask |= _RT_STRING; break;
+				case 't': mask |= _RT_TABLE; break;
+				case 'a': mask |= _RT_ARRAY; break;
+				case 'u': mask |= _RT_USERDATA; break;
+				case 'c': mask |= (_RT_CLOSURE | _RT_NATIVECLOSURE); break;
+				case 'b': mask |= _RT_BOOL; break;
+				case 'g': mask |= _RT_GENERATOR; break;
+				case 'p': mask |= _RT_USERPOINTER; break;
+				case 'v': mask |= _RT_THREAD; break;
+				case 'x': mask |= _RT_INSTANCE; break;
+				case 'y': mask |= _RT_CLASS; break;
+				case 'r': mask |= _RT_WEAKREF; break;
+				case '.': mask = -1; res.push_back(mask); i++; mask = 0; continue;
+				case ' ': i++; continue; //ignores spaces
+				default:
+					return false;
+		}
+		i++;
+		if(typemask[i] == '|') { 
+			i++; 
+			if(typemask[i] == 0)
+				return false;
+			continue; 
+		}
+		res.push_back(mask);
+		mask = 0;
+		
+	}
+	return true;
+}
+
+SQTable *CreateDefaultDelegate(SQSharedState *ss,SQRegFunction *funcz)
+{
+	SQInteger i=0;
+	SQTable *t=SQTable::Create(ss,0);
+	while(funcz[i].name!=0){
+		SQNativeClosure *nc = SQNativeClosure::Create(ss,funcz[i].f);
+		nc->_nparamscheck = funcz[i].nparamscheck;
+		nc->_name = SQString::Create(ss,funcz[i].name);
+		if(funcz[i].typemask && !CompileTypemask(nc->_typecheck,funcz[i].typemask))
+			return NULL;
+		t->NewSlot(SQString::Create(ss,funcz[i].name),nc);
+		i++;
+	}
+	return t;
+}
+
+void SQSharedState::Init()
+{	
+	_scratchpad=NULL;
+	_scratchpadsize=0;
+#ifndef NO_GARBAGE_COLLECTOR
+	_gc_chain=NULL;
+#endif
+	sq_new(_stringtable,StringTable);
+	sq_new(_metamethods,SQObjectPtrVec);
+	sq_new(_systemstrings,SQObjectPtrVec);
+	sq_new(_types,SQObjectPtrVec);
+	_metamethodsmap = SQTable::Create(this,MT_LAST-1);
+	//adding type strings to avoid memory trashing
+	//types names
+	newsysstring(_SC("null"));
+	newsysstring(_SC("table"));
+	newsysstring(_SC("array"));
+	newsysstring(_SC("closure"));
+	newsysstring(_SC("string"));
+	newsysstring(_SC("userdata"));
+	newsysstring(_SC("integer"));
+	newsysstring(_SC("float"));
+	newsysstring(_SC("userpointer"));
+	newsysstring(_SC("function"));
+	newsysstring(_SC("generator"));
+	newsysstring(_SC("thread"));
+	newsysstring(_SC("class"));
+	newsysstring(_SC("instance"));
+	newsysstring(_SC("bool"));
+	//meta methods
+	newmetamethod(MM_ADD);
+	newmetamethod(MM_SUB);
+	newmetamethod(MM_MUL);
+	newmetamethod(MM_DIV);
+	newmetamethod(MM_UNM);
+	newmetamethod(MM_MODULO);
+	newmetamethod(MM_SET);
+	newmetamethod(MM_GET);
+	newmetamethod(MM_TYPEOF);
+	newmetamethod(MM_NEXTI);
+	newmetamethod(MM_CMP);
+	newmetamethod(MM_CALL);
+	newmetamethod(MM_CLONED);
+	newmetamethod(MM_NEWSLOT);
+	newmetamethod(MM_DELSLOT);
+	newmetamethod(MM_TOSTRING);
+	newmetamethod(MM_NEWMEMBER);
+	newmetamethod(MM_INHERITED);
+
+	_constructoridx = SQString::Create(this,_SC("constructor"));
+	_registry = SQTable::Create(this,0);
+	_table_default_delegate=CreateDefaultDelegate(this,_table_default_delegate_funcz);
+	_array_default_delegate=CreateDefaultDelegate(this,_array_default_delegate_funcz);
+	_string_default_delegate=CreateDefaultDelegate(this,_string_default_delegate_funcz);
+	_number_default_delegate=CreateDefaultDelegate(this,_number_default_delegate_funcz);
+	_closure_default_delegate=CreateDefaultDelegate(this,_closure_default_delegate_funcz);
+	_generator_default_delegate=CreateDefaultDelegate(this,_generator_default_delegate_funcz);
+	_thread_default_delegate=CreateDefaultDelegate(this,_thread_default_delegate_funcz);
+	_class_default_delegate=CreateDefaultDelegate(this,_class_default_delegate_funcz);
+	_instance_default_delegate=CreateDefaultDelegate(this,_instance_default_delegate_funcz);
+	_weakref_default_delegate=CreateDefaultDelegate(this,_weakref_default_delegate_funcz);
+
+}
+
+SQSharedState::~SQSharedState()
+{
+	_constructoridx = _null_;
+	_refs_table.Finalize();
+	_table(_registry)->Finalize();
+	_table(_metamethodsmap)->Finalize();
+//	_refs_table = _null_;
+	_registry = _null_;
+	_metamethodsmap = _null_;
+	while(!_systemstrings->empty()){
+		_systemstrings->back()=_null_;
+		_systemstrings->pop_back();
+	}
+	_thread(_root_vm)->Finalize();
+	_root_vm = _null_;
+	_table_default_delegate=_null_;
+	_array_default_delegate=_null_;
+	_string_default_delegate=_null_;
+	_number_default_delegate=_null_;
+	_closure_default_delegate=_null_;
+	_generator_default_delegate=_null_;
+	_thread_default_delegate=_null_;
+	_class_default_delegate=_null_;
+	_instance_default_delegate=_null_;
+	_weakref_default_delegate=_null_;
+	
+#ifndef NO_GARBAGE_COLLECTOR
+	
+	
+	SQCollectable *t=_gc_chain;
+	SQCollectable *nx=NULL;
+	while(t){
+		t->_uiRef++;
+		t->Finalize();
+		nx=t->_next;
+		if(--t->_uiRef==0)
+			t->Release();
+		t=nx;
+	}
+	assert(_gc_chain==NULL); //just to proove a theory
+	while(_gc_chain){
+		_gc_chain->_uiRef++;
+		_gc_chain->Release();
+	}
+#endif
+	sq_delete(_types,SQObjectPtrVec);
+	sq_delete(_systemstrings,SQObjectPtrVec);
+	sq_delete(_metamethods,SQObjectPtrVec);
+	sq_delete(_stringtable,StringTable);
+	if(_scratchpad)SQ_FREE(_scratchpad,_scratchpadsize);
+}
+
+
+SQInteger SQSharedState::GetMetaMethodIdxByName(const SQObjectPtr &name)
+{
+	if(type(name) != OT_STRING)
+		return -1;
+	SQObjectPtr ret;
+	if(_table(_metamethodsmap)->Get(name,ret)) {
+		return _integer(ret);
+	}
+	return -1;
+}
+
+#ifndef NO_GARBAGE_COLLECTOR
+
+void SQSharedState::MarkObject(SQObjectPtr &o,SQCollectable **chain)
+{
+	switch(type(o)){
+	case OT_TABLE:_table(o)->Mark(chain);break;
+	case OT_ARRAY:_array(o)->Mark(chain);break;
+	case OT_USERDATA:_userdata(o)->Mark(chain);break;
+	case OT_CLOSURE:_closure(o)->Mark(chain);break;
+	case OT_NATIVECLOSURE:_nativeclosure(o)->Mark(chain);break;
+	case OT_GENERATOR:_generator(o)->Mark(chain);break;
+	case OT_THREAD:_thread(o)->Mark(chain);break;
+	case OT_CLASS:_class(o)->Mark(chain);break;
+	case OT_INSTANCE:_instance(o)->Mark(chain);break;
+	default: break; //shutup compiler
+	}
+}
+
+
+SQInteger SQSharedState::CollectGarbage(SQVM *vm)
+{
+	SQInteger n=0;
+	SQCollectable *tchain=NULL;
+	SQVM *vms=_thread(_root_vm);
+	
+	vms->Mark(&tchain);
+	SQInteger x = _table(_thread(_root_vm)->_roottable)->CountUsed();
+	_refs_table.Mark(&tchain);
+	MarkObject(_registry,&tchain);
+	MarkObject(_metamethodsmap,&tchain);
+	MarkObject(_table_default_delegate,&tchain);
+	MarkObject(_array_default_delegate,&tchain);
+	MarkObject(_string_default_delegate,&tchain);
+	MarkObject(_number_default_delegate,&tchain);
+	MarkObject(_generator_default_delegate,&tchain);
+	MarkObject(_thread_default_delegate,&tchain);
+	MarkObject(_closure_default_delegate,&tchain);
+	MarkObject(_class_default_delegate,&tchain);
+	MarkObject(_instance_default_delegate,&tchain);
+	MarkObject(_weakref_default_delegate,&tchain);
+	
+	SQCollectable *t=_gc_chain;
+	SQCollectable *nx=NULL;
+	while(t){
+		t->_uiRef++;
+		t->Finalize();
+		nx=t->_next;
+		if(--t->_uiRef==0)
+			t->Release();
+		t=nx;
+		n++;
+	}
+
+	t=tchain;
+	while(t){
+		t->UnMark();
+		t=t->_next;
+	}
+	_gc_chain=tchain;
+	SQInteger z = _table(_thread(_root_vm)->_roottable)->CountUsed();
+	assert(z == x);
+	return n;
+}
+#endif
+
+#ifndef NO_GARBAGE_COLLECTOR
+void SQCollectable::AddToChain(SQCollectable **chain,SQCollectable *c)
+{
+    c->_prev=NULL;
+	c->_next=*chain;
+	if(*chain) (*chain)->_prev=c;
+	*chain=c;
+}
+
+void SQCollectable::RemoveFromChain(SQCollectable **chain,SQCollectable *c)
+{
+	if(c->_prev) c->_prev->_next=c->_next;
+	else *chain=c->_next;
+	if(c->_next)
+		c->_next->_prev=c->_prev;
+	c->_next=NULL;
+	c->_prev=NULL;
+}
+#endif
+
+SQChar* SQSharedState::GetScratchPad(SQInteger size)
+{
+	SQInteger newsize;
+	if(size>0){
+		if(_scratchpadsize<size){
+			newsize=size+(size>>1);
+			_scratchpad=(SQChar *)SQ_REALLOC(_scratchpad,_scratchpadsize,newsize);
+			_scratchpadsize=newsize;
+
+		}else if(_scratchpadsize>=(size<<5)){
+			newsize=_scratchpadsize>>1;
+			_scratchpad=(SQChar *)SQ_REALLOC(_scratchpad,_scratchpadsize,newsize);
+			_scratchpadsize=newsize;
+		}
+	}
+	return _scratchpad;
+}
+
+RefTable::RefTable()
+{
+	AllocNodes(4);
+}
+
+void RefTable::Finalize()
+{
+	RefNode *nodes = (RefNode *)&_buckets[_numofslots];
+	for(SQUnsignedInteger n = 0; n < _numofslots; n++) {
+		nodes->obj = _null_;
+		nodes++;
+	}
+}
+
+RefTable::~RefTable()
+{
+	SQ_FREE(_buckets,_buffersize);
+}
+#ifndef NO_GARBAGE_COLLECTOR
+void RefTable::Mark(SQCollectable **chain)
+{
+	RefNode *nodes = (RefNode *)&_buckets[_numofslots];
+	for(SQUnsignedInteger n = 0; n < _numofslots; n++) {
+		if(type(nodes->obj) != OT_NULL) {
+			SQSharedState::MarkObject(nodes->obj,chain);
+		}
+		nodes++;
+	}
+}
+#endif
+void RefTable::AddRef(SQObject &obj)
+{
+	SQHash mainpos;
+	RefNode *prev;
+	RefNode *ref = Get(obj,mainpos,&prev,true);
+	ref->refs++;
+}
+
+SQBool RefTable::Release(SQObject &obj)
+{
+	SQHash mainpos;
+	RefNode *prev;
+	RefNode *ref = Get(obj,mainpos,&prev,false);
+	if(ref) {
+		if(--ref->refs == 0) {
+			ref->obj = _null_;
+			if(prev) {
+				prev->next = ref->next;
+			}
+			else {
+				_buckets[mainpos] = ref->next;
+			}
+			ref->next = _freelist;
+			_freelist = ref;
+			_slotused--;
+			//<<FIXME>>test for shrink?
+			return SQTrue;
+		}
+	}
+	return SQFalse;
+}
+
+void RefTable::Resize(SQUnsignedInteger size)
+{
+	RefNode **oldbuffer = _buckets;
+	RefNode *oldnodes = (RefNode *)&_buckets[_numofslots];
+	SQUnsignedInteger oldnumofslots = _numofslots;
+	SQUnsignedInteger oldbuffersize = _buffersize;
+	AllocNodes(size);
+	//rehash
+	for(SQUnsignedInteger n = 0; n < oldnumofslots; n++) {
+		if(type(oldnodes->obj) != OT_NULL) {
+			//add back;
+			assert(oldnodes->refs != 0);
+			RefNode *nn = Add(::HashObj(oldnodes->obj)&(_numofslots-1),oldnodes->obj);
+			nn->refs = oldnodes->refs; 
+			oldnodes->obj = _null_;
+		}
+		oldnodes++;
+	}
+	SQ_FREE(oldbuffer,oldbuffersize);
+}
+
+RefTable::RefNode *RefTable::Add(SQHash mainpos,SQObject &obj)
+{
+	RefNode *t = _buckets[mainpos];
+	RefNode *newnode = _freelist;
+	newnode->obj = obj;
+	_buckets[mainpos] = newnode;
+	_freelist = _freelist->next;
+	newnode->next = t;
+	assert(newnode->refs == 0);
+	_slotused++;
+	return newnode;
+}
+
+RefTable::RefNode *RefTable::Get(SQObject &obj,SQHash &mainpos,RefNode **prev,bool add)
+{
+	RefNode *ref;
+	mainpos = ::HashObj(obj)&(_numofslots-1);
+	*prev = NULL;
+	for (ref = _buckets[mainpos]; ref; ) {
+		if(_rawval(ref->obj) == _rawval(obj) && type(ref->obj) == type(obj))
+			break;
+		*prev = ref;
+		ref = ref->next;
+	}
+	if(ref == NULL && add) {
+		if(_numofslots == _slotused) {
+			Resize(_numofslots*2);
+		}
+		ref = Add(mainpos,obj);
+	}
+	return ref;
+}
+
+void RefTable::AllocNodes(SQUnsignedInteger size)
+{
+	RefNode **bucks;
+	RefNode *firstnode;
+	_buffersize = size * sizeof(RefNode *) + size * sizeof(RefNode);
+	bucks = (RefNode **)SQ_MALLOC(_buffersize);
+	firstnode = (RefNode *)&bucks[size];
+	RefNode *temp = firstnode;
+	SQUnsignedInteger n;
+	for(n = 0; n < size - 1; n++) {
+		bucks[n] = NULL;
+		temp->refs = 0;
+		new (&temp->obj) SQObjectPtr;
+		temp->next = temp+1;
+		temp++;
+	}
+	bucks[n] = NULL;
+	temp->refs = 0;
+	new (&temp->obj) SQObjectPtr;
+	temp->next = NULL;
+	_freelist = firstnode;
+	_buckets = bucks;
+	_slotused = 0;
+	_numofslots = size;
+}
+//////////////////////////////////////////////////////////////////////////
+//StringTable
+/*
+* The following code is based on Lua 4.0 (Copyright 1994-2002 Tecgraf, PUC-Rio.)
+* http://www.lua.org/copyright.html#4
+* http://www.lua.org/source/4.0.1/src_lstring.c.html
+*/
+
+StringTable::StringTable()
+{
+	AllocNodes(4);
+	_slotused = 0;
+}
+
+StringTable::~StringTable()
+{
+	SQ_FREE(_strings,sizeof(SQString*)*_numofslots);
+	_strings=NULL;
+}
+
+void StringTable::AllocNodes(SQInteger size)
+{
+	_numofslots=size;
+	//_slotused=0;
+	_strings=(SQString**)SQ_MALLOC(sizeof(SQString*)*_numofslots);
+	memset(_strings,0,sizeof(SQString*)*_numofslots);
+}
+
+SQString *StringTable::Add(const SQChar *news,SQInteger len)
+{
+	if(len<0)
+		len = (SQInteger)scstrlen(news);
+	SQHash h = ::_hashstr(news,len)&(_numofslots-1);
+	SQString *s;
+	for (s = _strings[h]; s; s = s->_next){
+		if(s->_len == len && (!memcmp(news,s->_val,rsl(len))))
+			return s; //found
+	}
+
+	SQString *t=(SQString *)SQ_MALLOC(rsl(len)+sizeof(SQString));
+	new (t) SQString;
+	memcpy(t->_val,news,rsl(len));
+	t->_val[len] = _SC('\0');
+	t->_len = len;
+	t->_hash = ::_hashstr(news,len);
+	t->_next = _strings[h];
+	_strings[h] = t;
+	_slotused++;
+	if (_slotused > _numofslots)  /* too crowded? */
+		Resize(_numofslots*2);
+	return t;
+}
+
+void StringTable::Resize(SQInteger size)
+{
+	SQInteger oldsize=_numofslots;
+	SQString **oldtable=_strings;
+	AllocNodes(size);
+	for (SQInteger i=0; i<oldsize; i++){
+		SQString *p = oldtable[i];
+		while(p){
+			SQString *next = p->_next;
+			SQHash h = p->_hash&(_numofslots-1);
+			p->_next = _strings[h];
+			_strings[h] = p;
+			p = next;
+		}
+	}
+	SQ_FREE(oldtable,oldsize*sizeof(SQString*));
+}
+
+void StringTable::Remove(SQString *bs)
+{
+	SQString *s;
+	SQString *prev=NULL;
+	SQHash h = bs->_hash&(_numofslots - 1);
+	
+	for (s = _strings[h]; s; ){
+		if(s == bs){
+			if(prev)
+				prev->_next = s->_next;
+			else
+				_strings[h] = s->_next;
+			_slotused--;
+			SQInteger slen = s->_len;
+			s->~SQString();
+			SQ_FREE(s,sizeof(SQString) + rsl(slen));
+			return;
+		}
+		prev = s;
+		s = s->_next;
+	}
+	assert(0);//if this fail something is wrong
+}
diff -rupwN ../dnl3/SqPlus/_squirrel/sqstate.h SqPlus/_squirrel/sqstate.h
--- ../dnl3/SqPlus/_squirrel/sqstate.h	1969-12-31 19:00:00.000000000 -0500
+++ SqPlus/_squirrel/sqstate.h	2006-03-19 14:32:58.000000000 -0500
@@ -0,0 +1,142 @@
+/*	see copyright notice in squirrel.h */
+#ifndef _SQSTATE_H_
+#define _SQSTATE_H_
+
+#include "squtils.h"
+#include "sqobject.h"
+struct SQString;
+struct SQTable;
+//max number of character for a printed number
+#define NUMBER_MAX_CHAR 50
+
+struct StringTable
+{
+	StringTable();
+	~StringTable();
+	SQString *Add(const SQChar *,SQInteger len);
+	void Remove(SQString *);
+private:
+	void Resize(SQInteger size);
+	void AllocNodes(SQInteger size);
+	SQString **_strings;
+	SQUnsignedInteger _numofslots;
+	SQUnsignedInteger _slotused;
+};
+
+struct RefTable {
+	struct RefNode {
+		SQObjectPtr obj;
+		SQUnsignedInteger refs;
+		struct RefNode *next;
+	};
+	RefTable();
+	~RefTable();
+	void AddRef(SQObject &obj);
+	SQBool Release(SQObject &obj);
+#ifndef NO_GARBAGE_COLLECTOR
+	void Mark(SQCollectable **chain);
+#endif
+	void Finalize();
+private:
+	RefNode *Get(SQObject &obj,SQHash &mainpos,RefNode **prev,bool add);
+	RefNode *Add(SQHash mainpos,SQObject &obj);
+	void Resize(SQUnsignedInteger size);
+	void AllocNodes(SQUnsignedInteger size);
+	SQUnsignedInteger _numofslots;
+	SQUnsignedInteger _slotused;
+	SQUnsignedInteger _buffersize;
+	RefNode *_freelist;
+	RefNode **_buckets;
+};
+
+#define ADD_STRING(ss,str,len) ss->_stringtable->Add(str,len)
+#define REMOVE_STRING(ss,bstr) ss->_stringtable->Remove(bstr)
+
+struct SQObjectPtr;
+
+struct SQSharedState
+{
+	SQSharedState();
+	~SQSharedState();
+	void Init();
+public:
+	SQChar* GetScratchPad(SQInteger size);
+	SQInteger GetMetaMethodIdxByName(const SQObjectPtr &name);
+#ifndef NO_GARBAGE_COLLECTOR
+	SQInteger CollectGarbage(SQVM *vm); 
+	static void MarkObject(SQObjectPtr &o,SQCollectable **chain);
+#endif
+	SQObjectPtrVec *_metamethods;
+	SQObjectPtr _metamethodsmap;
+	SQObjectPtrVec *_systemstrings;
+	SQObjectPtrVec *_types;
+	StringTable *_stringtable;
+	RefTable _refs_table;
+	SQObjectPtr _registry;
+	SQObjectPtr _constructoridx;
+#ifndef NO_GARBAGE_COLLECTOR
+	SQCollectable *_gc_chain;
+#endif
+	SQObjectPtr _root_vm;
+	SQObjectPtr _table_default_delegate;
+	static SQRegFunction _table_default_delegate_funcz[];
+	SQObjectPtr _array_default_delegate;
+	static SQRegFunction _array_default_delegate_funcz[];
+	SQObjectPtr _string_default_delegate;
+	static SQRegFunction _string_default_delegate_funcz[];
+	SQObjectPtr _number_default_delegate;
+	static SQRegFunction _number_default_delegate_funcz[];
+	SQObjectPtr _generator_default_delegate;
+	static SQRegFunction _generator_default_delegate_funcz[];
+	SQObjectPtr _closure_default_delegate;
+	static SQRegFunction _closure_default_delegate_funcz[];
+	SQObjectPtr _thread_default_delegate;
+	static SQRegFunction _thread_default_delegate_funcz[];
+	SQObjectPtr _class_default_delegate;
+	static SQRegFunction _class_default_delegate_funcz[];
+	SQObjectPtr _instance_default_delegate;
+	static SQRegFunction _instance_default_delegate_funcz[];
+	SQObjectPtr _weakref_default_delegate;
+	static SQRegFunction _weakref_default_delegate_funcz[];
+	
+	SQCOMPILERERROR _compilererrorhandler;
+	SQPRINTFUNCTION _printfunc;
+	bool _debuginfo;
+	bool _notifyallexceptions;
+private:
+	SQChar *_scratchpad;
+	SQInteger _scratchpadsize;
+};
+
+#define _sp(s) (_sharedstate->GetScratchPad(s))
+#define _spval (_sharedstate->GetScratchPad(-1))
+
+#define _table_ddel		_table(_sharedstate->_table_default_delegate) 
+#define _array_ddel		_table(_sharedstate->_array_default_delegate) 
+#define _string_ddel	_table(_sharedstate->_string_default_delegate) 
+#define _number_ddel	_table(_sharedstate->_number_default_delegate) 
+#define _generator_ddel	_table(_sharedstate->_generator_default_delegate) 
+#define _closure_ddel	_table(_sharedstate->_closure_default_delegate) 
+#define _thread_ddel	_table(_sharedstate->_thread_default_delegate) 
+#define _class_ddel		_table(_sharedstate->_class_default_delegate) 
+#define _instance_ddel	_table(_sharedstate->_instance_default_delegate) 
+#define _weakref_ddel	_table(_sharedstate->_weakref_default_delegate) 
+
+#ifdef SQUNICODE //rsl REAL STRING LEN
+#define rsl(l) ((l)<<1)
+#else
+#define rsl(l) (l)
+#endif
+
+extern SQObjectPtr _null_;
+extern SQObjectPtr _true_;
+extern SQObjectPtr _false_;
+extern SQObjectPtr _one_;
+extern SQObjectPtr _minusone_;
+
+bool CompileTypemask(SQIntVec &res,const SQChar *typemask);
+
+void *sq_vm_malloc(SQUnsignedInteger size);
+void *sq_vm_realloc(void *p,SQUnsignedInteger oldsize,SQUnsignedInteger size);
+void sq_vm_free(void *p,SQUnsignedInteger size);
+#endif //_SQSTATE_H_
diff -rupwN ../dnl3/SqPlus/_squirrel/sqstring.h SqPlus/_squirrel/sqstring.h
--- ../dnl3/SqPlus/_squirrel/sqstring.h	1969-12-31 19:00:00.000000000 -0500
+++ SqPlus/_squirrel/sqstring.h	2006-03-19 14:32:58.000000000 -0500
@@ -0,0 +1,31 @@
+/*	see copyright notice in squirrel.h */
+#ifndef _SQSTRING_H_
+#define _SQSTRING_H_
+
+inline SQHash _hashstr (const SQChar *s, size_t l)
+{
+		SQHash h = (SQHash)l;  /* seed */
+		size_t step = (l>>5)|1;  /* if string is too long, don't hash all its chars */
+		for (; l>=step; l-=step)
+			h = h ^ ((h<<5)+(h>>2)+(unsigned short)*(s++));
+		return h;
+}
+
+struct SQString : public SQRefCounted
+{
+	SQString(){}
+	~SQString(){}
+public:
+	static SQString *Create(SQSharedState *ss, const SQChar *, SQInteger len = -1 );
+	SQInteger Next(const SQObjectPtr &refpos, SQObjectPtr &outkey, SQObjectPtr &outval);
+	void Release();
+	SQSharedState *_sharedstate;
+	SQString *_next; //chain for the string table
+	SQInteger _len;
+	SQHash _hash;
+	SQChar _val[1];
+};
+
+
+
+#endif //_SQSTRING_H_
diff -rupwN ../dnl3/SqPlus/_squirrel/sqtable.cpp SqPlus/_squirrel/sqtable.cpp
--- ../dnl3/SqPlus/_squirrel/sqtable.cpp	1969-12-31 19:00:00.000000000 -0500
+++ SqPlus/_squirrel/sqtable.cpp	2006-03-19 14:32:58.000000000 -0500
@@ -0,0 +1,184 @@
+/*
+see copyright notice in squirrel.h
+*/
+#include "sqpcheader.h"
+#include "sqvm.h"
+#include "sqtable.h"
+#include "sqfuncproto.h"
+#include "sqclosure.h"
+
+SQTable::SQTable(SQSharedState *ss,SQInteger nInitialSize)
+{
+	SQInteger pow2size=MINPOWER2;
+	while(nInitialSize>pow2size)pow2size=pow2size<<1;
+	AllocNodes(pow2size);
+	_usednodes = 0;
+	_delegate = NULL;
+	INIT_CHAIN();
+	ADD_TO_CHAIN(&_sharedstate->_gc_chain,this);
+}
+
+void SQTable::Remove(const SQObjectPtr &key)
+{
+	
+	_HashNode *n = _Get(key, HashObj(key) & (_numofnodes - 1));
+	if (n) {
+		n->val = n->key = _null_;
+		_usednodes--;
+		Rehash(false);
+	}
+}
+
+void SQTable::AllocNodes(SQInteger nSize)
+{
+	_HashNode *nodes=(_HashNode *)SQ_MALLOC(sizeof(_HashNode)*nSize);
+	for(SQInteger i=0;i<nSize;i++){
+		new (&nodes[i]) _HashNode;
+		nodes[i].next=NULL;
+	}
+	_numofnodes=nSize;
+	_nodes=nodes;
+	_firstfree=&_nodes[_numofnodes-1];
+}
+
+void SQTable::Rehash(bool force)
+{
+	SQInteger oldsize=_numofnodes;
+	//prevent problems with the integer division
+	if(oldsize<4)oldsize=4;
+	_HashNode *nold=_nodes;
+	SQInteger nelems=CountUsed();
+	if (nelems >= oldsize-oldsize/4)  /* using more than 3/4? */
+		AllocNodes(oldsize*2);
+	else if (nelems <= oldsize/4 &&  /* less than 1/4? */
+		oldsize > MINPOWER2)
+		AllocNodes(oldsize/2);
+	else if(force)
+		AllocNodes(oldsize);
+	else
+		return;
+	_usednodes = 0;
+	for (SQInteger i=0; i<oldsize; i++) {
+		_HashNode *old = nold+i;
+		if (type(old->key) != OT_NULL)
+			NewSlot(old->key,old->val);
+	}
+	for(SQInteger k=0;k<oldsize;k++) 
+		nold[k].~_HashNode();
+	SQ_FREE(nold,oldsize*sizeof(_HashNode));
+}
+
+SQTable *SQTable::Clone()
+{
+	SQTable *nt=Create(_opt_ss(this),_numofnodes);
+	SQInteger ridx=0;
+	SQObjectPtr key,val;
+	while((ridx=Next(true,ridx,key,val))!=-1){
+		nt->NewSlot(key,val);
+	}
+	nt->SetDelegate(_delegate);
+	return nt;
+}
+
+bool SQTable::Get(const SQObjectPtr &key,SQObjectPtr &val)
+{
+	if(type(key) == OT_NULL)
+		return false;
+	_HashNode *n = _Get(key, HashObj(key) & (_numofnodes - 1));
+	if (n) {
+		val = _realval(n->val);
+		return true;
+	}
+	return false;
+}
+bool SQTable::NewSlot(const SQObjectPtr &key,const SQObjectPtr &val)
+{
+	assert(type(key) != OT_NULL);
+	SQHash h = HashObj(key) & (_numofnodes - 1);
+	_HashNode *n = _Get(key, h);
+	if (n) {
+		n->val = val;
+		return false;
+	}
+	_HashNode *mp = &_nodes[h];
+	n = mp;
+
+
+	//key not found I'll insert it
+	//main pos is not free
+
+	if(type(mp->key) != OT_NULL) {
+		n = _firstfree;  /* get a free place */
+		SQHash mph = HashObj(mp->key) & (_numofnodes - 1);
+		_HashNode *othern;  /* main position of colliding node */
+		
+		if (mp > n && (othern = &_nodes[mph]) != mp){
+			/* yes; move colliding node into free position */
+			while (othern->next != mp){
+				assert(othern->next != NULL);
+				othern = othern->next;  /* find previous */
+			}
+			othern->next = n;  /* redo the chain with `n' in place of `mp' */
+			n->key = mp->key;
+			n->val = mp->val;/* copy colliding node into free pos. (mp->next also goes) */
+			n->next = mp->next;
+			mp->key = _null_;
+			mp->val = _null_;
+			mp->next = NULL;  /* now `mp' is free */
+		}
+		else{
+			/* new node will go into free position */
+			n->next = mp->next;  /* chain new position */
+			mp->next = n;
+			mp = n;
+		}
+	}
+	mp->key = key;
+
+	for (;;) {  /* correct `firstfree' */
+		if (type(_firstfree->key) == OT_NULL && _firstfree->next == NULL) {
+			mp->val = val;
+			_usednodes++;
+			return true;  /* OK; table still has a free place */
+		}
+		else if (_firstfree == _nodes) break;  /* cannot decrement from here */
+		else (_firstfree)--;
+	}
+	Rehash(true);
+	return NewSlot(key, val);
+}
+
+SQInteger SQTable::Next(bool getweakrefs,const SQObjectPtr &refpos, SQObjectPtr &outkey, SQObjectPtr &outval)
+{
+	SQInteger idx = (SQInteger)TranslateIndex(refpos);
+	while (idx < _numofnodes) {
+		if(type(_nodes[idx].key) != OT_NULL) {
+			//first found
+			_HashNode &n = _nodes[idx];
+			outkey = n.key;
+			outval = getweakrefs?(SQObject)n.val:_realval(n.val);
+			//return idx for the next iteration
+			return ++idx;
+		}
+		++idx;
+	}
+	//nothing to iterate anymore
+	return -1;
+}
+
+
+bool SQTable::Set(const SQObjectPtr &key, const SQObjectPtr &val)
+{
+	_HashNode *n = _Get(key, HashObj(key) & (_numofnodes - 1));
+	if (n) {
+		n->val = val;
+		return true;
+	}
+	return false;
+}
+
+void SQTable::Finalize()
+{
+	for(SQInteger i = 0;i < _numofnodes; i++) { _nodes[i].key = _null_; _nodes[i].val = _null_; }
+		SetDelegate(NULL);
+}
diff -rupwN ../dnl3/SqPlus/_squirrel/sqtable.h SqPlus/_squirrel/sqtable.h
--- ../dnl3/SqPlus/_squirrel/sqtable.h	1969-12-31 19:00:00.000000000 -0500
+++ SqPlus/_squirrel/sqtable.h	2006-03-19 14:32:58.000000000 -0500
@@ -0,0 +1,89 @@
+/*	see copyright notice in squirrel.h */
+#ifndef _SQTABLE_H_
+#define _SQTABLE_H_
+/*
+* The following code is based on Lua 4.0 (Copyright 1994-2002 Tecgraf, PUC-Rio.)
+* http://www.lua.org/copyright.html#4
+* http://www.lua.org/source/4.0.1/src_ltable.c.html
+*/
+
+#include "sqstring.h"
+
+
+#define hashptr(p)  ((SQHash)(((SQInteger)p) >> 3))
+
+inline SQHash HashObj(const SQObjectPtr &key)
+{
+	switch(type(key)) {
+		case OT_STRING:		return _string(key)->_hash;
+		case OT_FLOAT:		return (SQHash)((SQInteger)_float(key));
+		case OT_BOOL: case OT_INTEGER:	return (SQHash)((SQInteger)_integer(key));
+		default:			return hashptr(key._unVal.pRefCounted);
+	}
+}
+
+struct SQTable : public SQDelegable 
+{
+private:
+	struct _HashNode
+	{
+		_HashNode() { next = NULL; }
+		SQObjectPtr val;
+		SQObjectPtr key;
+		_HashNode *next;
+	};
+	_HashNode *_firstfree;
+	_HashNode *_nodes;
+	SQInteger _numofnodes;
+	SQInteger _usednodes;
+	
+///////////////////////////
+	void AllocNodes(SQInteger nSize);
+	void Rehash(bool force);
+	SQTable(SQSharedState *ss, SQInteger nInitialSize);
+public:
+	static SQTable* Create(SQSharedState *ss,SQInteger nInitialSize)
+	{
+		SQTable *newtable = (SQTable*)SQ_MALLOC(sizeof(SQTable));
+		new (newtable) SQTable(ss, nInitialSize);
+		newtable->_delegate = NULL;
+		return newtable;
+	}
+	void Finalize();
+	SQTable *Clone();
+	~SQTable()
+	{
+		SetDelegate(NULL);
+		REMOVE_FROM_CHAIN(&_sharedstate->_gc_chain, this);
+		for (SQInteger i = 0; i < _numofnodes; i++) _nodes[i].~_HashNode();
+		SQ_FREE(_nodes, _numofnodes * sizeof(_HashNode));
+	}
+#ifndef NO_GARBAGE_COLLECTOR 
+	void Mark(SQCollectable **chain);
+#endif
+	inline _HashNode *_Get(const SQObjectPtr &key,SQHash hash)
+	{
+		_HashNode *n = &_nodes[hash];
+		do{
+			if(_rawval(n->key) == _rawval(key) && type(n->key) == type(key)){
+				return n;
+			}
+		}while((n = n->next));
+		return NULL;
+	}
+	bool Get(const SQObjectPtr &key,SQObjectPtr &val);
+	void Remove(const SQObjectPtr &key);
+	bool Set(const SQObjectPtr &key, const SQObjectPtr &val);
+	//returns true if a new slot has been created false if it was already present
+	bool NewSlot(const SQObjectPtr &key,const SQObjectPtr &val);
+	SQInteger Next(bool getweakrefs,const SQObjectPtr &refpos, SQObjectPtr &outkey, SQObjectPtr &outval);
+	
+	SQInteger CountUsed(){ return _usednodes;}
+	void Release()
+	{
+		sq_delete(this, SQTable);
+	}
+	
+};
+
+#endif //_SQTABLE_H_
diff -rupwN ../dnl3/SqPlus/_squirrel/squirrel71.vcproj SqPlus/_squirrel/squirrel71.vcproj
--- ../dnl3/SqPlus/_squirrel/squirrel71.vcproj	1969-12-31 19:00:00.000000000 -0500
+++ SqPlus/_squirrel/squirrel71.vcproj	2006-05-29 15:10:46.000000000 -0400
@@ -0,0 +1,750 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="7.10"
+	Name="squirrel"
+	ProjectGUID="{D2EB28F5-6B67-4823-8051-B564EF852CED}"
+	RootNamespace="squirrel"
+	SccProjectName=""
+	SccLocalPath="..">
+	<Platforms>
+		<Platform
+			Name="Win32"/>
+	</Platforms>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="4"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="FALSE"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\include"
+				PreprocessorDefinitions="WIN32;_DEBUG;_LIB;GARBAGE_COLLECTOR"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				UsePrecompiledHeader="0"
+				PrecompiledHeaderFile=".\Debug/squirrel.pch"
+				AssemblerListingLocation="$(IntDir)/"
+				ObjectFile="$(IntDir)/"
+				ProgramDataBaseFileName="$(IntDir)/"
+				WarningLevel="3"
+				SuppressStartupBanner="TRUE"
+				DebugInformationFormat="4"
+				CompileAs="0"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLibrarianTool"
+				OutputFile="..\lib\squirrelD.lib"
+				SuppressStartupBanner="TRUE"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="1040"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="4"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="FALSE"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="1"
+				AdditionalIncludeDirectories="..\include"
+				PreprocessorDefinitions="WIN32;NDEBUG;_LIB;GARBAGE_COLLECTOR"
+				StringPooling="TRUE"
+				RuntimeLibrary="0"
+				EnableFunctionLevelLinking="TRUE"
+				UsePrecompiledHeader="0"
+				PrecompiledHeaderFile=".\Release/squirrel.pch"
+				AssemblerListingLocation="$(IntDir)/"
+				ObjectFile="$(IntDir)/"
+				ProgramDataBaseFileName="$(IntDir)/"
+				WarningLevel="3"
+				SuppressStartupBanner="TRUE"
+				CompileAs="0"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLibrarianTool"
+				OutputFile="..\lib\squirrel.lib"
+				SuppressStartupBanner="TRUE"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG"
+				Culture="1040"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+		<Configuration
+			Name="Debug - Unicode|Win32"
+			OutputDirectory="$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="4"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="FALSE"
+			CharacterSet="1">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\include"
+				PreprocessorDefinitions="WIN32;_DEBUG;_LIB;GARBAGE_COLLECTOR"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				UsePrecompiledHeader="0"
+				PrecompiledHeaderFile=".\DebugU/squirrel.pch"
+				AssemblerListingLocation="$(IntDir)/"
+				ObjectFile="$(IntDir)/"
+				ProgramDataBaseFileName="$(IntDir)/"
+				WarningLevel="3"
+				SuppressStartupBanner="TRUE"
+				DebugInformationFormat="4"
+				CompileAs="0"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLibrarianTool"
+				OutputFile="..\lib\squirrelDU.lib"
+				SuppressStartupBanner="TRUE"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="1040"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+		<Configuration
+			Name="Release - Unicode|Win32"
+			OutputDirectory="$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="4"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="FALSE"
+			CharacterSet="1">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="1"
+				AdditionalIncludeDirectories="..\include"
+				PreprocessorDefinitions="WIN32;NDEBUG;_LIB;GARBAGE_COLLECTOR"
+				StringPooling="TRUE"
+				RuntimeLibrary="0"
+				EnableFunctionLevelLinking="TRUE"
+				UsePrecompiledHeader="0"
+				PrecompiledHeaderFile=".\Release/squirrel.pch"
+				AssemblerListingLocation="$(IntDir)/"
+				ObjectFile="$(IntDir)/"
+				ProgramDataBaseFileName="$(IntDir)/"
+				WarningLevel="3"
+				SuppressStartupBanner="TRUE"
+				CompileAs="0"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLibrarianTool"
+				OutputFile="..\lib\squirrelU.lib"
+				SuppressStartupBanner="TRUE"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG"
+				Culture="1040"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;rc;def;r;odl;idl;hpj;bat">
+			<File
+				RelativePath="sqapi.cpp">
+				<FileConfiguration
+					Name="Debug|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"
+						PrecompiledHeaderThrough="stdafx.h"/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug - Unicode|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"
+						PrecompiledHeaderThrough="stdafx.h"/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release - Unicode|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="sqbaselib.cpp">
+				<FileConfiguration
+					Name="Debug|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"
+						PrecompiledHeaderThrough="stdafx.h"/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug - Unicode|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"
+						PrecompiledHeaderThrough="stdafx.h"/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release - Unicode|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="sqclass.cpp">
+				<FileConfiguration
+					Name="Debug|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"
+						PrecompiledHeaderThrough="stdafx.h"/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug - Unicode|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"
+						PrecompiledHeaderThrough="stdafx.h"/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release - Unicode|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="sqcompiler.cpp">
+				<FileConfiguration
+					Name="Debug|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"
+						PrecompiledHeaderThrough="stdafx.h"/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug - Unicode|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"
+						PrecompiledHeaderThrough="stdafx.h"/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release - Unicode|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="sqdebug.cpp">
+				<FileConfiguration
+					Name="Debug|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"
+						PrecompiledHeaderThrough="stdafx.h"/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug - Unicode|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"
+						PrecompiledHeaderThrough="stdafx.h"/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release - Unicode|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="sqfuncstate.cpp">
+				<FileConfiguration
+					Name="Debug|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"
+						PrecompiledHeaderThrough="stdafx.h"/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug - Unicode|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"
+						PrecompiledHeaderThrough="stdafx.h"/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release - Unicode|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="sqlexer.cpp">
+				<FileConfiguration
+					Name="Debug|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"
+						PrecompiledHeaderThrough="stdafx.h"/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug - Unicode|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"
+						PrecompiledHeaderThrough="stdafx.h"/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release - Unicode|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="sqmem.cpp">
+				<FileConfiguration
+					Name="Debug|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug - Unicode|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release - Unicode|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="sqobject.cpp">
+				<FileConfiguration
+					Name="Debug|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"
+						PrecompiledHeaderThrough="stdafx.h"/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug - Unicode|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"
+						PrecompiledHeaderThrough="stdafx.h"/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release - Unicode|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="sqstate.cpp">
+				<FileConfiguration
+					Name="Debug|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"
+						PrecompiledHeaderThrough="stdafx.h"/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug - Unicode|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"
+						PrecompiledHeaderThrough="stdafx.h"/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release - Unicode|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="sqtable.cpp">
+				<FileConfiguration
+					Name="Debug|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"
+						PrecompiledHeaderThrough="stdafx.h"/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug - Unicode|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"
+						PrecompiledHeaderThrough="stdafx.h"/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release - Unicode|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="sqvm.cpp">
+				<FileConfiguration
+					Name="Debug|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"
+						PrecompiledHeaderThrough="stdafx.h"/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug - Unicode|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"
+						PrecompiledHeaderThrough="stdafx.h"/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release - Unicode|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""/>
+				</FileConfiguration>
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl">
+			<File
+				RelativePath="sqarray.h">
+			</File>
+			<File
+				RelativePath="sqclass.h">
+			</File>
+			<File
+				RelativePath="sqclosure.h">
+			</File>
+			<File
+				RelativePath="sqcompiler.h">
+			</File>
+			<File
+				RelativePath="sqfuncproto.h">
+			</File>
+			<File
+				RelativePath="sqfuncstate.h">
+			</File>
+			<File
+				RelativePath="sqlexer.h">
+			</File>
+			<File
+				RelativePath="sqobject.h">
+			</File>
+			<File
+				RelativePath="sqopcodes.h">
+			</File>
+			<File
+				RelativePath="sqpcheader.h">
+			</File>
+			<File
+				RelativePath="sqstate.h">
+			</File>
+			<File
+				RelativePath="sqstring.h">
+			</File>
+			<File
+				RelativePath="sqtable.h">
+			</File>
+			<File
+				RelativePath="squserdata.h">
+			</File>
+			<File
+				RelativePath="squtils.h">
+			</File>
+			<File
+				RelativePath="sqvm.h">
+			</File>
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -rupwN ../dnl3/SqPlus/_squirrel/squirrel.cbp SqPlus/_squirrel/squirrel.cbp
--- ../dnl3/SqPlus/_squirrel/squirrel.cbp	1969-12-31 19:00:00.000000000 -0500
+++ SqPlus/_squirrel/squirrel.cbp	2006-04-25 17:05:30.000000000 -0400
@@ -0,0 +1,324 @@
+<?xml version="1.0"?>
+<!DOCTYPE CodeBlocks_project_file>
+<CodeBlocks_project_file>
+	<FileVersion major="1" minor="1"/>
+	<Project>
+		<Option title="squirrel"/>
+		<Option makefile="Makefile"/>
+		<Option makefile_is_custom="0"/>
+		<Option default_target="-1"/>
+		<Option compiler="0"/>
+		<Build>
+			<Target title="Debug">
+				<Option output="..\lib\libsquirrelD.a"/>
+				<Option working_dir=""/>
+				<Option object_output="Debug"/>
+				<Option deps_output=".deps"/>
+				<Option type="2"/>
+				<Option compiler="0"/>
+				<Option createDefFile="1"/>
+				<Option projectResourceIncludeDirsRelation="2"/>
+				<Compiler>
+					<Add option="-DWIN32"/>
+					<Add option="-D_DEBUG"/>
+					<Add option="-D_LIB"/>
+					<Add option="-DGARBAGE_COLLECTOR"/>
+					<Add option="-D_CRT_SECURE_NO_DEPRECATE"/>
+					<Add option="-W"/>
+					<Add option="-O0"/>
+					<Add directory="..\include"/>
+				</Compiler>
+			</Target>
+			<Target title="Release">
+				<Option output="..\lib\libsquirrel.a"/>
+				<Option working_dir=""/>
+				<Option object_output="Release"/>
+				<Option deps_output=".deps"/>
+				<Option type="2"/>
+				<Option compiler="0"/>
+				<Option createDefFile="1"/>
+				<Option projectResourceIncludeDirsRelation="2"/>
+				<Compiler>
+					<Add option="-DWIN32"/>
+					<Add option="-DNDEBUG"/>
+					<Add option="-D_LIB"/>
+					<Add option="-DGARBAGE_COLLECTOR"/>
+					<Add option="-D_CRT_SECURE_NO_DEPRECATE"/>
+					<Add option="-W"/>
+					<Add option="-O2"/>
+					<Add directory="..\include"/>
+				</Compiler>
+			</Target>
+			<Target title="Debug - Unicode">
+				<Option output="..\lib\libsquirrelDU.a"/>
+				<Option working_dir=""/>
+				<Option object_output="Debug - Unicode"/>
+				<Option deps_output=".deps"/>
+				<Option type="2"/>
+				<Option compiler="0"/>
+				<Option createDefFile="1"/>
+				<Option projectResourceIncludeDirsRelation="2"/>
+				<Compiler>
+					<Add option="-DWIN32"/>
+					<Add option="-D_DEBUG"/>
+					<Add option="-D_LIB"/>
+					<Add option="-DGARBAGE_COLLECTOR"/>
+					<Add option="-D_CRT_SECURE_NO_DEPRECATE"/>
+					<Add option="-D_CRT_NON_CONFORMING_SWPRINTFS"/>
+					<Add option="-W"/>
+					<Add option="-O0"/>
+					<Add directory="..\include"/>
+				</Compiler>
+			</Target>
+			<Target title="Release - Unicode">
+				<Option output="..\lib\libsquirrelU.a"/>
+				<Option working_dir=""/>
+				<Option object_output="Release - Unicode"/>
+				<Option deps_output=".deps"/>
+				<Option type="2"/>
+				<Option compiler="0"/>
+				<Option createDefFile="1"/>
+				<Option projectResourceIncludeDirsRelation="2"/>
+				<Compiler>
+					<Add option="-DWIN32"/>
+					<Add option="-DNDEBUG"/>
+					<Add option="-D_LIB"/>
+					<Add option="-DGARBAGE_COLLECTOR"/>
+					<Add option="-D_CRT_SECURE_NO_DEPRECATE"/>
+					<Add option="-D_CRT_NON_CONFORMING_SWPRINTFS"/>
+					<Add option="-W"/>
+					<Add option="-O2"/>
+					<Add directory="..\include"/>
+				</Compiler>
+			</Target>
+		</Build>
+		<Unit filename="sqapi.cpp">
+			<Option compilerVar="CPP"/>
+			<Option target="Debug"/>
+			<Option target="Release"/>
+			<Option target="Debug - Unicode"/>
+			<Option target="Release - Unicode"/>
+		</Unit>
+		<Unit filename="sqarray.h">
+			<Option compilerVar=""/>
+			<Option compile="0"/>
+			<Option link="0"/>
+			<Option target="Debug"/>
+			<Option target="Release"/>
+			<Option target="Debug - Unicode"/>
+			<Option target="Release - Unicode"/>
+		</Unit>
+		<Unit filename="sqbaselib.cpp">
+			<Option compilerVar="CPP"/>
+			<Option target="Debug"/>
+			<Option target="Release"/>
+			<Option target="Debug - Unicode"/>
+			<Option target="Release - Unicode"/>
+		</Unit>
+		<Unit filename="sqclass.cpp">
+			<Option compilerVar="CPP"/>
+			<Option target="Debug"/>
+			<Option target="Release"/>
+			<Option target="Debug - Unicode"/>
+			<Option target="Release - Unicode"/>
+		</Unit>
+		<Unit filename="sqclass.h">
+			<Option compilerVar=""/>
+			<Option compile="0"/>
+			<Option link="0"/>
+			<Option target="Debug"/>
+			<Option target="Release"/>
+			<Option target="Debug - Unicode"/>
+			<Option target="Release - Unicode"/>
+		</Unit>
+		<Unit filename="sqclosure.h">
+			<Option compilerVar=""/>
+			<Option compile="0"/>
+			<Option link="0"/>
+			<Option target="Debug"/>
+			<Option target="Release"/>
+			<Option target="Debug - Unicode"/>
+			<Option target="Release - Unicode"/>
+		</Unit>
+		<Unit filename="sqcompiler.cpp">
+			<Option compilerVar="CPP"/>
+			<Option target="Debug"/>
+			<Option target="Release"/>
+			<Option target="Debug - Unicode"/>
+			<Option target="Release - Unicode"/>
+		</Unit>
+		<Unit filename="sqcompiler.h">
+			<Option compilerVar=""/>
+			<Option compile="0"/>
+			<Option link="0"/>
+			<Option target="Debug"/>
+			<Option target="Release"/>
+			<Option target="Debug - Unicode"/>
+			<Option target="Release - Unicode"/>
+		</Unit>
+		<Unit filename="sqdebug.cpp">
+			<Option compilerVar="CPP"/>
+			<Option target="Debug"/>
+			<Option target="Release"/>
+			<Option target="Debug - Unicode"/>
+			<Option target="Release - Unicode"/>
+		</Unit>
+		<Unit filename="sqfuncproto.h">
+			<Option compilerVar=""/>
+			<Option compile="0"/>
+			<Option link="0"/>
+			<Option target="Debug"/>
+			<Option target="Release"/>
+			<Option target="Debug - Unicode"/>
+			<Option target="Release - Unicode"/>
+		</Unit>
+		<Unit filename="sqfuncstate.cpp">
+			<Option compilerVar="CPP"/>
+			<Option target="Debug"/>
+			<Option target="Release"/>
+			<Option target="Debug - Unicode"/>
+			<Option target="Release - Unicode"/>
+		</Unit>
+		<Unit filename="sqfuncstate.h">
+			<Option compilerVar=""/>
+			<Option compile="0"/>
+			<Option link="0"/>
+			<Option target="Debug"/>
+			<Option target="Release"/>
+			<Option target="Debug - Unicode"/>
+			<Option target="Release - Unicode"/>
+		</Unit>
+		<Unit filename="sqlexer.cpp">
+			<Option compilerVar="CPP"/>
+			<Option target="Debug"/>
+			<Option target="Release"/>
+			<Option target="Debug - Unicode"/>
+			<Option target="Release - Unicode"/>
+		</Unit>
+		<Unit filename="sqlexer.h">
+			<Option compilerVar=""/>
+			<Option compile="0"/>
+			<Option link="0"/>
+			<Option target="Debug"/>
+			<Option target="Release"/>
+			<Option target="Debug - Unicode"/>
+			<Option target="Release - Unicode"/>
+		</Unit>
+		<Unit filename="sqmem.cpp">
+			<Option compilerVar="CPP"/>
+			<Option target="Debug"/>
+			<Option target="Release"/>
+			<Option target="Debug - Unicode"/>
+			<Option target="Release - Unicode"/>
+		</Unit>
+		<Unit filename="sqobject.cpp">
+			<Option compilerVar="CPP"/>
+			<Option target="Debug"/>
+			<Option target="Release"/>
+			<Option target="Debug - Unicode"/>
+			<Option target="Release - Unicode"/>
+		</Unit>
+		<Unit filename="sqobject.h">
+			<Option compilerVar=""/>
+			<Option compile="0"/>
+			<Option link="0"/>
+			<Option target="Debug"/>
+			<Option target="Release"/>
+			<Option target="Debug - Unicode"/>
+			<Option target="Release - Unicode"/>
+		</Unit>
+		<Unit filename="sqopcodes.h">
+			<Option compilerVar=""/>
+			<Option compile="0"/>
+			<Option link="0"/>
+			<Option target="Debug"/>
+			<Option target="Release"/>
+			<Option target="Debug - Unicode"/>
+			<Option target="Release - Unicode"/>
+		</Unit>
+		<Unit filename="sqpcheader.h">
+			<Option compilerVar=""/>
+			<Option compile="0"/>
+			<Option link="0"/>
+			<Option target="Debug"/>
+			<Option target="Release"/>
+			<Option target="Debug - Unicode"/>
+			<Option target="Release - Unicode"/>
+		</Unit>
+		<Unit filename="sqstate.cpp">
+			<Option compilerVar="CPP"/>
+			<Option target="Debug"/>
+			<Option target="Release"/>
+			<Option target="Debug - Unicode"/>
+			<Option target="Release - Unicode"/>
+		</Unit>
+		<Unit filename="sqstate.h">
+			<Option compilerVar=""/>
+			<Option compile="0"/>
+			<Option link="0"/>
+			<Option target="Debug"/>
+			<Option target="Release"/>
+			<Option target="Debug - Unicode"/>
+			<Option target="Release - Unicode"/>
+		</Unit>
+		<Unit filename="sqstring.h">
+			<Option compilerVar=""/>
+			<Option compile="0"/>
+			<Option link="0"/>
+			<Option target="Debug"/>
+			<Option target="Release"/>
+			<Option target="Debug - Unicode"/>
+			<Option target="Release - Unicode"/>
+		</Unit>
+		<Unit filename="sqtable.cpp">
+			<Option compilerVar="CPP"/>
+			<Option target="Debug"/>
+			<Option target="Release"/>
+			<Option target="Debug - Unicode"/>
+			<Option target="Release - Unicode"/>
+		</Unit>
+		<Unit filename="sqtable.h">
+			<Option compilerVar=""/>
+			<Option compile="0"/>
+			<Option link="0"/>
+			<Option target="Debug"/>
+			<Option target="Release"/>
+			<Option target="Debug - Unicode"/>
+			<Option target="Release - Unicode"/>
+		</Unit>
+		<Unit filename="squserdata.h">
+			<Option compilerVar=""/>
+			<Option compile="0"/>
+			<Option link="0"/>
+			<Option target="Debug"/>
+			<Option target="Release"/>
+			<Option target="Debug - Unicode"/>
+			<Option target="Release - Unicode"/>
+		</Unit>
+		<Unit filename="squtils.h">
+			<Option compilerVar=""/>
+			<Option compile="0"/>
+			<Option link="0"/>
+			<Option target="Debug"/>
+			<Option target="Release"/>
+			<Option target="Debug - Unicode"/>
+			<Option target="Release - Unicode"/>
+		</Unit>
+		<Unit filename="sqvm.cpp">
+			<Option compilerVar="CPP"/>
+			<Option target="Debug"/>
+			<Option target="Release"/>
+			<Option target="Debug - Unicode"/>
+			<Option target="Release - Unicode"/>
+		</Unit>
+		<Unit filename="sqvm.h">
+			<Option compilerVar=""/>
+			<Option compile="0"/>
+			<Option link="0"/>
+			<Option target="Debug"/>
+			<Option target="Release"/>
+			<Option target="Debug - Unicode"/>
+			<Option target="Release - Unicode"/>
+		</Unit>
+	</Project>
+</CodeBlocks_project_file>
diff -rupwN ../dnl3/SqPlus/_squirrel/squirrellib.cbp SqPlus/_squirrel/squirrellib.cbp
--- ../dnl3/SqPlus/_squirrel/squirrellib.cbp	1969-12-31 19:00:00.000000000 -0500
+++ SqPlus/_squirrel/squirrellib.cbp	2006-04-25 17:05:30.000000000 -0400
@@ -0,0 +1,20 @@
+<?xml version="1.0"?>
+<!DOCTYPE CodeBlocks_project_file>
+<CodeBlocks_project_file>
+	<FileVersion major="1" minor="1"/>
+	<Project>
+		<Option title="Static library"/>
+		<Option makefile="Makefile"/>
+		<Build>
+			<Target title="default">
+				<Option type="2"/>
+				<Option parameters=""/>
+				<Option includeInTargetAll="1"/>
+				<Option projectCompilerOptionsRelation="3"/>
+				<Option projectLinkerOptionsRelation="3"/>
+				<Option projectIncludeDirsRelation="3"/>
+				<Option projectLibDirsRelation="3"/>
+			</Target>
+		</Build>
+	</Project>
+</CodeBlocks_project_file>
diff -rupwN ../dnl3/SqPlus/_squirrel/squirrel.vcproj SqPlus/_squirrel/squirrel.vcproj
--- ../dnl3/SqPlus/_squirrel/squirrel.vcproj	1969-12-31 19:00:00.000000000 -0500
+++ SqPlus/_squirrel/squirrel.vcproj	2006-03-26 18:21:16.000000000 -0500
@@ -0,0 +1,971 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="8.00"
+	Name="squirrel"
+	ProjectGUID="{A79653F2-73F4-4F57-AE86-4AEBDE795232}"
+	RootNamespace="squirrel"
+	SccLocalPath=".."
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="4"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC71.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\include"
+				PreprocessorDefinitions="WIN32;_DEBUG;_LIB;GARBAGE_COLLECTOR;_CRT_SECURE_NO_DEPRECATE"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				UsePrecompiledHeader="0"
+				PrecompiledHeaderFile=".\Debug/squirrel.pch"
+				AssemblerListingLocation="$(IntDir)/"
+				ObjectFile="$(IntDir)/"
+				ProgramDataBaseFileName="$(IntDir)/"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+				DebugInformationFormat="4"
+				CompileAs="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="1040"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+				OutputFile="..\lib\squirrelD.lib"
+				SuppressStartupBanner="true"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="4"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC71.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="1"
+				AdditionalIncludeDirectories="..\include"
+				PreprocessorDefinitions="WIN32;NDEBUG;_LIB;GARBAGE_COLLECTOR;_CRT_SECURE_NO_DEPRECATE"
+				StringPooling="true"
+				RuntimeLibrary="0"
+				EnableFunctionLevelLinking="true"
+				UsePrecompiledHeader="0"
+				PrecompiledHeaderFile=".\Release/squirrel.pch"
+				AssemblerListingLocation="$(IntDir)/"
+				ObjectFile="$(IntDir)/"
+				ProgramDataBaseFileName="$(IntDir)/"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+				CompileAs="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG"
+				Culture="1040"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+				OutputFile="..\lib\squirrel.lib"
+				SuppressStartupBanner="true"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug - Unicode|Win32"
+			OutputDirectory="$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="4"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC71.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\include"
+				PreprocessorDefinitions="WIN32;_DEBUG;_LIB;GARBAGE_COLLECTOR;_CRT_SECURE_NO_DEPRECATE;_CRT_NON_CONFORMING_SWPRINTFS"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				UsePrecompiledHeader="0"
+				PrecompiledHeaderFile=".\DebugU/squirrel.pch"
+				AssemblerListingLocation="$(IntDir)/"
+				ObjectFile="$(IntDir)/"
+				ProgramDataBaseFileName="$(IntDir)/"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+				DebugInformationFormat="4"
+				CompileAs="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="1040"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+				OutputFile="..\lib\squirrelDU.lib"
+				SuppressStartupBanner="true"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release - Unicode|Win32"
+			OutputDirectory="$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="4"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC71.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="1"
+				AdditionalIncludeDirectories="..\include"
+				PreprocessorDefinitions="WIN32;NDEBUG;_LIB;GARBAGE_COLLECTOR;_CRT_SECURE_NO_DEPRECATE;_CRT_NON_CONFORMING_SWPRINTFS"
+				StringPooling="true"
+				RuntimeLibrary="0"
+				EnableFunctionLevelLinking="true"
+				UsePrecompiledHeader="0"
+				PrecompiledHeaderFile=".\Release/squirrel.pch"
+				AssemblerListingLocation="$(IntDir)/"
+				ObjectFile="$(IntDir)/"
+				ProgramDataBaseFileName="$(IntDir)/"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+				CompileAs="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG"
+				Culture="1040"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+				OutputFile="..\lib\squirrelU.lib"
+				SuppressStartupBanner="true"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
+			>
+			<File
+				RelativePath="sqapi.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"
+						PrecompiledHeaderThrough="stdafx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug - Unicode|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"
+						PrecompiledHeaderThrough="stdafx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release - Unicode|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="sqbaselib.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"
+						PrecompiledHeaderThrough="stdafx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug - Unicode|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"
+						PrecompiledHeaderThrough="stdafx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release - Unicode|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="sqclass.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"
+						PrecompiledHeaderThrough="stdafx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug - Unicode|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"
+						PrecompiledHeaderThrough="stdafx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release - Unicode|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="sqcompiler.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"
+						PrecompiledHeaderThrough="stdafx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug - Unicode|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"
+						PrecompiledHeaderThrough="stdafx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release - Unicode|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="sqdebug.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"
+						PrecompiledHeaderThrough="stdafx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug - Unicode|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"
+						PrecompiledHeaderThrough="stdafx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release - Unicode|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="sqfuncstate.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"
+						PrecompiledHeaderThrough="stdafx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug - Unicode|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"
+						PrecompiledHeaderThrough="stdafx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release - Unicode|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="sqlexer.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"
+						PrecompiledHeaderThrough="stdafx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug - Unicode|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"
+						PrecompiledHeaderThrough="stdafx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release - Unicode|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="sqmem.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug - Unicode|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release - Unicode|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="sqobject.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"
+						PrecompiledHeaderThrough="stdafx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug - Unicode|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"
+						PrecompiledHeaderThrough="stdafx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release - Unicode|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="sqstate.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"
+						PrecompiledHeaderThrough="stdafx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug - Unicode|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"
+						PrecompiledHeaderThrough="stdafx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release - Unicode|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="sqtable.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"
+						PrecompiledHeaderThrough="stdafx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug - Unicode|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"
+						PrecompiledHeaderThrough="stdafx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release - Unicode|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="sqvm.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"
+						PrecompiledHeaderThrough="stdafx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug - Unicode|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"
+						PrecompiledHeaderThrough="stdafx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release - Unicode|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl"
+			>
+			<File
+				RelativePath="sqarray.h"
+				>
+			</File>
+			<File
+				RelativePath="sqclass.h"
+				>
+			</File>
+			<File
+				RelativePath="sqclosure.h"
+				>
+			</File>
+			<File
+				RelativePath="sqcompiler.h"
+				>
+			</File>
+			<File
+				RelativePath="sqfuncproto.h"
+				>
+			</File>
+			<File
+				RelativePath="sqfuncstate.h"
+				>
+			</File>
+			<File
+				RelativePath="sqlexer.h"
+				>
+			</File>
+			<File
+				RelativePath="sqobject.h"
+				>
+			</File>
+			<File
+				RelativePath="sqopcodes.h"
+				>
+			</File>
+			<File
+				RelativePath="sqpcheader.h"
+				>
+			</File>
+			<File
+				RelativePath="sqstate.h"
+				>
+			</File>
+			<File
+				RelativePath="sqstring.h"
+				>
+			</File>
+			<File
+				RelativePath="sqtable.h"
+				>
+			</File>
+			<File
+				RelativePath="squserdata.h"
+				>
+			</File>
+			<File
+				RelativePath="squtils.h"
+				>
+			</File>
+			<File
+				RelativePath="sqvm.h"
+				>
+			</File>
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -rupwN ../dnl3/SqPlus/_squirrel/squserdata.h SqPlus/_squirrel/squserdata.h
--- ../dnl3/SqPlus/_squirrel/squserdata.h	1969-12-31 19:00:00.000000000 -0500
+++ SqPlus/_squirrel/squserdata.h	2005-09-25 17:56:20.000000000 -0400
@@ -0,0 +1,38 @@
+/*	see copyright notice in squirrel.h */
+#ifndef _SQUSERDATA_H_
+#define _SQUSERDATA_H_
+
+struct SQUserData : SQDelegable
+{
+	SQUserData(SQSharedState *ss){ _delegate = 0; _hook = NULL; INIT_CHAIN(); ADD_TO_CHAIN(&_ss(this)->_gc_chain, this); }
+	~SQUserData()
+	{
+		REMOVE_FROM_CHAIN(&_ss(this)->_gc_chain, this);
+		SetDelegate(NULL);
+	}
+	static SQUserData* Create(SQSharedState *ss, SQInteger size)
+	{
+		SQUserData* ud = (SQUserData*)SQ_MALLOC(sizeof(SQUserData)+(size-1));
+		new (ud) SQUserData(ss);
+		ud->_size = size;
+		ud->_typetag = 0;
+		return ud;
+	}
+#ifndef NO_GARBAGE_COLLECTOR
+	void Mark(SQCollectable **chain);
+	void Finalize(){SetDelegate(NULL);}
+#endif
+	void Release() {
+		if (_hook) _hook(_val,_size);
+		SQInteger tsize = _size - 1;
+		this->~SQUserData();
+		SQ_FREE(this, sizeof(SQUserData) + tsize);
+	}
+		
+	SQInteger _size;
+	SQRELEASEHOOK _hook;
+	SQUserPointer _typetag;
+	SQChar _val[1];
+};
+
+#endif //_SQUSERDATA_H_
diff -rupwN ../dnl3/SqPlus/_squirrel/squtils.h SqPlus/_squirrel/squtils.h
--- ../dnl3/SqPlus/_squirrel/squtils.h	1969-12-31 19:00:00.000000000 -0500
+++ SqPlus/_squirrel/squtils.h	2005-09-25 17:56:20.000000000 -0400
@@ -0,0 +1,104 @@
+/*	see copyright notice in squirrel.h */
+#ifndef _SQUTILS_H_
+#define _SQUTILS_H_
+
+#define sq_new(__ptr,__type) {__ptr=(__type *)sq_vm_malloc(sizeof(__type));new (__ptr) __type;}
+#define sq_delete(__ptr,__type) {__ptr->~__type();sq_vm_free(__ptr,sizeof(__type));}
+#define SQ_MALLOC(__size) sq_vm_malloc(__size);
+#define SQ_FREE(__ptr,__size) sq_vm_free(__ptr,__size);
+#define SQ_REALLOC(__ptr,__oldsize,__size) sq_vm_realloc(__ptr,__oldsize,__size);
+
+//sqvector mini vector class, supports objects by value
+template<typename T> class sqvector
+{
+public:
+	sqvector()
+	{
+		_vals = NULL;
+		_size = 0;
+		_allocated = 0;
+	}
+	sqvector(const sqvector<T>& v)
+	{
+		copy(v);
+	}
+	void copy(const sqvector<T>& v)
+	{
+		resize(v._size);
+		for(SQUnsignedInteger i = 0; i < v._size; i++) {
+			new ((void *)&_vals[i]) T(v._vals[i]);
+		}
+		_size = v._size;
+	}
+	~sqvector()
+	{
+		if(_allocated) {
+			for(SQUnsignedInteger i = 0; i < _size; i++)
+				_vals[i].~T();
+			SQ_FREE(_vals, (_allocated * sizeof(T)));
+		}
+	}
+	void reserve(SQUnsignedInteger newsize) { _realloc(newsize); }
+	void resize(SQUnsignedInteger newsize, const T& fill = T())
+	{
+		if(newsize > _allocated)
+			_realloc(newsize);
+		if(newsize > _size) {
+			while(_size < newsize) {
+				new ((void *)&_vals[_size]) T(fill);
+				_size++;
+			}
+		}
+		else{
+			for(SQUnsignedInteger i = newsize; i < _size; i++) {
+				_vals[i].~T();
+			}
+			_size = newsize;
+		}
+	}
+	void shrinktofit() { if(_size > 4) { _realloc(_size); } }
+	T& top() const { return _vals[_size - 1]; }
+	inline SQUnsignedInteger size() const { return _size; }
+	bool empty() const { return (_size <= 0); }
+	inline T &push_back(const T& val = T())
+	{
+		if(_allocated <= _size)
+			_realloc(_size * 2);
+		return *(new ((void *)&_vals[_size++]) T(val));
+	}
+	inline void pop_back()
+	{
+		_size--; _vals[_size].~T();
+	}
+	void insert(SQUnsignedInteger idx, const T& val)
+	{
+		resize(_size + 1);
+		for(SQUnsignedInteger i = _size - 1; i > idx; i--) {
+			_vals[i] = _vals[i - 1];
+		}
+    	_vals[idx] = val;
+	}
+	void remove(SQUnsignedInteger idx)
+	{
+		_vals[idx].~T();
+		if(idx < (_size - 1)) {
+			memcpy(&_vals[idx], &_vals[idx+1], sizeof(T) * (_size - idx - 1));
+		}
+		_size--;
+	}
+	SQUnsignedInteger capacity() { return _allocated; }
+	inline T &back() const { return _vals[_size - 1]; }
+	inline T& operator[](SQUnsignedInteger pos) const{ return _vals[pos]; }
+	T* _vals;
+private:
+	void _realloc(SQUnsignedInteger newsize)
+	{
+		newsize = (newsize > 0)?newsize:4;
+		_vals = (T*)SQ_REALLOC(_vals, _allocated * sizeof(T), newsize * sizeof(T));
+		_allocated = newsize;
+	}
+	SQUnsignedInteger _size;
+	SQUnsignedInteger _allocated;
+};
+
+#endif //_SQUTILS_H_
diff -rupwN ../dnl3/SqPlus/_squirrel/sqvm.cpp SqPlus/_squirrel/sqvm.cpp
--- ../dnl3/SqPlus/_squirrel/sqvm.cpp	1969-12-31 19:00:00.000000000 -0500
+++ SqPlus/_squirrel/sqvm.cpp	2006-03-19 14:32:58.000000000 -0500
@@ -0,0 +1,1467 @@
+/*
+	see copyright notice in squirrel.h
+*/
+#include "sqpcheader.h"
+#include <math.h>
+#include <stdlib.h>
+#include "sqopcodes.h"
+#include "sqfuncproto.h"
+#include "sqvm.h"
+#include "sqclosure.h"
+#include "sqstring.h"
+#include "sqtable.h"
+#include "squserdata.h"
+#include "sqarray.h"
+#include "sqclass.h"
+
+#define TOP() (_stack[_top-1])
+
+bool SQVM::BW_OP(SQUnsignedInteger op,SQObjectPtr &trg,const SQObjectPtr &o1,const SQObjectPtr &o2)
+{
+	SQInteger res;
+	SQInteger i1 = _integer(o1), i2 = _integer(o2);
+	if((type(o1)==OT_INTEGER) && (type(o2)==OT_INTEGER))
+	{
+		switch(op) {
+			case BW_AND:	res = i1 & i2; break;
+			case BW_OR:		res = i1 | i2; break;
+			case BW_XOR:	res = i1 ^ i2; break;
+			case BW_SHIFTL:	res = i1 << i2; break;
+			case BW_SHIFTR:	res = i1 >> i2; break;
+			case BW_USHIFTR:res = (SQInteger)(*((SQUnsignedInteger*)&i1) >> i2); break;
+			default: { Raise_Error(_SC("internal vm error bitwise op failed")); return false; }
+		}
+	} 
+	else { Raise_Error(_SC("bitwise op between '%s' and '%s'"),GetTypeName(o1),GetTypeName(o2)); return false;}
+	trg = res;
+	return true;
+}
+
+bool SQVM::ARITH_OP(SQUnsignedInteger op,SQObjectPtr &trg,const SQObjectPtr &o1,const SQObjectPtr &o2)
+{
+	if(sq_isnumeric(o1) && sq_isnumeric(o2)) {
+			if((type(o1)==OT_INTEGER) && (type(o2)==OT_INTEGER)) {
+				switch(op) {
+				case '+': trg = _integer(o1) + _integer(o2); break;
+				case '-': trg = _integer(o1) - _integer(o2); break;
+				case '/': if(_integer(o2) == 0) { Raise_Error(_SC("division by zero")); return false; }
+					trg = _integer(o1) / _integer(o2); 
+					break;
+				case '*': trg = _integer(o1) * _integer(o2); break;
+				case '%': trg = _integer(o1) % _integer(o2); break;
+				}
+			}else{
+				switch(op) {
+				case '+': trg = tofloat(o1) + tofloat(o2); break;
+				case '-': trg = tofloat(o1) - tofloat(o2); break;
+				case '/': trg = tofloat(o1) / tofloat(o2); break;
+				case '*': trg = tofloat(o1) * tofloat(o2); break;
+				case '%': trg = SQFloat(fmod((double)tofloat(o1),(double)tofloat(o2))); break;
+				}
+			}	
+		} else {
+			if(op == '+' &&	(type(o1) == OT_STRING || type(o2) == OT_STRING)){
+					if(!StringCat(o1, o2, trg)) return false;
+			}
+			else if(!ArithMetaMethod(op,o1,o2,trg)) { 
+				Raise_Error(_SC("arith op %c on between '%s' and '%s'"),op,GetTypeName(o1),GetTypeName(o2)); return false; 
+			}
+		}
+		return true;
+}
+
+SQVM::SQVM(SQSharedState *ss)
+{
+	_sharedstate=ss;
+	_suspended = SQFalse;
+	_suspended_target=-1;
+	_suspended_root = SQFalse;
+	_suspended_traps=-1;
+	_foreignptr=NULL;
+	_nnativecalls=0;
+	_lasterror = _null_;
+	_errorhandler = _null_;
+	_debughook = _null_;
+	ci = NULL;
+	INIT_CHAIN();ADD_TO_CHAIN(&_ss(this)->_gc_chain,this);
+}
+
+void SQVM::Finalize()
+{
+	_roottable = _null_;
+	_lasterror = _null_;
+	_errorhandler = _null_;
+	_debughook = _null_;
+	temp_reg = _null_;
+	SQInteger size=_stack.size();
+	for(SQInteger i=0;i<size;i++)
+		_stack[i]=_null_;
+}
+
+SQVM::~SQVM()
+{
+	Finalize();
+	REMOVE_FROM_CHAIN(&_ss(this)->_gc_chain,this);
+}
+
+bool SQVM::ArithMetaMethod(SQInteger op,const SQObjectPtr &o1,const SQObjectPtr &o2,SQObjectPtr &dest)
+{
+	SQMetaMethod mm;
+	switch(op){
+		case _SC('+'): mm=MT_ADD; break;
+		case _SC('-'): mm=MT_SUB; break;
+		case _SC('/'): mm=MT_DIV; break;
+		case _SC('*'): mm=MT_MUL; break;
+		case _SC('%'): mm=MT_MODULO; break;
+		default: mm = MT_ADD; assert(0); break; //shutup compiler
+	}
+	if(is_delegable(o1) && _delegable(o1)->_delegate) {
+		Push(o1);Push(o2);
+		return CallMetaMethod(_delegable(o1),mm,2,dest);
+	}
+	return false;
+}
+
+bool SQVM::NEG_OP(SQObjectPtr &trg,const SQObjectPtr &o)
+{
+	
+	switch(type(o)) {
+	case OT_INTEGER:
+		trg = -_integer(o);
+		return true;
+	case OT_FLOAT:
+		trg = -_float(o);
+		return true;
+	case OT_TABLE:
+	case OT_USERDATA:
+	case OT_INSTANCE:
+		if(_delegable(o)->_delegate) {
+			Push(o);
+			if(CallMetaMethod(_delegable(o), MT_UNM, 1, temp_reg)) {
+				trg = temp_reg;
+				return true;
+			}
+		}
+	default:break; //shutup compiler
+	}
+	Raise_Error(_SC("attempt to negate a %s"), GetTypeName(o));
+	return false;
+}
+
+#define _RET_SUCCEED(exp) { result = (exp); return true; } 
+bool SQVM::ObjCmp(const SQObjectPtr &o1,const SQObjectPtr &o2,SQInteger &result)
+{
+	if(type(o1)==type(o2)){
+		if(_userpointer(o1)==_userpointer(o2))_RET_SUCCEED(0);
+		SQObjectPtr res;
+		switch(type(o1)){
+		case OT_STRING:
+			_RET_SUCCEED(scstrcmp(_stringval(o1),_stringval(o2)));
+		case OT_INTEGER:
+			_RET_SUCCEED(_integer(o1)-_integer(o2));
+		case OT_FLOAT:
+			_RET_SUCCEED((_float(o1)<_float(o2))?-1:1);
+		case OT_TABLE:
+		case OT_USERDATA:
+		case OT_INSTANCE:
+			Push(o1);Push(o2);
+			if(_delegable(o1)->_delegate)CallMetaMethod(_delegable(o1),MT_CMP,2,res);
+			break;
+		default: break; //shutup compiler
+		}
+		if(type(res)!=OT_INTEGER) { Raise_CompareError(o1,o2); return false; }
+			_RET_SUCCEED(_integer(res));
+		
+	}
+	else{
+		if(sq_isnumeric(o1) && sq_isnumeric(o2)){
+			if((type(o1)==OT_INTEGER) && (type(o2)==OT_FLOAT)) { 
+				if( _integer(o1)==_float(o2) ) { _RET_SUCCEED(0); }
+				else if( _integer(o1)<_float(o2) ) { _RET_SUCCEED(-1); }
+				_RET_SUCCEED(1);
+			}
+			else{
+				if( _float(o1)==_integer(o2) ) { _RET_SUCCEED(0); }
+				else if( _float(o1)<_integer(o2) ) { _RET_SUCCEED(-1); }
+				_RET_SUCCEED(1);
+			}
+		}
+		else if(type(o1)==OT_NULL) {_RET_SUCCEED(-1);}
+		else if(type(o2)==OT_NULL) {_RET_SUCCEED(1);}
+		else { Raise_CompareError(o1,o2); return false; }
+		
+	}
+	assert(0);
+	_RET_SUCCEED(0); //cannot happen
+}
+
+bool SQVM::CMP_OP(CmpOP op, const SQObjectPtr &o1,const SQObjectPtr &o2,SQObjectPtr &res)
+{
+	SQInteger r;
+	if(ObjCmp(o1,o2,r)) {
+		switch(op) {
+			case CMP_G: res = (r > 0)?_true_:_false_; return true;
+			case CMP_GE: res = (r >= 0)?_true_:_false_; return true;
+			case CMP_L: res = (r < 0)?_true_:_false_; return true;
+			case CMP_LE: res = (r <= 0)?_true_:_false_; return true;
+			
+		}
+		assert(0);
+	}
+	return false;
+}
+
+void SQVM::ToString(const SQObjectPtr &o,SQObjectPtr &res)
+{
+	switch(type(o)) {
+	case OT_STRING:
+		res = o;
+		return;
+	case OT_FLOAT:
+		scsprintf(_sp(rsl(NUMBER_MAX_CHAR+1)),_SC("%g"),_float(o));
+		break;
+	case OT_INTEGER:
+		scsprintf(_sp(rsl(NUMBER_MAX_CHAR+1)),_SC("%d"),_integer(o));
+		break;
+	case OT_BOOL:
+		scsprintf(_sp(rsl(6)),_integer(o)?_SC("true"):_SC("false"));
+		break;
+	case OT_TABLE:
+	case OT_USERDATA:
+	case OT_INSTANCE:
+		if(_delegable(o)->_delegate) {
+			Push(o);
+			if(CallMetaMethod(_delegable(o),MT_TOSTRING,1,res)) {
+				if(type(res) == OT_STRING)
+					return;
+				//else keeps going to the default
+			}
+		}
+	default:
+		scsprintf(_sp(rsl(sizeof(void*)+20)),_SC("(%s : 0x%p)"),GetTypeName(o),(void*)_rawval(o));
+	}
+	res = SQString::Create(_ss(this),_spval);
+}
+
+
+bool SQVM::StringCat(const SQObjectPtr &str,const SQObjectPtr &obj,SQObjectPtr &dest)
+{
+	SQObjectPtr a, b;
+	ToString(str, a);
+	ToString(obj, b);
+	SQInteger l = _string(a)->_len , ol = _string(b)->_len;
+	SQChar *s = _sp(rsl(l + ol + 1));
+	memcpy(s, _stringval(a), rsl(l)); 
+	memcpy(s + l, _stringval(b), rsl(ol));
+	dest = SQString::Create(_ss(this), _spval, l + ol);
+	return true;
+}
+
+const SQChar *IdType2Name(SQObjectType type)
+{
+	switch(_RAW_TYPE(type))
+	{
+	case _RT_NULL:return _SC("null");
+	case _RT_INTEGER:return _SC("integer");
+	case _RT_FLOAT:return _SC("float");
+	case _RT_BOOL:return _SC("bool");
+	case _RT_STRING:return _SC("string");
+	case _RT_TABLE:return _SC("table");
+	case _RT_ARRAY:return _SC("array");
+	case _RT_GENERATOR:return _SC("generator");
+	case _RT_CLOSURE:
+	case _RT_NATIVECLOSURE:
+		return _SC("function");
+	case _RT_USERDATA:
+	case _RT_USERPOINTER:
+		return _SC("userdata");
+	case _RT_THREAD: return _SC("thread");
+	case _RT_FUNCPROTO: return _SC("function");
+	case _RT_CLASS: return _SC("class");
+	case _RT_INSTANCE: return _SC("instance");
+	case _RT_WEAKREF: return _SC("weakref");
+	default:
+		return NULL;
+	}
+}
+
+const SQChar *GetTypeName(const SQObjectPtr &obj1)
+{
+	return IdType2Name(type(obj1));	
+}
+
+void SQVM::TypeOf(const SQObjectPtr &obj1,SQObjectPtr &dest)
+{
+	if(is_delegable(obj1) && _delegable(obj1)->_delegate) {
+		Push(obj1);
+		if(CallMetaMethod(_delegable(obj1),MT_TYPEOF,1,dest))
+			return;
+	}
+	dest = SQString::Create(_ss(this),GetTypeName(obj1));
+}
+
+bool SQVM::Init(SQVM *friendvm, SQInteger stacksize)
+{
+	_stack.resize(stacksize);
+	_callsstack.reserve(4);
+	_stackbase = 0;
+	_top = 0;
+	if(!friendvm) 
+		_roottable = SQTable::Create(_ss(this), 0);
+	else {
+		_roottable = friendvm->_roottable;
+		_errorhandler = friendvm->_errorhandler;
+		_debughook = friendvm->_debughook;
+	}
+	
+	sq_base_register(this);
+	return true;
+}
+
+extern SQInstructionDesc g_InstrDesc[];
+
+bool SQVM::StartCall(SQClosure *closure,SQInteger target,SQInteger nargs,SQInteger stackbase,bool tailcall)
+{
+	SQFunctionProto *func = _funcproto(closure->_function);
+	
+	const SQInteger paramssize = func->_parameters.size();
+	const SQInteger newtop = stackbase + func->_stacksize;
+	
+	
+	if (paramssize != nargs) {
+		if(func->_varparams)
+		{
+			if (nargs < paramssize) {
+				Raise_Error(_SC("wrong number of parameters"));
+				return false;
+			}
+			for(SQInteger n = 0; n < nargs - paramssize; n++) {
+				_vargsstack.push_back(_stack[stackbase+paramssize+n]);
+				_stack[stackbase+paramssize+n] = _null_;
+			}
+		}
+		else {
+			Raise_Error(_SC("wrong number of parameters"));
+			return false;
+		}
+	}
+
+	if(type(closure->_env) == OT_WEAKREF) {
+		_stack[stackbase] = _weakref(closure->_env)->_obj;
+	}
+
+	if (!tailcall) {
+		CallInfo lc;
+		lc._etraps = 0;
+		lc._prevstkbase = stackbase - _stackbase;
+		lc._target = target;
+		lc._prevtop = _top - _stackbase;
+		lc._ncalls = 1;
+		lc._root = SQFalse;
+		PUSH_CALLINFO(this, lc);
+	}
+	else {
+		ci->_ncalls++;
+		if(ci->_vargs.size) PopVarArgs(ci->_vargs);
+	}
+	ci->_vargs.size = (nargs - paramssize);
+	ci->_vargs.base = _vargsstack.size()-(ci->_vargs.size);
+	ci->_closure._unVal.pClosure = closure;
+	ci->_closure._type = OT_CLOSURE;
+	ci->_iv = &func->_instructions;
+	ci->_literals = &func->_literals;
+	//grows the stack if needed
+	if (((SQUnsignedInteger)newtop + (func->_stacksize<<1)) > _stack.size()) {
+		_stack.resize(_stack.size() + (func->_stacksize<<1));
+	}
+		
+	_top = newtop;
+	_stackbase = stackbase;
+	ci->_ip = ci->_iv->_vals;
+	return true;
+}
+
+bool SQVM::Return(SQInteger _arg0, SQInteger _arg1, SQObjectPtr &retval)
+{
+	if (type(_debughook) != OT_NULL && _rawval(_debughook) != _rawval(ci->_closure))
+		for(SQInteger i=0;i<ci->_ncalls;i++)
+			CallDebugHook(_SC('r'));
+			
+	SQBool broot = ci->_root;
+	SQInteger last_top = _top;
+	SQInteger target = ci->_target;
+	SQInteger oldstackbase = _stackbase;
+	_stackbase -= ci->_prevstkbase;
+	_top = _stackbase + ci->_prevtop;
+	if(ci->_vargs.size) PopVarArgs(ci->_vargs);
+	POP_CALLINFO(this);
+	if (broot) {
+		if (_arg0 != MAX_FUNC_STACKSIZE) retval = _stack[oldstackbase+_arg1];
+		else retval = _null_;
+	}
+	else {
+		if(target != -1) { //-1 is when a class contructor ret value has to be ignored
+			if (_arg0 != MAX_FUNC_STACKSIZE)
+				STK(target) = _stack[oldstackbase+_arg1];
+			else
+				STK(target) = _null_;
+		}
+	}
+
+	while (last_top >= _top) _stack[last_top--].Null();
+	assert(oldstackbase >= _stackbase); 
+	return broot?true:false;
+}
+
+#define _RET_ON_FAIL(exp) { if(!exp) return false; }
+
+bool SQVM::LOCAL_INC(SQInteger op,SQObjectPtr &target, SQObjectPtr &a, SQObjectPtr &incr)
+{
+	_RET_ON_FAIL(ARITH_OP( op , target, a, incr));
+	a = target;
+	return true;
+}
+
+bool SQVM::PLOCAL_INC(SQInteger op,SQObjectPtr &target, SQObjectPtr &a, SQObjectPtr &incr)
+{
+ 	SQObjectPtr trg;
+	_RET_ON_FAIL(ARITH_OP( op , trg, a, incr));
+	target = a;
+	a = trg;
+	return true;
+}
+
+bool SQVM::DerefInc(SQInteger op,SQObjectPtr &target, SQObjectPtr &self, SQObjectPtr &key, SQObjectPtr &incr, bool postfix)
+{
+	SQObjectPtr tmp, tself = self, tkey = key;
+	if (!Get(tself, tkey, tmp, false, true)) { Raise_IdxError(tkey); return false; }
+	_RET_ON_FAIL(ARITH_OP( op , target, tmp, incr))
+	Set(tself, tkey, target,true);
+	if (postfix) target = tmp;
+	return true;
+}
+
+#define arg0 (_i_._arg0)
+#define arg1 (_i_._arg1)
+#define sarg1 (*((SQInt32 *)&_i_._arg1))
+#define arg2 (_i_._arg2)
+#define arg3 (_i_._arg3)
+#define sarg3 ((SQInteger)*((signed char *)&_i_._arg3))
+
+SQRESULT SQVM::Suspend()
+{
+	if (_suspended)
+		return sq_throwerror(this, _SC("cannot suspend an already suspended vm"));
+	if (_nnativecalls!=2)
+		return sq_throwerror(this, _SC("cannot suspend through native calls/metamethods"));
+	return SQ_SUSPEND_FLAG;
+}
+
+void SQVM::PopVarArgs(VarArgs &vargs)
+{
+	for(SQInteger n = 0; n< vargs.size; n++)
+		_vargsstack.pop_back();
+}
+
+#define _FINISH(stoploop) {finished = stoploop; return true; }
+bool SQVM::FOREACH_OP(SQObjectPtr &o1,SQObjectPtr &o2,SQObjectPtr 
+&o3,SQObjectPtr &o4,SQInteger arg_2,bool &finished)
+{
+	SQInteger nrefidx;
+	switch(type(o1)) {
+	case OT_TABLE:
+		if((nrefidx = _table(o1)->Next(false,o4, o2, o3)) == -1) _FINISH(true);
+		o4 = (SQInteger)nrefidx; _FINISH(false);
+	case OT_ARRAY:
+		if((nrefidx = _array(o1)->Next(o4, o2, o3)) == -1) _FINISH(true);
+		o4 = (SQInteger) nrefidx; _FINISH(false);
+	case OT_STRING:
+		if((nrefidx = _string(o1)->Next(o4, o2, o3)) == -1)_FINISH(true);
+		o4 = (SQInteger)nrefidx; _FINISH(false);
+	case OT_CLASS:
+		if((nrefidx = _class(o1)->Next(o4, o2, o3)) == -1)_FINISH(true);
+		o4 = (SQInteger)nrefidx; _FINISH(false);
+	case OT_USERDATA:
+	case OT_INSTANCE:
+		if(_delegable(o1)->_delegate) {
+			SQObjectPtr itr;
+			Push(o1);
+			Push(o4);
+			if(CallMetaMethod(_delegable(o1), MT_NEXTI, 2, itr)){
+				o4 = o2 = itr;
+				if(type(itr) == OT_NULL) _FINISH(true);
+				if(!Get(o1, itr, o3, false,false)) {
+					Raise_Error(_SC("_nexti returned an invalid idx"));
+					return false;
+				}
+				_FINISH(false);
+			}
+			Raise_Error(_SC("_nexti failed"));
+			return false;
+		}
+		break;
+	case OT_GENERATOR:
+		if(_generator(o1)->_state == SQGenerator::eDead) _FINISH(true);
+		if(_generator(o1)->_state == SQGenerator::eSuspended) {
+			SQInteger idx = 0;
+			if(type(o4) == OT_INTEGER) {
+				idx = _integer(o4) + 1;
+			}
+			o2 = idx;
+			o4 = idx;
+			_generator(o1)->Resume(this, arg_2+1);
+			_FINISH(false);
+		}
+	default: 
+		Raise_Error(_SC("cannot iterate %s"), GetTypeName(o1));
+	}
+	return false; //cannot be hit(just to avoid warnings)
+}
+
+bool SQVM::DELEGATE_OP(SQObjectPtr &trg,SQObjectPtr &o1,SQObjectPtr &o2)
+{
+	if(type(o1) != OT_TABLE) { Raise_Error(_SC("delegating a '%s'"), GetTypeName(o1)); return false; }
+	switch(type(o2)) {
+	case OT_TABLE:
+		if(!_table(o1)->SetDelegate(_table(o2))){
+			Raise_Error(_SC("delegate cycle detected"));
+			return false;
+		}
+		break;
+	case OT_NULL:
+		_table(o1)->SetDelegate(NULL);
+		break;
+	default:
+		Raise_Error(_SC("using '%s' as delegate"), GetTypeName(o2));
+		return false;
+		break;
+	}
+	trg = o1;
+	return true;
+}
+#define COND_LITERAL (arg3!=0?(*ci->_literals)[arg1]:STK(arg1))
+
+#define _GUARD(exp) { if(!exp) { Raise_Error(_lasterror); SQ_THROW();} }
+
+#define SQ_THROW() { goto exception_trap; }
+
+bool SQVM::CLOSURE_OP(SQObjectPtr &target, SQFunctionProto *func)
+{
+	SQInteger nouters;
+	SQClosure *closure = SQClosure::Create(_ss(this), func);
+	if((nouters = func->_outervalues.size())) {
+		closure->_outervalues.reserve(nouters);
+		for(SQInteger i = 0; i<nouters; i++) {
+			SQOuterVar &v = func->_outervalues[i];
+			switch(v._type){
+			case otSYMBOL:
+				closure->_outervalues.push_back(_null_);
+				if(!Get(_stack._vals[_stackbase]/*STK(0)*/, v._src, closure->_outervalues.top(), false,true))
+				{Raise_IdxError(v._src); return false; }
+				break;
+			case otLOCAL:
+				closure->_outervalues.push_back(_stack._vals[_stackbase+_integer(v._src)]);
+				break;
+			case otOUTER:
+				closure->_outervalues.push_back(_closure(ci->_closure)->_outervalues[_integer(v._src)]);
+				break;
+			}
+		}
+	}
+	target = closure;
+	return true;
+
+}
+
+bool SQVM::GETVARGV_OP(SQObjectPtr &target,SQObjectPtr &index,CallInfo *ci)
+{
+	if(ci->_vargs.size == 0) {
+		Raise_Error(_SC("the function doesn't have var args"));
+		return false;
+	}
+	if(!sq_isnumeric(index)){
+		Raise_Error(_SC("indexing 'vargv' with %s"),GetTypeName(index));
+		return false;
+	}
+	SQInteger idx = tointeger(index);
+	if(idx < 0 || idx >= ci->_vargs.size){ Raise_Error(_SC("vargv index out of range")); return false; }
+	target = _vargsstack[ci->_vargs.base+idx];
+	return true;
+}
+
+bool SQVM::CLASS_OP(SQObjectPtr &target,SQInteger baseclass,SQInteger attributes)
+{
+	SQClass *base = NULL;
+	SQObjectPtr attrs;
+	if(baseclass != -1) {
+		if(type(_stack._vals[_stackbase+baseclass]) != OT_CLASS) { Raise_Error(_SC("trying to inherit from a %s"),GetTypeName(_stack._vals[_stackbase+baseclass])); return false; }
+		base = _class(_stack._vals[_stackbase + baseclass]);
+	}
+	if(attributes != MAX_FUNC_STACKSIZE) {
+		attrs = _stack._vals[_stackbase+attributes];
+	}
+	target = SQClass::Create(_ss(this),base);
+	if(type(_class(target)->_metamethods[MT_INHERITED]) != OT_NULL) {
+		int nparams = 2;
+		SQObjectPtr ret;
+		Push(target); Push(attrs);
+		Call(_class(target)->_metamethods[MT_INHERITED],nparams,_top - nparams, ret, false);
+		Pop(nparams);
+	}
+	_class(target)->_attributes = attrs;
+	return true;
+}
+
+
+
+bool SQVM::IsEqual(SQObjectPtr &o1,SQObjectPtr &o2,bool &res)
+{
+	if(type(o1) == type(o2)) {
+		res = ((_userpointer(o1) == _userpointer(o2)?true:false));
+	}
+	else {
+		if(sq_isnumeric(o1) && sq_isnumeric(o2)) {
+			SQInteger cmpres;
+			if(!ObjCmp(o1, o2,cmpres)) return false;
+			res = (cmpres == 0);
+		}
+		else {
+			res = false;
+		}
+	}
+	return true;
+}
+
+bool SQVM::IsFalse(SQObjectPtr &o)
+{
+	if((type(o) & SQOBJECT_CANBEFALSE) && ( (type(o) == OT_FLOAT) && (_float(o) == SQFloat(0.0)) )
+		|| (_integer(o) == 0) ) { //OT_NULL|OT_INTEGER|OT_BOOL
+		return true;
+	}
+	return false;
+}
+
+bool SQVM::GETPARENT_OP(SQObjectPtr &o,SQObjectPtr &target)
+{
+	switch(type(o)) {
+		case OT_TABLE: target = _table(o)->_delegate?SQObjectPtr(_table(o)->_delegate):_null_;
+			break;
+		case OT_CLASS: target = _class(o)->_base?_class(o)->_base:_null_;
+			break;
+		default:
+			Raise_Error(_SC("the %s type doesn't have a parent slot"), GetTypeName(o));
+			return false;
+	}
+	return true;
+}
+
+bool SQVM::Execute(SQObjectPtr &closure, SQInteger target, SQInteger nargs, SQInteger stackbase,SQObjectPtr &outres, SQBool raiseerror,ExecutionType et)
+{
+	if ((_nnativecalls + 1) > MAX_NATIVE_CALLS) { Raise_Error(_SC("Native stack overflow")); return false; }
+	_nnativecalls++;
+	AutoDec ad(&_nnativecalls);
+	SQInteger traps = 0;
+	//temp_reg vars for OP_CALL
+	SQInteger ct_target;
+	bool ct_tailcall; 
+
+	switch(et) {
+		case ET_CALL: 
+			if(!StartCall(_closure(closure), _top - nargs, nargs, stackbase, false)) { 
+				//call the handler if there are no calls in the stack, if not relies on the previous node
+				if(ci == NULL) CallErrorHandler(_lasterror);
+				return false;
+			}
+			ci->_root = SQTrue;
+			break;
+		case ET_RESUME_GENERATOR: _generator(closure)->Resume(this, target); ci->_root = SQTrue; traps += ci->_etraps; break;
+		case ET_RESUME_VM:
+			traps = _suspended_traps;
+			ci->_root = _suspended_root;
+			_suspended = SQFalse;
+			break;
+	}
+	
+exception_restore:
+	//
+	{
+		for(;;)
+		{
+			const SQInstruction &_i_ = *ci->_ip++;
+			//dumpstack(_stackbase);
+			//scprintf("\n[%d] %s %d %d %d %d\n",ci->_ip-ci->_iv->_vals,g_InstrDesc[_i_.op].name,arg0,arg1,arg2,arg3);
+			switch(_i_.op)
+			{
+			case _OP_LINE:
+				if(type(_debughook) != OT_NULL && _rawval(_debughook) != _rawval(ci->_closure))
+					CallDebugHook(_SC('l'),arg1);
+				continue;
+			case _OP_LOAD: TARGET = (*ci->_literals)[arg1]; continue;
+			case _OP_LOADINT: TARGET = (SQInteger)arg1; continue;
+			case _OP_DLOAD: TARGET = (*ci->_literals)[arg1]; STK(arg2) = (*ci->_literals)[arg3];continue;
+			case _OP_TAILCALL:
+				temp_reg = STK(arg1);
+				if (type(temp_reg) == OT_CLOSURE){ 
+					ct_tailcall = true;
+					if(ci->_vargs.size) PopVarArgs(ci->_vargs);
+					for (SQInteger i = 0; i < arg3; i++) STK(i) = STK(arg2 + i);
+					ct_target = ci->_target;
+					goto common_call;
+				}
+			case _OP_CALL: {
+					ct_tailcall = false;
+					ct_target = arg0;
+					temp_reg = STK(arg1);
+common_call:
+					SQInteger last_top = _top;
+					switch (type(temp_reg)) {
+					case OT_CLOSURE:{
+						_GUARD(StartCall(_closure(temp_reg), ct_target, arg3, ct_tailcall?_stackbase:_stackbase+arg2, ct_tailcall));
+						if (_funcproto(_closure(temp_reg)->_function)->_bgenerator) {
+							SQGenerator *gen = SQGenerator::Create(_ss(this), _closure(temp_reg));
+							_GUARD(gen->Yield(this));
+							Return(1, ct_target, temp_reg);
+							STK(ct_target) = gen;
+							while (last_top >= _top) _stack[last_top--].Null();
+							continue;
+						}
+						if (type(_debughook) != OT_NULL && _rawval(_debughook) != _rawval(ci->_closure))
+							CallDebugHook(_SC('c'));
+						}
+						break;
+					case OT_NATIVECLOSURE: {
+						bool suspend;
+						_GUARD(CallNative(_nativeclosure(temp_reg), arg3, _stackbase+arg2, ct_tailcall, temp_reg,suspend));
+						if(suspend){
+							_suspended = SQTrue;
+							_suspended_target = ct_target;
+							_suspended_root = ci->_root;
+							_suspended_traps = traps;
+							outres = temp_reg;
+							return true;
+						}
+						if(ct_target != -1) { //skip return value for contructors
+							STK(ct_target) = temp_reg;
+						}
+										   }
+						break;
+					case OT_CLASS:{
+						SQObjectPtr inst;
+						_GUARD(CreateClassInstance(_class(temp_reg),inst,temp_reg));
+						STK(ct_target) = inst;
+						ct_target = -1; //fakes return value target so that is not overwritten by the contructor
+						if(type(temp_reg) != OT_NULL) {
+							_stack[_stackbase+arg2] = inst;
+							goto common_call; //hard core spaghetti code(reissues the OP_CALL to invoke the contructor)
+						}
+						}
+						break;
+					case OT_TABLE:
+					case OT_USERDATA:
+					case OT_INSTANCE:
+						{
+						Push(temp_reg);
+						for (SQInteger i = 0; i < arg3; i++) Push(STK(arg2 + i));
+						if (_delegable(temp_reg) && CallMetaMethod(_delegable(temp_reg), MT_CALL, arg3+1, temp_reg)){
+							STK(ct_target) = temp_reg;
+							break;
+						}
+						Raise_Error(_SC("attempt to call '%s'"), GetTypeName(temp_reg));
+						SQ_THROW();
+					  }
+					default:
+						Raise_Error(_SC("attempt to call '%s'"), GetTypeName(temp_reg));
+						SQ_THROW();
+					}
+				}
+				  continue;
+			case _OP_PREPCALL:
+					if (!Get(STK(arg2), STK(arg1), temp_reg, false,true))
+					{ Raise_IdxError(STK(arg1)); SQ_THROW(); }
+					goto common_prepcall;
+			case _OP_PREPCALLK:
+					if (!Get(STK(arg2), (*ci->_literals)[arg1], temp_reg,false,true)) {
+						if(type(STK(arg2)) == OT_CLASS) { //hack?
+							if(_class_ddel->Get((*ci->_literals)[arg1],temp_reg)) {
+								STK(arg3) = STK(arg2);
+								TARGET = temp_reg;
+								continue;
+							}
+						}
+						{ Raise_IdxError((*ci->_literals)[arg1]); SQ_THROW();}
+					}
+common_prepcall:
+					if(type(STK(arg2)) == OT_CLASS) {
+						STK(arg3) = STK(0); // this
+					}
+					else {
+						STK(arg3) = STK(arg2);
+					}
+					TARGET = temp_reg;
+				continue;
+			case _OP_GETK:
+				if (!Get(STK(arg2), (*ci->_literals)[arg1], temp_reg, false,true)) { Raise_IdxError((*ci->_literals)[arg1]); SQ_THROW();}
+				TARGET = temp_reg;
+				continue;
+			case _OP_MOVE: TARGET = STK(arg1); continue;
+			case _OP_NEWSLOT:
+				_GUARD(NewSlot(STK(arg1), STK(arg2), STK(arg3),false));
+				if(arg0 != arg3) TARGET = STK(arg3);
+				continue;
+			case _OP_DELETE: _GUARD(DeleteSlot(STK(arg1), STK(arg2), TARGET)); continue;
+			case _OP_SET:
+				if (!Set(STK(arg1), STK(arg2), STK(arg3),true)) { Raise_IdxError(STK(arg2)); SQ_THROW(); }
+				if (arg0 != arg3) TARGET = STK(arg3);
+				continue;
+			case _OP_GET:
+				if (!Get(STK(arg1), STK(arg2), temp_reg, false,true)) { Raise_IdxError(STK(arg2)); SQ_THROW(); }
+				TARGET = temp_reg;
+				continue;
+			case _OP_EQ:{
+				bool res;
+				if(!IsEqual(STK(arg2),COND_LITERAL,res)) { SQ_THROW(); }
+				TARGET = res?_true_:_false_;
+				}continue;
+			case _OP_NE:{ 
+				bool res;
+				if(!IsEqual(STK(arg2),COND_LITERAL,res)) { SQ_THROW(); }
+				TARGET = (!res)?_true_:_false_;
+				} continue;
+			case _OP_ARITH: _GUARD(ARITH_OP( arg3 , temp_reg, STK(arg2), STK(arg1))); TARGET = temp_reg; continue;
+			case _OP_BITW:	_GUARD(BW_OP( arg3,TARGET,STK(arg2),STK(arg1))); continue;
+			case _OP_RETURN:
+				if(type((ci)->_generator) == OT_GENERATOR) {
+					_generator((ci)->_generator)->Kill();
+				}
+				if(Return(arg0, arg1, temp_reg)){
+					assert(traps==0);
+					outres = temp_reg;
+					return true;
+				}
+				continue;
+			case _OP_LOADNULLS:{ for(SQInt32 n=0; n < arg1; n++) STK(arg0+n) = _null_; }continue;
+			case _OP_LOADROOTTABLE:	TARGET = _roottable; continue;
+			case _OP_LOADBOOL: TARGET = arg1?_true_:_false_; continue;
+			case _OP_DMOVE: STK(arg0) = STK(arg1); STK(arg2) = STK(arg3); continue;
+			case _OP_JMP: ci->_ip += (sarg1); continue;
+			case _OP_JNZ: if(!IsFalse(STK(arg0))) ci->_ip+=(sarg1); continue;
+			case _OP_JZ: if(IsFalse(STK(arg0))) ci->_ip+=(sarg1); continue;
+			case _OP_LOADFREEVAR: TARGET = _closure(ci->_closure)->_outervalues[arg1]; continue;
+			case _OP_VARGC: TARGET = SQInteger(ci->_vargs.size); continue;
+			case _OP_GETVARGV: 
+				if(!GETVARGV_OP(TARGET,STK(arg1),ci)) { SQ_THROW(); } 
+				continue;
+			case _OP_NEWTABLE: TARGET = SQTable::Create(_ss(this), arg1); continue;
+			case _OP_NEWARRAY: TARGET = SQArray::Create(_ss(this), 0); _array(TARGET)->Reserve(arg1); continue;
+			case _OP_APPENDARRAY: _array(STK(arg0))->Append(COND_LITERAL);	continue;
+			case _OP_GETPARENT: _GUARD(GETPARENT_OP(STK(arg1),TARGET)); continue;
+			case _OP_COMPARITH: _GUARD(DerefInc(arg3, TARGET, STK((((SQUnsignedInteger)arg1&0xFFFF0000)>>16)), STK(arg2), STK(arg1&0x0000FFFF), false)); continue;
+			case _OP_COMPARITHL: _GUARD(LOCAL_INC(arg3, TARGET, STK(arg1), STK(arg2))); continue;
+			case _OP_INC: {SQObjectPtr o(sarg3); _GUARD(DerefInc('+',TARGET, STK(arg1), STK(arg2), o, false));} continue;
+			case _OP_INCL: {SQObjectPtr o(sarg3); _GUARD(LOCAL_INC('+',TARGET, STK(arg1), o));} continue;
+			case _OP_PINC: {SQObjectPtr o(sarg3); _GUARD(DerefInc('+',TARGET, STK(arg1), STK(arg2), o, true));} continue;
+			case _OP_PINCL:	{SQObjectPtr o(sarg3); _GUARD(PLOCAL_INC('+',TARGET, STK(arg1), o));} continue;
+			case _OP_CMP:	_GUARD(CMP_OP((CmpOP)arg3,STK(arg2),STK(arg1),TARGET))	continue;
+			case _OP_EXISTS: TARGET = Get(STK(arg1), STK(arg2), temp_reg, true,false)?_true_:_false_;continue;
+			case _OP_INSTANCEOF: 
+				if(type(STK(arg1)) != OT_CLASS || type(STK(arg2)) != OT_INSTANCE)
+				{Raise_Error(_SC("cannot apply instanceof between a %s and a %s"),GetTypeName(STK(arg1)),GetTypeName(STK(arg2))); SQ_THROW();}
+				TARGET = _instance(STK(arg2))->InstanceOf(_class(STK(arg1)))?_true_:_false_;
+				continue;
+			case _OP_AND: 
+				if(IsFalse(STK(arg2))) {
+					TARGET = STK(arg2);
+					ci->_ip += (sarg1);
+				}
+				continue;
+			case _OP_OR:
+				if(!IsFalse(STK(arg2))) {
+					TARGET = STK(arg2);
+					ci->_ip += (sarg1);
+				}
+				continue;
+			case _OP_NEG: _GUARD(NEG_OP(TARGET,STK(arg1))); continue;
+			case _OP_NOT: TARGET = (IsFalse(STK(arg1))?_true_:_false_); continue;
+			case _OP_BWNOT:
+				if(type(STK(arg1)) == OT_INTEGER) {
+					SQInteger t = _integer(STK(arg1));
+					TARGET = SQInteger(~t);
+					continue;
+				}
+				Raise_Error(_SC("attempt to perform a bitwise op on a %s"), GetTypeName(STK(arg1)));
+				SQ_THROW();
+			case _OP_CLOSURE: {
+				SQClosure *c = ci->_closure._unVal.pClosure;
+				SQFunctionProto *fp = c->_function._unVal.pFunctionProto;
+				if(!CLOSURE_OP(TARGET,fp->_functions[arg1]._unVal.pFunctionProto)) { SQ_THROW(); }
+				continue;
+			}
+			case _OP_YIELD:{
+				if(type(ci->_generator) == OT_GENERATOR) {
+					if(sarg1 != MAX_FUNC_STACKSIZE) temp_reg = STK(arg1);
+					_GUARD(_generator(ci->_generator)->Yield(this));
+					traps -= ci->_etraps;
+					if(sarg1 != MAX_FUNC_STACKSIZE) STK(arg1) = temp_reg;
+				}
+				else { Raise_Error(_SC("trying to yield a '%s',only genenerator can be yielded"), GetTypeName(ci->_generator)); SQ_THROW();}
+				if(Return(arg0, arg1, temp_reg)){
+					assert(traps == 0);
+					outres = temp_reg;
+					return true;
+				}
+					
+				}
+				continue;
+			case _OP_RESUME:
+				if(type(STK(arg1)) != OT_GENERATOR){ Raise_Error(_SC("trying to resume a '%s',only genenerator can be resumed"), GetTypeName(STK(arg1))); SQ_THROW();}
+				_GUARD(_generator(STK(arg1))->Resume(this, arg0));
+				traps += ci->_etraps;
+                continue;
+			case _OP_FOREACH:{ bool finished;
+				_GUARD(FOREACH_OP(STK(arg0),STK(arg2),STK(arg2+1),STK(arg2+2),arg2,finished));
+				if(finished) ci->_ip += sarg1; }
+				continue;
+			case _OP_DELEGATE: _GUARD(DELEGATE_OP(TARGET,STK(arg1),STK(arg2))); continue;
+			case _OP_CLONE:
+				if(!Clone(STK(arg1), TARGET))
+				{ Raise_Error(_SC("cloning a %s"), GetTypeName(STK(arg1))); SQ_THROW();}
+				continue;
+			case _OP_TYPEOF: TypeOf(STK(arg1), TARGET); continue;
+			case _OP_PUSHTRAP:
+				_etraps.push_back(SQExceptionTrap(_top,_stackbase, &ci->_iv->_vals[(ci->_ip-ci->_iv->_vals)+arg1], arg0)); traps++;
+				ci->_etraps++;
+				continue;
+			case _OP_POPTRAP:
+				for(SQInteger i = 0; i < arg0; i++) {
+					_etraps.pop_back(); traps--;
+					ci->_etraps--;
+				}
+				continue;
+			case _OP_THROW:	Raise_Error(TARGET); SQ_THROW(); continue;
+			case _OP_CLASS: _GUARD(CLASS_OP(TARGET,arg1,arg2)); continue;
+			case _OP_NEWSLOTA:
+				bool bstatic = (arg0&NEW_SLOT_STATIC_FLAG)?true:false;
+				if(type(STK(arg1)) == OT_CLASS) {
+					if(type(_class(STK(arg1))->_metamethods[MT_NEWMEMBER]) != OT_NULL ) {
+						Push(STK(arg1)); Push(STK(arg2)); Push(STK(arg3));
+						Push((arg0&NEW_SLOT_ATTRIBUTES_FLAG) ? STK(arg2-1) : _null_);
+						int nparams = 4;
+						if(Call(_class(STK(arg1))->_metamethods[MT_NEWMEMBER], nparams, _top - nparams, temp_reg,SQFalse)) {
+							Pop(nparams);
+							continue;
+						}
+					}
+				}
+				_GUARD(NewSlot(STK(arg1), STK(arg2), STK(arg3),bstatic));
+				if((arg0&NEW_SLOT_ATTRIBUTES_FLAG)) {
+					_class(STK(arg1))->SetAttributes(STK(arg2),STK(arg2-1));
+				}
+				continue;
+			}
+			
+		}
+	}
+exception_trap:
+	{
+		SQObjectPtr currerror = _lasterror;
+//		dumpstack(_stackbase);
+		SQInteger n = 0;
+		SQInteger last_top = _top;
+		if(ci) {
+			if(_ss(this)->_notifyallexceptions) CallErrorHandler(currerror);
+
+			if(traps) {
+				do {
+					if(ci->_etraps > 0) {
+						SQExceptionTrap &et = _etraps.top();
+						ci->_ip = et._ip;
+						_top = et._stacksize;
+						_stackbase = et._stackbase;
+						_stack[_stackbase+et._extarget] = currerror;
+						_etraps.pop_back(); traps--; ci->_etraps--;
+						while(last_top >= _top) _stack[last_top--].Null();
+						goto exception_restore;
+					}
+					//if is a native closure
+					if(type(ci->_closure) != OT_CLOSURE && n)
+						break;
+					if(type(ci->_generator) == OT_GENERATOR) _generator(ci->_generator)->Kill();
+					PopVarArgs(ci->_vargs);
+					POP_CALLINFO(this);
+					n++;
+				} while(_callsstack.size());
+			}
+			else {
+				//call the hook
+				if(raiseerror && !_ss(this)->_notifyallexceptions)
+					CallErrorHandler(currerror);
+			}
+			//remove call stack until a C function is found or the cstack is empty
+			if(ci) do {
+				SQBool exitafterthisone = ci->_root;
+				if(type(ci->_generator) == OT_GENERATOR) _generator(ci->_generator)->Kill();
+				_stackbase -= ci->_prevstkbase;
+				_top = _stackbase + ci->_prevtop;
+				PopVarArgs(ci->_vargs);
+				POP_CALLINFO(this);
+				if( (ci && type(ci->_closure) != OT_CLOSURE) || exitafterthisone) break;
+			} while(_callsstack.size());
+
+			while(last_top >= _top) _stack[last_top--].Null();
+		}
+		_lasterror = currerror;
+		return false;
+	}
+	assert(0);
+}
+
+bool SQVM::CreateClassInstance(SQClass *theclass, SQObjectPtr &inst, SQObjectPtr &constructor)
+{
+	inst = theclass->CreateInstance();
+	if(!theclass->Get(_ss(this)->_constructoridx,constructor)) {
+		//if(!Call(constr,nargs,stackbase,constr,false))
+		//	return false;
+		constructor = _null_;
+	}
+	return true;
+}
+
+void SQVM::CallErrorHandler(SQObjectPtr &error)
+{
+	if(type(_errorhandler) != OT_NULL) {
+		SQObjectPtr out;
+		Push(_roottable); Push(error);
+		Call(_errorhandler, 2, _top-2, out,SQFalse);
+		Pop(2);
+	}
+}
+
+void SQVM::CallDebugHook(SQInteger type,SQInteger forcedline)
+{
+	SQObjectPtr temp_reg;
+	SQInteger nparams=5;
+	SQFunctionProto *func=_funcproto(_closure(ci->_closure)->_function);
+	Push(_roottable); Push(type); Push(func->_sourcename); Push(forcedline?forcedline:func->GetLine(ci->_ip)); Push(func->_name);
+	Call(_debughook,nparams,_top-nparams,temp_reg,SQFalse);
+	Pop(nparams);
+}
+
+bool SQVM::CallNative(SQNativeClosure *nclosure,SQInteger nargs,SQInteger stackbase,bool tailcall,SQObjectPtr &retval,bool &suspend)
+{
+	if (_nnativecalls + 1 > MAX_NATIVE_CALLS) { Raise_Error(_SC("Native stack overflow")); return false; }
+	SQInteger nparamscheck = nclosure->_nparamscheck;
+	if(((nparamscheck > 0) && (nparamscheck != nargs))
+		|| ((nparamscheck < 0) && (nargs < (-nparamscheck)))) {
+		Raise_Error(_SC("wrong number of parameters"));
+		return false;
+		}
+
+	SQInteger tcs;
+	if((tcs = nclosure->_typecheck.size())) {
+		for(SQInteger i = 0; i < nargs && i < tcs; i++)
+			if((nclosure->_typecheck[i] != -1) && !(type(_stack[stackbase+i]) & nclosure->_typecheck[i])) {
+                Raise_ParamTypeError(i,nclosure->_typecheck[i],type(_stack[stackbase+i]));
+				return false;
+			}
+	}
+	_nnativecalls++;
+	if ((_top + MIN_STACK_OVERHEAD) > (SQInteger)_stack.size()) {
+		_stack.resize(_stack.size() + (MIN_STACK_OVERHEAD<<1));
+	}
+	SQInteger oldtop = _top;
+	SQInteger oldstackbase = _stackbase;
+	_top = stackbase + nargs;
+	PUSH_CALLINFO(this, CallInfo());
+	ci->_etraps = 0;
+	ci->_closure._unVal.pNativeClosure = nclosure;
+	ci->_closure._type = OT_NATIVECLOSURE;
+	ci->_prevstkbase = stackbase - _stackbase;
+	ci->_ncalls = 1;
+	_stackbase = stackbase;
+	//push free variables
+	SQInteger outers = nclosure->_outervalues.size();
+	for (SQInteger i = 0; i < outers; i++) {
+		Push(nclosure->_outervalues[i]);
+	}
+
+	if(type(nclosure->_env) == OT_WEAKREF) {
+		_stack[stackbase] = _weakref(nclosure->_env)->_obj;
+	}
+
+	ci->_prevtop = (oldtop - oldstackbase);
+	SQInteger ret = (nclosure->_function)(this);
+	_nnativecalls--;
+	suspend = false;
+	if( ret == SQ_SUSPEND_FLAG) suspend = true;
+	else if (ret < 0) { 
+		_stackbase = oldstackbase;
+		_top = oldtop;
+		POP_CALLINFO(this);
+		Raise_Error(_lasterror);
+		return false;
+	}
+	
+	if (ret != 0){ retval = TOP(); }
+	else { retval = _null_; }
+	_stackbase = oldstackbase;
+	_top = oldtop;
+	POP_CALLINFO(this);
+	return true;
+}
+
+bool SQVM::Get(const SQObjectPtr &self,const SQObjectPtr &key,SQObjectPtr &dest,bool raw, bool fetchroot)
+{
+	switch(type(self)){
+	case OT_TABLE:
+		if(_table(self)->Get(key,dest))return true;
+		break;
+	case OT_ARRAY:
+		if(sq_isnumeric(key)){
+			return _array(self)->Get(tointeger(key),dest);
+		}
+		break;
+	case OT_INSTANCE:
+		if(_instance(self)->Get(key,dest)) return true;
+		break;
+	default:break; //shut up compiler
+	}
+	if(FallBackGet(self,key,dest,raw)) return true;
+
+	if(fetchroot) {
+		if(_rawval(STK(0)) == _rawval(self) &&
+			type(STK(0)) == type(self)) {
+				return _table(_roottable)->Get(key,dest);
+		}
+	}
+	return false;
+}
+
+bool SQVM::FallBackGet(const SQObjectPtr &self,const SQObjectPtr &key,SQObjectPtr &dest,bool raw)
+{
+	switch(type(self)){
+	case OT_CLASS: 
+		return _class(self)->Get(key,dest);
+		break;
+	case OT_TABLE:
+	case OT_USERDATA:
+        //delegation
+		if(_delegable(self)->_delegate) {
+			if(Get(SQObjectPtr(_delegable(self)->_delegate),key,dest,raw,false))
+				return true;	
+			if(raw)return false;
+			Push(self);Push(key);
+			if(CallMetaMethod(_delegable(self),MT_GET,2,dest))
+				return true;
+		}
+		if(type(self) == OT_TABLE) {
+			if(raw) return false;
+			return _table_ddel->Get(key,dest);
+		}
+		return false;
+		break;
+	case OT_ARRAY:
+		if(raw)return false;
+		return _array_ddel->Get(key,dest);
+	case OT_STRING:
+		if(sq_isnumeric(key)){
+			SQInteger n=tointeger(key);
+			if(abs((int)n)<_string(self)->_len){
+				if(n<0)n=_string(self)->_len-n;
+				dest=SQInteger(_stringval(self)[n]);
+				return true;
+			}
+			return false;
+		}
+		else {
+			if(raw)return false;
+			return _string_ddel->Get(key,dest);
+		}
+		break;
+	case OT_INSTANCE:
+		if(raw)return false;
+		Push(self);Push(key);
+		if(!CallMetaMethod(_delegable(self),MT_GET,2,dest)) {
+			return _instance_ddel->Get(key,dest);
+		}
+		return true;
+	case OT_INTEGER:case OT_FLOAT:case OT_BOOL: 
+		if(raw)return false;
+		return _number_ddel->Get(key,dest);
+	case OT_GENERATOR: 
+		if(raw)return false;
+		return _generator_ddel->Get(key,dest);
+	case OT_CLOSURE: case OT_NATIVECLOSURE:	
+		if(raw)return false;
+		return _closure_ddel->Get(key,dest);
+	case OT_THREAD:
+		if(raw)return false;
+		return  _thread_ddel->Get(key,dest);
+	case OT_WEAKREF:
+		if(raw)return false;
+		return  _weakref_ddel->Get(key,dest);
+	default:return false;
+	}
+	return false;
+}
+
+bool SQVM::Set(const SQObjectPtr &self,const SQObjectPtr &key,const SQObjectPtr &val,bool fetchroot)
+{
+	switch(type(self)){
+	case OT_TABLE:
+		if(_table(self)->Set(key,val))
+			return true;
+		if(_table(self)->_delegate) {
+			if(Set(_table(self)->_delegate,key,val,false)) {
+				return true;
+			}
+		}
+		//keeps going
+	case OT_USERDATA:
+		if(_delegable(self)->_delegate) {
+			SQObjectPtr t;
+			Push(self);Push(key);Push(val);
+			if(CallMetaMethod(_delegable(self),MT_SET,3,t)) return true;
+		}
+		break;
+	case OT_INSTANCE:{
+		if(_instance(self)->Set(key,val))
+			return true;
+		SQObjectPtr t;
+		Push(self);Push(key);Push(val);
+		if(CallMetaMethod(_delegable(self),MT_SET,3,t)) return true;
+		}
+		break;
+	case OT_ARRAY:
+		if(!sq_isnumeric(key)) {Raise_Error(_SC("indexing %s with %s"),GetTypeName(self),GetTypeName(key)); return false; }
+		return _array(self)->Set(tointeger(key),val);
+	default:
+		Raise_Error(_SC("trying to set '%s'"),GetTypeName(self));
+		return false;
+	}
+	if(fetchroot) {
+		if(_rawval(STK(0)) == _rawval(self) &&
+			type(STK(0)) == type(self)) {
+				return _table(_roottable)->Set(key,val);
+			}
+	}
+	return false;
+}
+
+bool SQVM::Clone(const SQObjectPtr &self,SQObjectPtr &target)
+{
+	SQObjectPtr temp_reg;
+	SQObjectPtr newobj;
+	switch(type(self)){
+	case OT_TABLE:
+		newobj = _table(self)->Clone();
+		goto cloned_mt;
+	case OT_INSTANCE:
+		newobj = _instance(self)->Clone(_ss(this));
+cloned_mt:
+		if(_delegable(newobj)->_delegate){
+			Push(newobj);
+			Push(self);
+			CallMetaMethod(_delegable(newobj),MT_CLONED,2,temp_reg);
+		}
+		target = newobj;
+		return true;
+	case OT_ARRAY: 
+		target = _array(self)->Clone();
+		return true;
+	default: return false;
+	}
+}
+
+bool SQVM::NewSlot(const SQObjectPtr &self,const SQObjectPtr &key,const SQObjectPtr &val,bool bstatic)
+{
+	if(type(key) == OT_NULL) { Raise_Error(_SC("null cannot be used as index")); return false; }
+	switch(type(self)) {
+	case OT_TABLE: {
+		bool rawcall = true;
+		if(_table(self)->_delegate) {
+			SQObjectPtr res;
+			if(!_table(self)->Get(key,res)) {
+				Push(self);Push(key);Push(val);
+				rawcall = !CallMetaMethod(_table(self),MT_NEWSLOT,3,res);
+			}
+		}
+		if(rawcall) _table(self)->NewSlot(key,val); //cannot fail
+		
+		break;}
+	case OT_CLASS: 
+		if(!_class(self)->NewSlot(_ss(this),key,val,bstatic)) {
+			if(_class(self)->_locked) {
+				Raise_Error(_SC("trying to modify a class that has already been instantiated"));
+				return false;
+			}
+			else {
+				SQObjectPtr oval = PrintObjVal(key);
+				Raise_Error(_SC("the property '%s' already exists"),_stringval(oval));
+				return false;
+			}
+		}
+		break;
+	default:
+		Raise_Error(_SC("indexing %s with %s"),GetTypeName(self),GetTypeName(key));
+		return false;
+		break;
+	}
+	return true;
+}
+
+bool SQVM::DeleteSlot(const SQObjectPtr &self,const SQObjectPtr &key,SQObjectPtr &res)
+{
+	switch(type(self)) {
+	case OT_TABLE:
+	case OT_INSTANCE:
+	case OT_USERDATA: {
+		SQObjectPtr t;
+		bool handled = false;
+		if(_delegable(self)->_delegate) {
+			Push(self);Push(key);
+			handled = CallMetaMethod(_delegable(self),MT_DELSLOT,2,t);
+		}
+
+		if(!handled) {
+			if(type(self) == OT_TABLE) {
+				if(_table(self)->Get(key,t)) {
+					_table(self)->Remove(key);
+				}
+				else {
+					Raise_IdxError((SQObject &)key);
+					return false;
+				}
+			}
+			else {
+				Raise_Error(_SC("cannot delete a slot from %s"),GetTypeName(self));
+				return false;
+			}
+		}
+		res = t;
+				}
+		break;
+	default:
+		Raise_Error(_SC("attempt to delete a slot from a %s"),GetTypeName(self));
+		return false;
+	}
+	return true;
+}
+
+bool SQVM::Call(SQObjectPtr &closure,SQInteger nparams,SQInteger stackbase,SQObjectPtr &outres,SQBool raiseerror)
+{
+#ifdef _DEBUG
+SQInteger prevstackbase = _stackbase;
+#endif
+	switch(type(closure)) {
+	case OT_CLOSURE:
+		return Execute(closure, _top - nparams, nparams, stackbase,outres,raiseerror);
+		break;
+	case OT_NATIVECLOSURE:{
+		bool suspend;
+		return CallNative(_nativeclosure(closure), nparams, stackbase, false, outres,suspend);
+		
+						  }
+		break;
+	case OT_CLASS: {
+		SQObjectPtr constr;
+		SQObjectPtr temp;
+		CreateClassInstance(_class(closure),outres,constr);
+		if(type(constr) != OT_NULL) {
+			_stack[stackbase] = outres;
+			return Call(constr,nparams,stackbase,temp,raiseerror);
+		}
+		return true;
+				   }
+		break;
+	default:
+		return false;
+	}
+#ifdef _DEBUG
+	if(!_suspended) {
+		assert(_stackbase == prevstackbase);
+	}
+#endif
+	return true;
+}
+
+bool SQVM::CallMetaMethod(SQDelegable *del,SQMetaMethod mm,SQInteger nparams,SQObjectPtr &outres)
+{
+	SQObjectPtr closure;
+	if(del->GetMetaMethod(this, mm, closure)) {
+		if(Call(closure, nparams, _top - nparams, outres, SQFalse)) {
+			Pop(nparams);
+			return true;
+		}
+	}
+	Pop(nparams);
+	return false;
+}
+
+void SQVM::Remove(SQInteger n) {
+	n = (n >= 0)?n + _stackbase - 1:_top + n;
+	for(SQInteger i = n; i < _top; i++){
+		_stack[i] = _stack[i+1];
+	}
+	_stack[_top] = _null_;
+	_top--;
+}
+
+void SQVM::Pop() {
+	_stack[--_top] = _null_;
+}
+
+void SQVM::Pop(SQInteger n) {
+	for(SQInteger i = 0; i < n; i++){
+		_stack[--_top] = _null_;
+	}
+}
+
+void SQVM::Push(const SQObjectPtr &o) { _stack[_top++] = o; }
+SQObjectPtr &SQVM::Top() { return _stack[_top-1]; }
+SQObjectPtr &SQVM::PopGet() { return _stack[--_top]; }
+SQObjectPtr &SQVM::GetUp(SQInteger n) { return _stack[_top+n]; }
+SQObjectPtr &SQVM::GetAt(SQInteger n) { return _stack[n]; }
+
+#ifdef _DEBUG_DUMP
+void SQVM::dumpstack(SQInteger stackbase,bool dumpall)
+{
+	SQInteger size=dumpall?_stack.size():_top;
+	SQInteger n=0;
+	scprintf(_SC("\n>>>>stack dump<<<<\n"));
+	CallInfo &ci=_callsstack.back();
+	scprintf(_SC("IP: %p\n"),ci._ip);
+	scprintf(_SC("prev stack base: %d\n"),ci._prevstkbase);
+	scprintf(_SC("prev top: %d\n"),ci._prevtop);
+	for(SQInteger i=0;i<size;i++){
+		SQObjectPtr &obj=_stack[i];	
+		if(stackbase==i)scprintf(_SC(">"));else scprintf(_SC(" "));
+		scprintf(_SC("[%d]:"),n);
+		switch(type(obj)){
+		case OT_FLOAT:			scprintf(_SC("FLOAT %.3f"),_float(obj));break;
+		case OT_INTEGER:		scprintf(_SC("INTEGER %d"),_integer(obj));break;
+		case OT_BOOL:			scprintf(_SC("BOOL %s"),_integer(obj)?"true":"false");break;
+		case OT_STRING:			scprintf(_SC("STRING %s"),_stringval(obj));break;
+		case OT_NULL:			scprintf(_SC("NULL"));	break;
+		case OT_TABLE:			scprintf(_SC("TABLE %p[%p]"),_table(obj),_table(obj)->_delegate);break;
+		case OT_ARRAY:			scprintf(_SC("ARRAY %p"),_array(obj));break;
+		case OT_CLOSURE:		scprintf(_SC("CLOSURE [%p]"),_closure(obj));break;
+		case OT_NATIVECLOSURE:	scprintf(_SC("NATIVECLOSURE"));break;
+		case OT_USERDATA:		scprintf(_SC("USERDATA %p[%p]"),_userdataval(obj),_userdata(obj)->_delegate);break;
+		case OT_GENERATOR:		scprintf(_SC("GENERATOR"));break;
+		case OT_THREAD:			scprintf(_SC("THREAD [%p]"),_thread(obj));break;
+		case OT_USERPOINTER:	scprintf(_SC("USERPOINTER %p"),_userpointer(obj));break;
+		case OT_CLASS:			scprintf(_SC("CLASS %p"),_class(obj));break;
+		case OT_INSTANCE:		scprintf(_SC("INSTANCE %p"),_instance(obj));break;
+		case OT_WEAKREF:		scprintf(_SC("WEAKERF %p"),_weakref(obj));break;
+		default:
+			assert(0);
+			break;
+		};
+		scprintf(_SC("\n"));
+		++n;
+	}
+}
+
+
+
+#endif
diff -rupwN ../dnl3/SqPlus/_squirrel/sqvm.h SqPlus/_squirrel/sqvm.h
--- ../dnl3/SqPlus/_squirrel/sqvm.h	1969-12-31 19:00:00.000000000 -0500
+++ SqPlus/_squirrel/sqvm.h	2006-03-19 14:32:58.000000000 -0500
@@ -0,0 +1,190 @@
+/*	see copyright notice in squirrel.h */
+#ifndef _SQVM_H_
+#define _SQVM_H_
+
+#include "sqopcodes.h"
+#include "sqobject.h"
+#define MAX_NATIVE_CALLS 100
+#define MIN_STACK_OVERHEAD 10
+
+#define SQ_SUSPEND_FLAG -666
+//base lib
+void sq_base_register(HSQUIRRELVM v);
+
+struct SQExceptionTrap{
+	SQExceptionTrap() {}
+	SQExceptionTrap(SQInteger ss, SQInteger stackbase,SQInstruction *ip, SQInteger ex_target){ _stacksize = ss; _stackbase = stackbase; _ip = ip; _extarget = ex_target;}
+	SQExceptionTrap(const SQExceptionTrap &et) { (*this) = et;	}
+	SQInteger _stackbase;
+	SQInteger _stacksize;
+	SQInstruction *_ip;
+	SQInteger _extarget;
+};
+
+#define _INLINE 
+
+#define STK(a) _stack._vals[_stackbase+(a)]
+#define TARGET _stack._vals[_stackbase+arg0]
+
+typedef sqvector<SQExceptionTrap> ExceptionsTraps;
+
+struct SQVM : public CHAINABLE_OBJ
+{
+	struct VarArgs {
+		VarArgs() { size = 0; base = 0; }
+		SQInteger size;
+		SQInteger base;
+	};
+
+	struct CallInfo{
+		CallInfo() { _generator._type = OT_NULL;}
+		//CallInfo(const CallInfo& ci) {  }
+		SQInstructionVec *_iv;
+		SQObjectPtrVec *_literals;
+		SQObject _closure;
+		SQObject _generator;
+		SQInteger _etraps;
+		SQInteger _prevstkbase;
+		SQInteger _prevtop;
+		SQInteger _target;
+		SQInstruction *_ip;
+		SQInteger _ncalls;
+		SQBool _root;
+		VarArgs _vargs;
+	};
+	
+typedef sqvector<CallInfo> CallInfoVec;
+public:
+	enum ExecutionType { ET_CALL, ET_RESUME_GENERATOR, ET_RESUME_VM };
+	SQVM(SQSharedState *ss);
+	~SQVM();
+	bool Init(SQVM *friendvm, SQInteger stacksize);
+	bool Execute(SQObjectPtr &func, SQInteger target, SQInteger nargs, SQInteger stackbase, SQObjectPtr &outres, SQBool raiseerror, ExecutionType et = ET_CALL);
+	//starts a native call return when the NATIVE closure returns
+	bool CallNative(SQNativeClosure *nclosure, SQInteger nargs, SQInteger stackbase, bool tailcall, SQObjectPtr &retval,bool &suspend);
+	//starts a SQUIRREL call in the same "Execution loop"
+	bool StartCall(SQClosure *closure, SQInteger target, SQInteger nargs, SQInteger stackbase, bool tailcall);
+	bool CreateClassInstance(SQClass *theclass, SQObjectPtr &inst, SQObjectPtr &constructor);
+	//call a generic closure pure SQUIRREL or NATIVE
+	bool Call(SQObjectPtr &closure, SQInteger nparams, SQInteger stackbase, SQObjectPtr &outres,SQBool raiseerror);
+	SQRESULT Suspend();
+
+	void CallDebugHook(SQInteger type,SQInteger forcedline=0);
+	void CallErrorHandler(SQObjectPtr &e);
+	bool Get(const SQObjectPtr &self, const SQObjectPtr &key, SQObjectPtr &dest, bool raw, bool fetchroot);
+	bool FallBackGet(const SQObjectPtr &self,const SQObjectPtr &key,SQObjectPtr &dest,bool raw);
+	bool Set(const SQObjectPtr &self, const SQObjectPtr &key, const SQObjectPtr &val, bool fetchroot);
+	bool NewSlot(const SQObjectPtr &self, const SQObjectPtr &key, const SQObjectPtr &val,bool bstatic);
+	bool DeleteSlot(const SQObjectPtr &self, const SQObjectPtr &key, SQObjectPtr &res);
+	bool Clone(const SQObjectPtr &self, SQObjectPtr &target);
+	bool ObjCmp(const SQObjectPtr &o1, const SQObjectPtr &o2,SQInteger &res);
+	bool StringCat(const SQObjectPtr &str, const SQObjectPtr &obj, SQObjectPtr &dest);
+	bool IsEqual(SQObjectPtr &o1,SQObjectPtr &o2,bool &res);
+	void ToString(const SQObjectPtr &o,SQObjectPtr &res);
+	SQString *PrintObjVal(const SQObject &o);
+
+ 
+	void Raise_Error(const SQChar *s, ...);
+	void Raise_Error(SQObjectPtr &desc);
+	void Raise_IdxError(SQObject &o);
+	void Raise_CompareError(const SQObject &o1, const SQObject &o2);
+	void Raise_ParamTypeError(SQInteger nparam,SQInteger typemask,SQInteger type);
+
+	void TypeOf(const SQObjectPtr &obj1, SQObjectPtr &dest);
+	bool CallMetaMethod(SQDelegable *del, SQMetaMethod mm, SQInteger nparams, SQObjectPtr &outres);
+	bool ArithMetaMethod(SQInteger op, const SQObjectPtr &o1, const SQObjectPtr &o2, SQObjectPtr &dest);
+	bool Return(SQInteger _arg0, SQInteger _arg1, SQObjectPtr &retval);
+	//new stuff
+	_INLINE bool ARITH_OP(SQUnsignedInteger op,SQObjectPtr &trg,const SQObjectPtr &o1,const SQObjectPtr &o2);
+	_INLINE bool BW_OP(SQUnsignedInteger op,SQObjectPtr &trg,const SQObjectPtr &o1,const SQObjectPtr &o2);
+	_INLINE bool NEG_OP(SQObjectPtr &trg,const SQObjectPtr &o1);
+	_INLINE bool CMP_OP(CmpOP op, const SQObjectPtr &o1,const SQObjectPtr &o2,SQObjectPtr &res);
+	bool CLOSURE_OP(SQObjectPtr &target, SQFunctionProto *func);
+	bool GETVARGV_OP(SQObjectPtr &target,SQObjectPtr &idx,CallInfo *ci);
+	bool CLASS_OP(SQObjectPtr &target,SQInteger base,SQInteger attrs);
+	bool GETPARENT_OP(SQObjectPtr &o,SQObjectPtr &target);
+	//return true if the loop is finished
+	bool FOREACH_OP(SQObjectPtr &o1,SQObjectPtr &o2,SQObjectPtr &o3,SQObjectPtr &o4,SQInteger arg_2,bool &finished);
+	bool DELEGATE_OP(SQObjectPtr &trg,SQObjectPtr &o1,SQObjectPtr &o2);
+	_INLINE bool LOCAL_INC(SQInteger op,SQObjectPtr &target, SQObjectPtr &a, SQObjectPtr &incr);
+	_INLINE bool PLOCAL_INC(SQInteger op,SQObjectPtr &target, SQObjectPtr &a, SQObjectPtr &incr);
+	_INLINE bool DerefInc(SQInteger op,SQObjectPtr &target, SQObjectPtr &self, SQObjectPtr &key, SQObjectPtr &incr, bool postfix);
+	void PopVarArgs(VarArgs &vargs);
+#ifdef _DEBUG_DUMP
+	void dumpstack(SQInteger stackbase=-1, bool dumpall = false);
+#endif
+
+#ifndef NO_GARBAGE_COLLECTOR
+	void Mark(SQCollectable **chain);
+#endif
+	void Finalize();
+
+	void Release(){ sq_delete(this,SQVM); } //does nothing
+////////////////////////////////////////////////////////////////////////////
+	//stack functions for the api
+	void Remove(SQInteger n);
+
+	bool IsFalse(SQObjectPtr &o);
+	
+	void Pop();
+	void Pop(SQInteger n);
+	void Push(const SQObjectPtr &o);
+	SQObjectPtr &Top();
+	SQObjectPtr &PopGet();
+	SQObjectPtr &GetUp(SQInteger n);
+	SQObjectPtr &GetAt(SQInteger n);
+
+	SQObjectPtrVec _stack;
+	SQObjectPtrVec _vargsstack;
+	SQInteger _top;
+	SQInteger _stackbase;
+	SQObjectPtr _roottable;
+	SQObjectPtr _lasterror;
+	SQObjectPtr _errorhandler;
+	SQObjectPtr _debughook;
+
+	SQObjectPtr temp_reg;
+	CallInfoVec _callsstack;
+	ExceptionsTraps _etraps;
+	CallInfo *ci;
+	void *_foreignptr;
+	//VMs sharing the same state
+	SQSharedState *_sharedstate;
+	SQInteger _nnativecalls;
+	//suspend infos
+	SQBool _suspended;
+	SQBool _suspended_root;
+	SQInteger _suspended_target;
+	SQInteger _suspended_traps;
+};
+
+struct AutoDec{
+	AutoDec(SQInteger *n) { _n = n; }
+	~AutoDec() { (*_n)--; }
+	SQInteger *_n;
+};
+
+inline SQObjectPtr &stack_get(HSQUIRRELVM v,SQInteger idx){return ((idx>=0)?(v->GetAt(idx+v->_stackbase-1)):(v->GetUp(idx)));}
+const SQChar *GetTypeName(const SQObjectPtr &obj1);
+const SQChar *IdType2Name(SQObjectType type);
+
+#define _ss(_vm_) (_vm_)->_sharedstate
+
+#ifndef NO_GARBAGE_COLLECTOR
+#define _opt_ss(_vm_) (_vm_)->_sharedstate
+#else
+#define _opt_ss(_vm_) NULL
+#endif
+
+#define PUSH_CALLINFO(v,nci){ \
+	v->ci = &v->_callsstack.push_back(nci); \
+}
+
+#define POP_CALLINFO(v){ \
+	v->_callsstack.pop_back(); \
+	if(v->_callsstack.size())	\
+		v->ci = &v->_callsstack.back() ; \
+	else	\
+		v->ci = NULL; \
+}
+#endif //_SQVM_H_
